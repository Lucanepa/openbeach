import { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import { useTranslation } from 'react-i18next'
import { useAlert } from '../contexts_beach/AlertContext_beach'
import { useLiveQuery } from 'dexie-react-hooks'
import Dexie from 'dexie'
import { db } from '../db_beach/db_beach'
import Modal from './Modal'

import ConnectionStatus from './ConnectionStatus'
import MenuList from './MenuList'
import ScoreboardOptionsModal from './options/ScoreboardOptionsModal'
import ConnectionSetupModal from './options/ConnectionSetupModal'
import { useSyncQueue } from '../hooks_beach/useSyncQueue_beach'
import { useSequentialSync } from '../hooks_beach/useSequentialSync_beach'
import SyncProgressModal from './SyncProgressModal'
import SignaturePad from './SignaturePad'
import LongPressProgressIndicator from './LongPressProgressIndicator'
import mikasaVolleyball from '../mikasa_v200w.png'

// Primary ball image (with mikasa as fallback)
const ballImage = '/ball.png'
import { debugLogger, createStateSnapshot } from '../utils_beach/debugLogger_beach'
import { useComponentLogging } from '../contexts_beach/LoggingContext_beach'
import { supabase } from '../lib_beach/supabaseClient_beach'
import { exportMatchData } from '../utils_beach/backupManager_beach'

// Sport type for beach volleyball
const SPORT_TYPE = 'beach'
import { uploadBackupToCloud, uploadLogsToCloud, triggerContinuousBackup } from '../utils_beach/logger_beach'
import { splitLocalDateTime, parseLocalDateTimeToISO, roundToMinute } from '../utils_beach/timeUtils_beach'
import { uploadScoresheetAsync } from '../utils_beach/scoresheetUploader_beach'

/**
 * SYNC ARCHITECTURE NOTE:
 * -----------------------
 * This component uses TWO write paths to Supabase (see useSyncQueue.js for full docs):
 *
 * 1. QUEUED: Events, sets, match metadata → db.sync_queue → processed async
 *    Used for: All scoring events, substitutions, timeouts, sanctions
 *    Why: Offline-first, dependency ordering, retry-safe
 *
 * 2. DIRECT: match_live_state → supabase.upsert() immediately
 *    Used for: Real-time spectator display (lineup, scores, serving team)
 *    Why: Sub-second latency needed for live viewing - queue adds 1s+ delay
 *
 * The eventInProgressRef mutex serializes event creation to prevent race
 * conditions (e.g., rapid clicks causing duplicate sets).
 */

export default function Scoreboard({ matchId, scorerAttentionTrigger = null, onFinishSet, onOpenSetup, onOpenMatchSetup, onOpenCoinToss, onTriggerEventBackup }) {
  const { t } = useTranslation()
  const { showAlert } = useAlert()
  const { syncStatus, flush: flushSyncQueue } = useSyncQueue()
  const cLogger = useComponentLogging('Scoreboard')
  const { syncState, syncSetEnd, resetSyncState } = useSequentialSync()
  const [syncModalOpen, setSyncModalOpen] = useState(false)
  const syncProceedCallbackRef = useRef(null)
  // Memoized callback for SyncProgressModal to prevent timer resets on re-render
  const handleSyncProceed = useCallback(() => {
    if (syncProceedCallbackRef.current) {
      syncProceedCallbackRef.current()
      syncProceedCallbackRef.current = null
    }
  }, [])
  const [now, setNow] = useState(() => new Date())
  const [isOnline, setIsOnline] = useState(() =>
    typeof navigator !== 'undefined' ? navigator.onLine : true
  )
  const [duplicateTabError, setDuplicateTabError] = useState(false)
  const tabIdRef = useRef(Math.random().toString(36).substring(2, 15))

  const [showLogs, setShowLogs] = useState(false)
  const [logSearchQuery, setLogSearchQuery] = useState('')
  const [showManualPanel, setShowManualPanel] = useState(false)
  const [manualPanelExpandedSections, setManualPanelExpandedSections] = useState({
    lineup: false,     // Change Current Lineup
    scores: false,     // Score & Sets
    matchSettings: false, // Match Settings (teams setup, status, sides)
    events: false,     // Event History (points, timeouts, subs, sanctions)
    advanced: false,   // Advanced (add events, delete events, times)
    summary: false     // Manual Changes Summary
  })
  const [manualChangesLog, setManualChangesLog] = useState([])
  const [showCurrentSetAdjustment, setShowCurrentSetAdjustment] = useState(false)
  const [showRemarks, setShowRemarks] = useState(false)
  const [remarksText, setRemarksText] = useState('')
  const remarksTextareaRef = useRef(null)
  const [showRosters, setShowRosters] = useState(false)
  const [showSanctions, setShowSanctions] = useState(false)
  const [menuModal, setMenuModal] = useState(false)
  const [showOptionsInMenu, setShowOptionsInMenu] = useState(false)
  const [connectionSetupModal, setConnectionSetupModal] = useState(false)
  const [localManageCaptainOnCourt, setLocalManageCaptainOnCourt] = useState(() => {
    // Load from localStorage, default to false
    const saved = localStorage.getItem('manageCaptainOnCourt')
    return saved === 'true'
  })
  const [checkAccidentalRallyStart, setCheckAccidentalRallyStart] = useState(() => {
    const saved = localStorage.getItem('checkAccidentalRallyStart')
    return saved === 'true' // default false
  })
  const [accidentalRallyStartDuration, setAccidentalRallyStartDuration] = useState(() => {
    const saved = localStorage.getItem('accidentalRallyStartDuration')
    return saved ? parseInt(saved, 10) : 3 // default 3 seconds
  })
  const [checkAccidentalPointAward, setCheckAccidentalPointAward] = useState(() => {
    const saved = localStorage.getItem('checkAccidentalPointAward')
    return saved === 'true' // default false
  })
  const [accidentalPointAwardDuration, setAccidentalPointAwardDuration] = useState(() => {
    const saved = localStorage.getItem('accidentalPointAwardDuration')
    return saved ? parseInt(saved, 10) : 3 // default 3 seconds
  })

  // Set 5 Coin Toss Draft State
  const [set5CoinTossDraft, setSet5CoinTossDraft] = useState({
    serve: 'A', // Default to Team A serving
    sideA: 'left' // Default to Team A on left (standard rotation)
  })
  const [liberoExitConfirmation, setLiberoExitConfirmation] = useState(() => {
    const saved = localStorage.getItem('liberoExitConfirmation')
    return saved !== 'false' // default true
  })
  const [liberoEntrySuggestion, setLiberoEntrySuggestion] = useState(() => {
    const saved = localStorage.getItem('liberoEntrySuggestion')
    return saved !== 'false' // default true
  })
  const [setIntervalDuration, setSetIntervalDuration] = useState(() => {
    const saved = localStorage.getItem('setIntervalDuration')
    return saved ? parseInt(saved, 10) : 180 // default 3 minutes = 180 seconds
  })
  // Score/countdown font: 'default' | 'orbitron'
  const [scoreFont, setScoreFont] = useState(() => {
    const saved = localStorage.getItem('scoreFont')
    return saved || 'default'
  })
  // Display mode: 'desktop' | 'tablet' | 'smartphone' | 'auto'
  const [displayMode, setDisplayMode] = useState(() => {
    const saved = localStorage.getItem('displayMode')
    return saved || 'auto' // default to auto-detect
  })
  const [detectedDisplayMode, setDetectedDisplayMode] = useState('desktop') // What mode was auto-detected
  const [displayModeSuggestion, setDisplayModeSuggestion] = useState(null) // null | 'tablet' | 'smartphone'
  const [showDisplayModeSuggestion, setShowDisplayModeSuggestion] = useState(false)
  const [leftTeamSanctionsExpanded, setLeftTeamSanctionsExpanded] = useState(false)
  const [rightTeamSanctionsExpanded, setRightTeamSanctionsExpanded] = useState(false)
  const [leftTeamBenchExpanded, setLeftTeamBenchExpanded] = useState(false)
  const [rightTeamBenchExpanded, setRightTeamBenchExpanded] = useState(false)
  // Main layout collapsible sections (collapsed by default on tablet)
  const [leftMainBenchExpanded, setLeftMainBenchExpanded] = useState(false)
  const [rightMainBenchExpanded, setRightMainBenchExpanded] = useState(false)
  const [leftMainLiberosExpanded, setLeftMainLiberosExpanded] = useState(false)
  const [rightMainLiberosExpanded, setRightMainLiberosExpanded] = useState(false)
  const [leftMainOfficialsExpanded, setLeftMainOfficialsExpanded] = useState(false)
  const [rightMainOfficialsExpanded, setRightMainOfficialsExpanded] = useState(false)
  const [rallyStatusExpanded, setRallyStatusExpanded] = useState(false) // Toggle rally status/last action size
  const [accidentalRallyConfirmModal, setAccidentalRallyConfirmModal] = useState(null) // { onConfirm: function } | null
  const [accidentalPointConfirmModal, setAccidentalPointConfirmModal] = useState(null) // { team: 'home'|'away', onConfirm: function } | null
  const lastPointAwardedTimeRef = useRef(null) // Track when last point was awarded
  const rallyStartTimeRef = useRef(null) // Track when rally started
  // MUTEX: Serializes event creation to prevent race conditions (e.g., rapid clicks creating duplicate sets)
  // See architecture note at top of file. All event-creating functions acquire this lock.
  const eventInProgressRef = useRef(false)
  const eventQueueRef = useRef([]) // Queue for serializing event creation
  const confirmingTimeoutRef = useRef(false) // Prevent double-click on timeout confirmation
  const [keybindingsEnabled, setKeybindingsEnabled] = useState(() => {
    const saved = localStorage.getItem('keybindingsEnabled')
    return saved === 'true' // default false
  })
  const [keybindingsModalOpen, setKeybindingsModalOpen] = useState(false)
  const defaultKeyBindings = {
    pointLeft: 'a',
    pointRight: 'l',
    timeoutLeft: 'q',
    timeoutRight: 'p',
    exchangeLiberoLeft: 'x',
    exchangeLiberoRight: 'n',
    undo: 'Backspace',
    confirm: 'Enter',
    cancel: 'Escape',
    startRally: 'Enter'
  }
  const [keyBindings, setKeyBindings] = useState(() => {
    const saved = localStorage.getItem('keyBindings')
    if (saved) {
      try {
        return { ...defaultKeyBindings, ...JSON.parse(saved) }
      } catch {
        return defaultKeyBindings
      }
    }
    return defaultKeyBindings
  })
  const [editingKey, setEditingKey] = useState(null) // Which key binding is being edited

  const [serverRunning, setServerRunning] = useState(false)
  const [serverStatus, setServerStatus] = useState(null)
  const [serverLoading, setServerLoading] = useState(false)
  const [editPinModal, setEditPinModal] = useState(false)
  const [showPinsModal, setShowPinsModal] = useState(false)
  const [newPin, setNewPin] = useState('')
  const [pinError, setPinError] = useState('')
  const [editPinType, setEditPinType] = useState(null) // 'referee' | 'teamA' | 'teamB'
  const [connectionModal, setConnectionModal] = useState(null) // 'referee' | 'teamA' | 'teamB' | null
  const [connectionModalPosition, setConnectionModalPosition] = useState({ x: 0, y: 0 })
  const [courtSwitchModal, setCourtSwitchModal] = useState(null) // { set, homePoints, awayPoints, teamThatScored } | null
  const [timeoutModal, setTimeoutModal] = useState(null) // { team: 'home'|'away', countdown: number, started: boolean }
  const [duplicateTimeoutConfirm, setDuplicateTimeoutConfirm] = useState(null) // { team: 'home'|'away' } - confirmation for duplicate TO
  const [betweenSetsCountdown, setBetweenSetsCountdown] = useState(null) // { countdown: number, started: boolean, finished?: boolean } | null
  const countdownDismissedRef = useRef(false) // Track if countdown was manually dismissed
  const setEndModalDismissedRef = useRef(null) // Track setIndex where set end modal was dismissed via undo
  const confirmedSetEndRef = useRef(new Set()) // Track which sets have been confirmed to prevent double-processing
  const timeoutStartTimestampRef = useRef(null) // Timestamp when timeout started
  const timeoutInitialCountdownRef = useRef(30) // Initial timeout duration
  const betweenSetsStartTimestampRef = useRef(null) // Timestamp when between-sets interval started
  const betweenSetsInitialCountdownRef = useRef(180) // Initial between-sets duration
  const [lineupModal, setLineupModal] = useState(null) // { team: 'home'|'away', mode?: 'initial'|'manual' } | null
  const [peekingLineup, setPeekingLineup] = useState({ left: false, right: false }) // Track which team's lineup is being peeked

  // Reset peeking state on any mouseup/touchend (since overlay disappears when peeking)
  useEffect(() => {
    const resetPeeking = () => setPeekingLineup({ left: false, right: false })
    document.addEventListener('mouseup', resetPeeking)
    document.addEventListener('touchend', resetPeeking)
    return () => {
      document.removeEventListener('mouseup', resetPeeking)
      document.removeEventListener('touchend', resetPeeking)
    }
  }, [])

  const [scoresheetErrorModal, setScoresheetErrorModal] = useState(null) // { error: string, details?: string } | null
  const [exceptionalSubstitutionModal, setExceptionalSubstitutionModal] = useState(null) // { team: 'home'|'away', position: string, playerOut: number, reason: 'expulsion'|'disqualification'|'injury' } | null
  const [substitutionDropdown, setSubstitutionDropdown] = useState(null) // { team: 'home'|'away', position: 'I'|'II'|'III'|'IV'|'V'|'VI', playerNumber: number, element: HTMLElement, isInjury?: boolean } | null
  const [substitutionConfirm, setSubstitutionConfirm] = useState(null) // { team: 'home'|'away', position: 'I'|'II'|'III'|'IV'|'V'|'VI', playerOut: number, playerIn: number, isInjury?: boolean, isExceptional?: boolean, isExpelled?: boolean, isDisqualified?: boolean } | null
  const [liberoDropdown, setLiberoDropdown] = useState(null) // { team: 'home'|'away', position: 'I'|'V'|'VI', playerNumber: number, element: HTMLElement } | null
  const [liberoConfirm, setLiberoConfirm] = useState(null) // { team: 'home'|'away', position: 'I'|'V'|'VI', playerOut: number, liberoIn: string } | null
  const [liberoInDropdown, setLiberoInDropdown] = useState(null) // { team: 'home'|'away', side: 'left'|'right', element: HTMLElement, x?: number, y?: number } | null
  const [undoConfirm, setUndoConfirm] = useState(null) // { event: Event, description: string } | null
  const [liberoReminder, setLiberoReminder] = useState(null) // { teams: ['home'|'away'] } | null - Show reminder at start of set
  const [liberoRotationModal, setLiberoRotationModal] = useState(null) // { team: 'home'|'away', position: 'IV', liberoNumber: number, playerNumber: number } | null
  const [exchangeLiberoDropdown, setExchangeLiberoDropdown] = useState(null) // { team: 'home'|'away', position: 'I'|'V'|'VI', liberoNumber: number, element: HTMLElement } | null
  const [liberoReentryModal, setLiberoReentryModal] = useState(null) // { team: 'home'|'away', position: 'I', playerNumber: number, liberoNumber: number, liberoType: string, availableLiberos: [{number, type, label}], selectedLiberoIndex: number } | null
  const [liberoSuggestionDismissedForExit, setLiberoSuggestionDismissedForExit] = useState({ home: null, away: null }) // Track which libero_exit event (by timestamp) was dismissed to avoid repeated suggestions
  const [liberoRedesignationModal, setLiberoRedesignationModal] = useState(null) // { team: 'home'|'away', unableLiberoNumber: number, unableLiberoType: string, reason: 'declared'|'injury'|'expulsion'|'disqualification' } | null
  const [liberoUnableModal, setLiberoUnableModal] = useState(null) // { team: 'home'|'away', liberoNumber: number, liberoType: string, reason?: 'declared'|'injury' } | null
  const [liberoBenchActionMenu, setLiberoBenchActionMenu] = useState(null) // { team: 'home'|'away', liberoNumber: number, liberoType: string, element: HTMLElement, x: number, y: number } | null
  const [captainOnCourtModal, setCaptainOnCourtModal] = useState(null) // { team: 'home'|'away' } | null
  const [reopenSetConfirm, setReopenSetConfirm] = useState(null) // { setId: number, setIndex: number } | null
  const [setStartTimeModal, setSetStartTimeModal] = useState(null) // { setIndex: number, defaultTime: string } | null
  const [setEndTimeModal, setSetEndTimeModal] = useState(null) // { setIndex: number, winner: string, homePoints: number, awayPoints: number, defaultTime: string } | null
  const [set5SideServiceModal, setSet5SideServiceModal] = useState(null) // { setIndex: number, set4LeftTeamLabel: string, set4RightTeamLabel: string, set4ServingTeamLabel: string } | null - shown after set 4 ends
  const [set5SelectedLeftTeam, setSet5SelectedLeftTeam] = useState('A')
  const [set5SelectedFirstServe, setSet5SelectedFirstServe] = useState('A')
  const [setTransitionLoading, setSetTransitionLoading] = useState(null) // { step: string } | null - Loading overlay during set transition
  const [set5SetupConfirmed, setSet5SetupConfirmed] = useState(false) // Track if Set 5 coin toss setup is confirmed (inline UI)
  const [postMatchSignature, setPostMatchSignature] = useState(null) // 'home-captain' | 'away-captain' | null
  const [sanctionConfirm, setSanctionConfirm] = useState(null) // { side: 'left'|'right', type: 'improper_request'|'delay_warning'|'delay_penalty' } | null
  const [sanctionDropdown, setSanctionDropdown] = useState(null) // { team: 'home'|'away', type: 'player'|'bench'|'libero'|'official', playerNumber?: number, position?: string, role?: string, element: HTMLElement, x?: number, y?: number } | null
  const [sanctionConfirmModal, setSanctionConfirmModal] = useState(null) // { team: 'home'|'away', type: 'player'|'bench'|'libero'|'official', playerNumber?: number, position?: string, role?: string, sanctionType: 'warning'|'penalty'|'expulsion'|'disqualification' } | null
  const [sanctionSubstitutionModal, setSanctionSubstitutionModal] = useState(null) // { team, expelledPlayer, liberoOnCourt?, availableSubs, reason: 'expulsion'|'disqualification', isExceptional: boolean, position?: string } | null
  const [injuryDropdown, setInjuryDropdown] = useState(null) // { team: 'home'|'away', position: 'I'|'II'|'III'|'IV'|'V'|'VI', playerNumber: number, element: HTMLElement, x?: number, y?: number } | null
  const [playerActionMenu, setPlayerActionMenu] = useState(null) // { team: 'home'|'away', position: 'I'|'II'|'III'|'IV'|'V'|'VI', playerNumber: number, element: HTMLElement, x?: number, y?: number, canSubstitute: boolean, canEnterLibero: boolean } | null
  const [benchPlayerActionMenu, setBenchPlayerActionMenu] = useState(null) // { team: 'home'|'away', playerNumber: number, element: HTMLElement, x?: number, y?: number, canSubstitute: boolean, courtPlayerToSwapWith?: { number: number, position: string } } | null
  const [benchSubExpanded, setBenchSubExpanded] = useState(false) // Track if substitution list is expanded in bench player menu
  const [courtSubExpanded, setCourtSubExpanded] = useState(false) // Track if substitution list is expanded in court player menu
  const [courtSanctionExpanded, setCourtSanctionExpanded] = useState(false) // Track if sanction list is expanded in court player menu
  const [courtLiberoExpanded, setCourtLiberoExpanded] = useState(false) // Track if libero list is expanded in court player menu
  const [courtLiberoUnableExpanded, setCourtLiberoUnableExpanded] = useState(false) // Track if "Unable to play" submenu is expanded
  const [benchSanctionExpanded, setBenchSanctionExpanded] = useState(false) // Track if sanction list is expanded in bench player menu
  const [liberoBenchReplaceExpanded, setLiberoBenchReplaceExpanded] = useState(false) // Track if replace list is expanded in libero bench menu
  const [liberoBenchUnableExpanded, setLiberoBenchUnableExpanded] = useState(false) // Track if "Unable to play" submenu is expanded in libero bench menu
  const [leftLiberoDropdownOpen, setLeftLiberoDropdownOpen] = useState(false) // Narrow mode dropdown for left team libero buttons
  const [rightLiberoDropdownOpen, setRightLiberoDropdownOpen] = useState(false) // Narrow mode dropdown for right team libero buttons
  const [leftDelaysDropdownOpen, setLeftDelaysDropdownOpen] = useState(false) // Narrow mode dropdown for left team delays/sanctions buttons
  const [rightDelaysDropdownOpen, setRightDelaysDropdownOpen] = useState(false) // Narrow mode dropdown for right team delays/sanctions buttons
  const [toSubDetailsModal, setToSubDetailsModal] = useState(null) // { type: 'timeout'|'substitution', side: 'left'|'right' } | null
  const [showHelpModal, setShowHelpModal] = useState(false)
  const [selectedHelpTopic, setSelectedHelpTopic] = useState(null)
  const [replayRallyConfirm, setReplayRallyConfirm] = useState(null) // { event: Event, description: string, selectedOption: 'swap'|'replay' } | null
  const [stopMatchModal, setStopMatchModal] = useState(null) // 'select' | null - Stop the match modal selection
  const [stopMatchTeamSelect, setStopMatchTeamSelect] = useState(null) // { pendingAction: 'forfeit' } | null - Team selection for forfeit
  const [stopMatchConfirm, setStopMatchConfirm] = useState(null) // { type: 'forfeit'|'impossibility', team?: 'home'|'away' } | null - Confirmation modal
  const [stopMatchRemarksStep, setStopMatchRemarksStep] = useState(null) // { type: 'forfeit'|'impossibility', team?: 'home'|'away' } | null - After remarks
  const [recentlySubstitutedPlayers, setRecentlySubstitutedPlayers] = useState([]) // [{ team, playerNumber, timestamp }] - for flashing effect
  const recentSubFlashTimeoutRef = useRef(null) // Timeout ref for clearing flash
  const leftCourtPositionVRef = useRef(null) // Ref for position V on left court (for modal positioning)
  const rightCourtPositionIIRef = useRef(null) // Ref for position II on right court (for modal positioning)

  // Header collapse state
  const [headerCollapsed, setHeaderCollapsed] = useState(false)
  const [showNamesOnCourt, setShowNamesOnCourtState] = useState(() => {
    const saved = localStorage.getItem('showNamesOnCourt')
    return saved === 'true' // default false
  })
  const setShowNamesOnCourt = (val) => {
    setShowNamesOnCourtState(val)
    localStorage.setItem('showNamesOnCourt', String(val))
  }
  const [expandedPlayerName, setExpandedPlayerName] = useState(null) // 'home-12' | 'away-5' | null - tracks which player name is expanded
  const [autoDownloadAtSetEnd, setAutoDownloadAtSetEnd] = useState(true)
  const [viewportWidth, setViewportWidth] = useState(() => typeof window !== 'undefined' ? window.innerWidth : 1366)
  const [viewportHeight, setViewportHeight] = useState(() => typeof window !== 'undefined' ? window.innerHeight : 768)
  // Compact mode: landscape (width >= height) = width <= 960 OR height < 768
  //               portrait (height > width) = height <= 960 OR width < 768
  const isLandscape = viewportWidth >= viewportHeight
  const isCompactMode = isLandscape
    ? (viewportWidth <= 960 || viewportHeight < 768)
    : (viewportHeight <= 960 || viewportWidth < 768)
  const isVeryCompact = isLandscape
    ? (viewportWidth <= 800 || viewportHeight < 600)
    : (viewportHeight <= 800 || viewportWidth < 600)
  // Laptop mode: between compact (960) and full desktop (1400) - smaller UI than full desktop
  const isLaptopMode = !isCompactMode && viewportWidth > 960 && viewportWidth <= 1400
  // Narrow mode: < 1000px - collapse buttons into dropdowns, column layout for counters
  const isNarrowMode = viewportWidth < 1000
  // Short height mode: < 900px - smaller counters, clickable TO counter, hide TO button
  const isShortHeight = viewportHeight < 900
  const wsRef = useRef(null) // Store WebSocket connection for use in callbacks
  const previousMatchIdRef = useRef(null) // Track previous matchId to detect changes
  const wakeLockRef = useRef(null) // Wake lock to prevent screen sleep
  const syncFunctionRef = useRef(null) // Store sync function for use in action handlers
  const noSleepVideoRef = useRef(null) // Video element for NoSleep fallback
  const checkAndRequestCaptainOnCourtRef = useRef(null) // Store latest captain check function
  const logEventRef = useRef(null) // Store latest logEvent function to avoid circular dependencies

  // Request wake lock to prevent screen from sleeping
  useEffect(() => {
    // Create a tiny looping video that keeps the screen awake on mobile/tablets
    const createNoSleepVideo = () => {
      if (noSleepVideoRef.current) return

      // Base64 encoded tiny MP4 video (blank, silent, loops)
      const mp4 = 'data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAA1VtZGF0AAACrQYF//+p3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE1NSByMjkxNyAwYTg0ZDk4IC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxOCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDExMyBtZT1oZXggc3VibWU9NyBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0xIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MSA4eDhkY3Q9MSBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0tMiB0aHJlYWRzPTMgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAbWWIhAAz//727L4FNf2f0JcRLMXaSnA+KqSAgHc0wAAAAwAAAwAAV/8iZ2P/4kTVAAIgAAABHQZ4iRPCv/wAAAwAAAwAAHxQSRJ2C2E0AAAMAAAMAYOLkAADAAAHPgVxpAAKGAAABvBqIAg5LAH4AABLNAAAAHEGeQniFfwAAAwAAAwACNQsIAADAAADABOvIgAAAABoBnmF0Rn8AAAMAAAMAAApFAADAAADAECGAAHUAAAAaAZ5jakZ/AAADAAADAAClYlVkAAADAAADAJdwAAAAVUGaZkmoQWyZTAhv//6qVQAAAwAACjIWAANXJ5AAVKLiPqsAAHG/pAALrZ6AAHUhqAAC8QOAAHo0KAAHqwIAAeNf4AAcfgdSAAGdg+sAAOCnAABH6AAAADdBnoRFESwn/wAAAwAAAwAB7YZ+YfJAAOwAkxZiAgABmtQACVrdYAAbcqMAAPMrOAAH1LsAAJ5gAAAAGgGeo3RGfwAAAwAAAwAAXHMAADAAADAEfmAAdQAAABoBnqVqRn8AAAMAAAMAAKReyQADAAADABYxgAAAAFVBmqpJqEFsmUwIb//+qlUAAAMAAAoWMAANXIYAAUZC4kLQAB8rCgABTxKAADq86AAFHAwAAe3E4AAdTHoAAahnMAAL7zYAAR9BcAAN0SgAASNvQAAAADdBnshFFSwn/wAAAwAAAwAB7YZ+YfJAAOwAkxZiAgABvNIACVqdYAAbcqMAAPcquAAH1LsAAJ5gAAAAGgGe53RGfwAAAwAAAwAAXHUAADAAADAEfmAAdQAAABoBnulqRn8AAAMAAAMAAKRhXQADAAADABVxgAAAAGhBmu5JqEFsmUwIb//+qlUAAAMAAH8yQAB7sgACKrBcSAAIKXS4AAd8MAAG7xwAApriMAASJiQAAXfPOAACmvmAACNqrgAB2OyYAAm0kwABRZvgABCrlAAC7SfAABqJMAAHpZugAAAzQZ8MRRUsJ/8AAAMAAAMA5nIA/VBzAADYASYsxBwAA3mjABLVOsAANuVGAAHuVnAACuYAAAAXAZ8rdEZ/AAADAAADABSsSqyAYAC6zAAAdQAAABkBny1qRn8AAAMAAAMAFGpKrIBgAMDOJKAAdQA='

      const video = document.createElement('video')
      video.setAttribute('playsinline', '')
      video.setAttribute('muted', '')
      video.setAttribute('loop', '')
      video.setAttribute('src', mp4)
      video.style.position = 'fixed'
      video.style.top = '-9999px'
      video.style.left = '-9999px'
      video.style.width = '1px'
      video.style.height = '1px'
      document.body.appendChild(video)
      noSleepVideoRef.current = video

      return video
    }

    const enableNoSleep = async () => {
      // First try native Wake Lock API (works on desktop browsers)
      try {
        if ('wakeLock' in navigator) {
          wakeLockRef.current = await navigator.wakeLock.request('screen')
          wakeLockRef.current.addEventListener('release', () => { })
        }
      } catch (err) {
        // Wake lock not supported or failed
      }

      // Also use video trick as fallback (better for tablets/mobile)
      try {
        const video = createNoSleepVideo()
        if (video) {
          await video.play()
        }
      } catch (err) {
        // Video wake lock failed
      }
    }

    // Enable on user interaction (required on some devices)
    const handleInteraction = () => {
      enableNoSleep()
      document.removeEventListener('click', handleInteraction)
      document.removeEventListener('touchstart', handleInteraction)
    }

    enableNoSleep()
    document.addEventListener('click', handleInteraction, { once: true })
    document.addEventListener('touchstart', handleInteraction, { once: true })

    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        enableNoSleep()
      }
    }
    document.addEventListener('visibilitychange', handleVisibilityChange)

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange)
      document.removeEventListener('click', handleInteraction)
      document.removeEventListener('touchstart', handleInteraction)
      if (wakeLockRef.current) {
        wakeLockRef.current.release()
        wakeLockRef.current = null
      }
      if (noSleepVideoRef.current) {
        noSleepVideoRef.current.pause()
        noSleepVideoRef.current.remove()
        noSleepVideoRef.current = null
      }
    }
  }, [])
  const [connectionStatuses, setConnectionStatuses] = useState({
    api: 'unknown',
    server: 'unknown',
    websocket: 'unknown',
    scoreboard: 'unknown',
    match: 'unknown',
    db: 'unknown'
  })
  const [connectionDebugInfo, setConnectionDebugInfo] = useState({})
  const [showDebugMenu, setShowDebugMenu] = useState(null) // Which connection type to show debug for


  useEffect(() => {
    const timer = setInterval(() => setNow(new Date()), 1000)
    return () => clearInterval(timer)
  }, [])

  // Single-tab enforcement - prevent opening scoresheet in multiple tabs for same match
  useEffect(() => {
    if (!matchId) return

    const channelName = `scoresheet-${matchId}`
    const storageKey = `scoresheet-active-${matchId}`
    const tabId = tabIdRef.current

    // Try to claim this tab as active
    const existingTab = localStorage.getItem(storageKey)
    if (existingTab && existingTab !== tabId) {
      // Another tab might be active, check via BroadcastChannel
      try {
        const channel = new BroadcastChannel(channelName)

        // Ask if any other tab is active
        const checkTimeout = setTimeout(() => {
          // No response, claim the tab
          localStorage.setItem(storageKey, tabId)
          channel.close()
        }, 200)

        channel.onmessage = (event) => {
          if (event.data.type === 'PING') {
            // Another tab is checking, respond
            channel.postMessage({ type: 'PONG', tabId: tabId })
          } else if (event.data.type === 'PONG' && event.data.tabId !== tabId) {
            // Another tab responded, this is a duplicate
            clearTimeout(checkTimeout)
            setDuplicateTabError(true)
            channel.close()
          } else if (event.data.type === 'NEW_TAB' && event.data.tabId !== tabId) {
            // A new tab just opened, tell it we're here
            channel.postMessage({ type: 'PONG', tabId: tabId })
          }
        }

        // Announce ourselves
        channel.postMessage({ type: 'NEW_TAB', tabId: tabId })

        return () => {
          clearTimeout(checkTimeout)
          channel.close()
          // Only remove from storage if we're the active tab
          if (localStorage.getItem(storageKey) === tabId) {
            localStorage.removeItem(storageKey)
          }
        }
      } catch {
        // BroadcastChannel not supported, fall back to localStorage only
        localStorage.setItem(storageKey, tabId)
      }
    } else {
      // Claim this tab as active
      localStorage.setItem(storageKey, tabId)
    }

    // Set up BroadcastChannel for ongoing communication
    let channel
    try {
      channel = new BroadcastChannel(channelName)

      channel.onmessage = (event) => {
        if (event.data.type === 'PING' || event.data.type === 'NEW_TAB') {
          // Another tab is checking or just opened, respond
          channel.postMessage({ type: 'PONG', tabId: tabId })
        }
      }
    } catch {
      // BroadcastChannel not supported
    }

    // Listen for storage events (when another tab changes localStorage)
    const handleStorage = (e) => {
      if (e.key === storageKey && e.newValue && e.newValue !== tabId) {
        // Another tab just claimed active status
        setDuplicateTabError(true)
      }
    }
    window.addEventListener('storage', handleStorage)

    return () => {
      window.removeEventListener('storage', handleStorage)
      if (channel) channel.close()
      // Only remove from storage if we're the active tab
      if (localStorage.getItem(storageKey) === tabId) {
        localStorage.removeItem(storageKey)
      }
    }
  }, [matchId])

  // Send heartbeat to indicate scoresheet is active
  useEffect(() => {
    if (!matchId) return

    const updateHeartbeat = async () => {
      try {
        await db.matches.update(matchId, {
          updatedAt: new Date().toISOString()
        })
      } catch (error) {
        // Silently fail - not critical
      }
    }

    // Initial heartbeat
    updateHeartbeat()

    // Update heartbeat every 10 seconds
    const interval = setInterval(updateHeartbeat, 10000)

    return () => clearInterval(interval)
  }, [matchId])

  // Clear confirmed set end tracking when match changes
  useEffect(() => {
    confirmedSetEndRef.current.clear()
  }, [matchId])

  // Screen size detection for display mode suggestions
  // Improved detection: check both screen size and touch capability
  // < 600px + touch = smartphone, 600-900px + touch = tablet, > 900px or no touch = desktop
  useEffect(() => {
    const checkScreenSize = () => {
      const width = window.innerWidth
      const height = window.innerHeight
      const hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0)
      let detected = 'desktop'
      let suggestion = null

      // Smartphone: narrow screen (<= 600px) with touch, or very narrow (<= 480px) even without touch
      if ((width <= 600 && hasTouch) || width <= 480) {
        detected = 'smartphone'
        suggestion = 'smartphone'
      }
      // Tablet: medium screen (600-900px) with touch
      else if (width <= 900 && hasTouch) {
        detected = 'tablet'
        suggestion = 'tablet'
      }
      // Desktop: > 900px OR no touch capability
      // This ensures laptops are always desktop even if screen is narrower

      setDetectedDisplayMode(detected)

      // Only show suggestion if in auto mode and we detected a smaller screen
      if (displayMode === 'auto' && suggestion) {
        // Check if user already dismissed this suggestion
        const dismissedSuggestion = sessionStorage.getItem('displayModeSuggestionDismissed')
        if (!dismissedSuggestion) {
          setDisplayModeSuggestion(suggestion)
          setShowDisplayModeSuggestion(true)
        }
      }
    }

    // Check on mount
    checkScreenSize()

    // Check on resize
    window.addEventListener('resize', checkScreenSize)
    return () => window.removeEventListener('resize', checkScreenSize)
  }, [displayMode])

  // Track viewport size for responsive layout
  useEffect(() => {
    const handleResize = () => {
      setViewportWidth(window.innerWidth)
      setViewportHeight(window.innerHeight)
    }
    window.addEventListener('resize', handleResize)
    return () => window.removeEventListener('resize', handleResize)
  }, [])

  // Auto-lock orientation to landscape for scoreboard on mount
  useEffect(() => {
    const lockLandscape = async () => {
      try {
        if (screen.orientation && screen.orientation.lock) {
          await screen.orientation.lock('landscape')
        }
      } catch (err) {
        // Orientation lock not supported
      }
    }
    lockLandscape()

    return () => {
      // Unlock orientation when leaving scoreboard
      if (screen.orientation && screen.orientation.unlock) {
        try {
          screen.orientation.unlock()
        } catch (err) {
          // Ignore unlock errors
        }
      }
    }
  }, [])

  // Get the active display mode (either forced or auto-detected)
  const activeDisplayMode = displayMode === 'auto' ? detectedDisplayMode : displayMode

  // Fullscreen and orientation lock for tablet/smartphone modes
  const enterDisplayMode = useCallback((mode) => {
    // Request fullscreen
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen().catch(err => {
        // Fullscreen not supported
      })
    }

    // Try to lock orientation to landscape (may not work on all browsers)
    if (screen.orientation && screen.orientation.lock) {
      screen.orientation.lock('landscape').catch(() => { })
    }

    // Set the display mode
    setDisplayMode(mode)
    localStorage.setItem('displayMode', mode)
    setShowDisplayModeSuggestion(false)
    sessionStorage.setItem('displayModeSuggestionDismissed', 'true')
  }, [])

  // Exit fullscreen and reset to desktop mode
  const exitDisplayMode = useCallback(() => {
    if (document.exitFullscreen && document.fullscreenElement) {
      document.exitFullscreen().catch(err => {
        // Exit fullscreen failed
      })
    }

    // Unlock orientation
    if (screen.orientation && screen.orientation.unlock) {
      screen.orientation.unlock()
    }

    setDisplayMode('desktop')
    localStorage.setItem('displayMode', 'desktop')
  }, [])

  const data = useLiveQuery(async () => {
    const match = await db.matches.get(matchId)
    if (!match) return null

    const [homeTeam, awayTeam] = await Promise.all([
      match?.homeTeamId ? db.teams.get(match.homeTeamId) : null,
      match?.awayTeamId ? db.teams.get(match.awayTeamId) : null
    ])

    const sets = await db.sets
      .where('matchId')
      .equals(matchId)
      .sortBy('index')

    // Find the current set: first unfinished set, preferring highest id if duplicates exist
    // Also filter out any duplicate indices, keeping the latest one (highest id)
    const setsByIndex = new Map()
    for (const set of sets) {
      const existing = setsByIndex.get(set.index)
      if (!existing || set.id > existing.id) {
        setsByIndex.set(set.index, set)
      }
    }
    const dedupedSets = Array.from(setsByIndex.values()).sort((a, b) => a.index - b.index)
    const currentSet = dedupedSets.find(s => !s.finished) ?? null

    const [homePlayers, awayPlayers] = await Promise.all([
      match?.homeTeamId
        ? db.players.where('teamId').equals(match.homeTeamId).sortBy('number')
        : [],
      match?.awayTeamId
        ? db.players.where('teamId').equals(match.awayTeamId).sortBy('number')
        : []
    ])

    // Get all events for the match (keep logs across sets)
    // Sort by seq if available, otherwise by ts
    const eventsRaw = await db.events
      .where('matchId')
      .equals(matchId)
      .toArray()

    const events = eventsRaw.sort((a, b) => {
      // Sort by sequence number if available
      const aSeq = a.seq || 0
      const bSeq = b.seq || 0
      if (aSeq !== 0 || bSeq !== 0) {
        return aSeq - bSeq // Ascending
      }
      // Fallback to timestamp for legacy events
      const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
      const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
      return aTime - bTime
    })

    // Log all action IDs to track sequence numbers (show only base integer IDs, not decimals)
    const baseActionIds = events
      .map(e => {
        const seq = e.seq || 0
        return Math.floor(seq) // Get integer part only
      })
      .filter(id => id > 0)
      .filter((id, index, self) => self.indexOf(id) === index) // Remove duplicates

    // Action IDs tracked internally

    const result = {
      set: currentSet,
      match,
      homeTeam,
      awayTeam,
      homePlayers,
      awayPlayers,
      events,
      sets
    }

    return result
  }, [matchId])

  // Check if Set 5 was already confirmed (on mount or when entering Set 5)
  useEffect(() => {
    if (!data?.set || !data?.events) return
    if (data.set.index !== 5) return

    // Check if Set 5 has already started (has points or set5_coin_toss event)
    const hasSet5CoinToss = data.events.some(e => e.type === 'set5_coin_toss' && e.setIndex === 5)
    const hasSet5Points = data.events.some(e => e.type === 'point' && e.setIndex === 5)

    if (hasSet5CoinToss || hasSet5Points) {
      setSet5SetupConfirmed(true)
    }
  }, [data?.set?.index, data?.events])



  // Helper to create state snapshot for debug logging
  const getStateSnapshot = useCallback(() => {
    if (!data) return null
    return {
      matchId: data.match?.id,
      setIndex: data.set?.index,
      homeScore: data.set?.homeScore,
      awayScore: data.set?.awayScore,
      currentServe: data.set?.currentServe,
      homeRotation: data.set?.homeRotation,
      awayRotation: data.set?.awayRotation,
      homeOnCourt: data.set?.homeOnCourt,
      awayOnCourt: data.set?.awayOnCourt,
      homeLiberoIn: data.set?.homeLiberoIn,
      awayLiberoIn: data.set?.awayLiberoIn,
      homeLiberoFor: data.set?.homeLiberoFor,
      awayLiberoFor: data.set?.awayLiberoFor,
      homeTimeouts: data.set?.homeTimeouts,
      awayTimeouts: data.set?.awayTimeouts,
      rallyInProgress: data.set?.rallyInProgress,
      homeSetsWon: data.sets?.filter(s => s.winner === 'home').length,
      awaySetsWon: data.sets?.filter(s => s.winner === 'away').length,
      totalEvents: data.events?.length
    }
  }, [data])

  // Load existing manual changes when panel opens
  useEffect(() => {
    if (showManualPanel && data?.match?.manualChanges) {
      setManualChangesLog(data.match.manualChanges)
    }
  }, [showManualPanel, data?.match?.manualChanges])

  // Capture FULL state snapshot for snapshot-based undo system
  // This captures everything needed to restore the match state completely
  const captureFullStateSnapshot = useCallback(async () => {
    const _ts = performance.now()
    if (!matchId) return null

    try {
      // Query fresh data from IndexedDB to avoid stale closure issues
      const match = await db.matches.get(matchId)
      if (!match) return null
      console.log(`[PERF:snapshot] After match.get: +${(performance.now() - _ts).toFixed(0)}ms`)

      // Get current set from database
      const allSets = await db.sets.where({ matchId }).toArray()
      const currentSet = allSets.find(s => !s.finished) || allSets[allSets.length - 1]
      if (!currentSet) return null
      console.log(`[PERF:snapshot] After sets query: +${(performance.now() - _ts).toFixed(0)}ms`)

      // Get all events from database
      const allEvents = await db.events.where({ matchId }).toArray()
      console.log(`[PERF:snapshot] After events query (${allEvents.length} events): +${(performance.now() - _ts).toFixed(0)}ms`)

      // Get players from database
      const [homePlayersDb, awayPlayersDb] = await Promise.all([
        match.homeTeamId ? db.players.where('teamId').equals(match.homeTeamId).toArray() : [],
        match.awayTeamId ? db.players.where('teamId').equals(match.awayTeamId).toArray() : []
      ])
      console.log(`[PERF:snapshot] After players query: +${(performance.now() - _ts).toFixed(0)}ms`)

      // Compute current state
      const finishedSets = allSets.filter(s => s.finished)
      const homeSetsWon = finishedSets.filter(s => s.homePoints > s.awayPoints).length
      const awaySetsWon = finishedSets.filter(s => s.awayPoints > s.homePoints).length

      // A/B Model: Team A = coin toss winner (constant), side_a = which side they're on
      const setIndex = currentSet.index
      const teamAKey = match.coinTossTeamA || 'home'
      const teamBKey = teamAKey === 'home' ? 'away' : 'home'
      const is5thSet = setIndex === 5
      const set5CourtSwitched = match.set5CourtSwitched
      const set5LeftTeam = match.set5LeftTeam

      // Determine which side Team A is on this set
      // setLeftTeamOverrides stores 'A' or 'B' - which team is on the LEFT
      const setLeftTeamOverrides = match.setLeftTeamOverrides || {}
      let sideA
      if (setLeftTeamOverrides[setIndex] !== undefined) {
        // Override stores 'A' or 'B', not 'home'/'away'
        sideA = setLeftTeamOverrides[setIndex] === 'A' ? 'left' : 'right'
      } else if (is5thSet && set5LeftTeam) {
        // Use set5LeftTeam for Set 5 (from coin toss or manual switch)
        sideA = set5LeftTeam === 'A' ? 'left' : 'right'
      } else {
        sideA = setIndex % 2 === 1 ? 'left' : 'right'
      }

      // If Set 5 court switch at 8 points has happened, flip the sides
      if (is5thSet && set5CourtSwitched) {
        sideA = sideA === 'left' ? 'right' : 'left'
      }

      // Team names and colors
      const teamAName = teamAKey === 'home' ? match.homeName : match.awayName
      const teamBName = teamAKey === 'home' ? match.awayName : match.homeName
      const teamAShort = teamAKey === 'home' ? match.homeShortName : match.awayShortName
      const teamBShort = teamAKey === 'home' ? match.awayShortName : match.homeShortName
      const teamAColor = teamAKey === 'home' ? match.homeColor : match.awayColor
      const teamBColor = teamAKey === 'home' ? match.awayColor : match.homeColor

      // Points and set scores
      const pointsA = teamAKey === 'home' ? currentSet.homePoints : currentSet.awayPoints
      const pointsB = teamAKey === 'home' ? currentSet.awayPoints : currentSet.homePoints
      const setScoreA = teamAKey === 'home' ? homeSetsWon : awaySetsWon
      const setScoreB = teamAKey === 'home' ? awaySetsWon : homeSetsWon

      // Current set events
      const currentSetEvents = allEvents.filter(e => e.setIndex === currentSet.index)

      // Timeouts
      const timeouts = currentSetEvents.filter(e => e.type === 'timeout').reduce((acc, e) => {
        const team = e.payload?.team
        if (team) acc[team] = (acc[team] || 0) + 1
        return acc
      }, { home: 0, away: 0 })
      const timeoutsA = teamAKey === 'home' ? timeouts.home : timeouts.away
      const timeoutsB = teamAKey === 'home' ? timeouts.away : timeouts.home

      // Substitutions with details
      const subsDetails = currentSetEvents.filter(e => e.type === 'substitution').reduce((acc, e) => {
        const team = e.payload?.team
        if (team) {
          if (!acc[team]) acc[team] = []
          acc[team].push({
            playerIn: e.payload?.playerIn,
            playerOut: e.payload?.playerOut,
            position: e.payload?.position,
            exceptional: e.payload?.exceptional || false,
            ts: e.ts
          })
        }
        return acc
      }, { home: [], away: [] })
      const subsA = teamAKey === 'home' ? subsDetails.home : subsDetails.away
      const subsB = teamAKey === 'home' ? subsDetails.away : subsDetails.home

      // Get lineups - check ALL events that have lineup data (lineup, rotation, libero, substitution, etc.)
      const getLineupForTeam = (teamKey) => {
        // Find all events for this team in current set that have lineup data
        const eventsWithLineup = allEvents
          .filter(e => e.payload?.team === teamKey && e.setIndex === currentSet.index &&
            (e.payload?.lineup || e.payload?.newLineup))
          .sort((a, b) => (a.seq || 0) - (b.seq || 0))

        if (eventsWithLineup.length === 0) return null

        // Get the most recent event with lineup data
        const lastEvent = eventsWithLineup[eventsWithLineup.length - 1]
        // Prefer newLineup (from libero/rotation events) over lineup
        return lastEvent.payload?.newLineup || lastEvent.payload?.lineup || null
      }

      const getLiberoSubForTeam = (teamKey) => {
        // Check lineup events for liberoSubstitution
        const lineupEvents = allEvents
          .filter(e => e.type === 'lineup' && e.payload?.team === teamKey && e.setIndex === currentSet.index)
          .sort((a, b) => (a.seq || 0) - (b.seq || 0))

        // Check libero entry/exit events
        const liberoEvents = allEvents
          .filter(e => (e.type === 'LIBERO_ENTRY' || e.type === 'LIBERO_EXIT') &&
            e.payload?.team === teamKey && e.setIndex === currentSet.index)
          .sort((a, b) => (a.seq || 0) - (b.seq || 0))

        const lastLineupEvent = lineupEvents.length > 0 ? lineupEvents[lineupEvents.length - 1] : null
        const lastLiberoEvent = liberoEvents.length > 0 ? liberoEvents[liberoEvents.length - 1] : null

        // If the most recent event is a libero entry, return that info
        if (lastLiberoEvent) {
          const isLiberoOnCourt = lastLiberoEvent.type === 'LIBERO_ENTRY'
          if (isLiberoOnCourt) {
            // Build liberoSubstitution object from LIBERO_ENTRY event
            return {
              liberoNumber: lastLiberoEvent.payload?.liberoIn,
              playerNumber: lastLiberoEvent.payload?.playerOut,
              position: lastLiberoEvent.payload?.position,
              liberoType: lastLiberoEvent.payload?.liberoType
            }
          } else {
            // LIBERO_EXIT - no libero currently on court
            return null
          }
        }

        // Fall back to lineup event's liberoSubstitution if no libero events
        if (lastLineupEvent) {
          return lastLineupEvent.payload?.liberoSubstitution || null
        }
        return null
      }

      const getInitialLineupForTeam = (teamKey) => {
        const initialLineup = allEvents.find(e =>
          e.type === 'lineup' &&
          e.payload?.team === teamKey &&
          e.setIndex === currentSet.index &&
          e.payload?.isInitial === true
        )
        return initialLineup?.payload?.lineup || null
      }

      const rawLineupA = getLineupForTeam(teamAKey)
      const rawLineupB = getLineupForTeam(teamBKey)
      const initialLineupA = getInitialLineupForTeam(teamAKey)
      const initialLineupB = getInitialLineupForTeam(teamBKey)
      const liberoSubA = getLiberoSubForTeam(teamAKey)
      const liberoSubB = getLiberoSubForTeam(teamBKey)

      // Captain info
      const getCaptainInfo = (playersDb) => {
        const captain = playersDb.find(p => p.isCaptain || p.captain)
        return captain ? captain.number : null
      }
      const teamAPlayersDb = teamAKey === 'home' ? homePlayersDb : awayPlayersDb
      const teamBPlayersDb = teamAKey === 'home' ? awayPlayersDb : homePlayersDb
      const captainA = getCaptainInfo(teamAPlayersDb)
      const captainB = getCaptainInfo(teamBPlayersDb)
      const courtCaptainA = teamAKey === 'home' ? match.homeCourtCaptain : match.awayCourtCaptain
      const courtCaptainB = teamBKey === 'home' ? match.homeCourtCaptain : match.awayCourtCaptain

      // Serving team calculation
      const pointEvents = allEvents
        .filter(e => e.type === 'point' && e.setIndex === currentSet.index)
        .sort((a, b) => (b.seq || 0) - (a.seq || 0))

      const set1FirstServe = match.firstServe || 'home'
      let currentSetFirstServe
      if (setIndex === 5 && match.set5FirstServe) {
        currentSetFirstServe = match.set5FirstServe === 'A' ? teamAKey : teamBKey
      } else if (setIndex === 5) {
        currentSetFirstServe = set1FirstServe
      } else {
        currentSetFirstServe = setIndex % 2 === 1 ? set1FirstServe : (set1FirstServe === 'home' ? 'away' : 'home')
      }

      const servingTeam = pointEvents.length > 0 ? (pointEvents[0].payload?.team || currentSetFirstServe) : currentSetFirstServe
      console.log('[Snapshot] servingTeam calculation:', {
        set1FirstServe,
        currentSetFirstServe,
        pointEventsCount: pointEvents.length,
        lastPointTeam: pointEvents[0]?.payload?.team,
        servingTeam
      })
      const servingTeamLineup = getLineupForTeam(servingTeam)
      const serverNumber = servingTeamLineup?.['I'] ? Number(servingTeamLineup['I']) : null

      // Sanctions
      const getSanctionsForTeam = (teamKey) => {
        return currentSetEvents
          .filter(e => e.type === 'sanction' && e.payload?.team === teamKey)
          .map(e => ({
            player: e.payload?.playerNumber || null,
            type: e.payload?.type || e.payload?.sanctionType,
            playerType: e.payload?.playerType || null,
            position: e.payload?.position || null,
            role: e.payload?.role || null,
            ts: e.ts
          }))
      }
      const sanctionsA = getSanctionsForTeam(teamAKey)
      const sanctionsB = getSanctionsForTeam(teamBKey)

      // Match-wide sanctions (team, players, bench officials) - persist across sets
      const getMatchTeamSanctionsForTeam = (teamKey) => {
        return allEvents
          .filter(e => e.type === 'sanction' && e.payload?.team === teamKey)
          .map(e => ({
            player: e.payload?.playerNumber || null,
            type: e.payload?.type || e.payload?.sanctionType,
            playerType: e.payload?.playerType || null,
            position: e.payload?.position || null,
            role: e.payload?.role || null,
            ts: e.ts
          }))
      }
      const matchTeamSanctionsA = getMatchTeamSanctionsForTeam(teamAKey)
      const matchTeamSanctionsB = getMatchTeamSanctionsForTeam(teamBKey)

      // Build rich lineup
      const buildRichLineup = (rawLineup, initialLineup, playersDb, subsDetails, sanctions, isServingTeam, captainNum, courtCaptainNum, liberoSubstitution) => {
        if (!rawLineup) return null

        const backRowPositions = ['I', 'V', 'VI']
        const richLineup = {}

        // Check if team captain is on court - if so, don't show court captain badge for anyone
        const captainOnCourt = captainNum && Object.values(rawLineup).some(num => String(num) === String(captainNum))

        for (const position of ['I', 'II', 'III', 'IV', 'V', 'VI']) {
          const playerNum = rawLineup[position]
          if (!playerNum) continue

          const playerNumStr = String(playerNum)
          const player = playersDb.find(p => String(p.number) === playerNumStr)
          const isBackRow = backRowPositions.includes(position)
          const isLibero = player && (player.libero === 'libero1' || player.libero === 'libero2' || player.libero === 'redesignated')

          let replacedNumber = null
          if (isLibero && liberoSubstitution && String(liberoSubstitution.liberoNumber) === playerNumStr) {
            replacedNumber = liberoSubstitution.playerNumber
          }

          const isInInitialLineup = initialLineup && Object.values(initialLineup).some(num => String(num) === playerNumStr)
          const subEvent = subsDetails.find(s => String(s.playerIn) === playerNumStr)
          const isSubstituted = !!subEvent && !isInInitialLineup
          const substitutedFor = isSubstituted ? Number(subEvent.playerOut) : null

          const playerSanctions = sanctions.filter(s => String(s.player) === playerNumStr)
          const hasSanction = playerSanctions.length > 0

          const isCaptain = !!(captainNum && String(captainNum) === playerNumStr)
          // Only show court captain badge if team captain is NOT on court
          const isCourtCaptain = !captainOnCourt && !!(courtCaptainNum && String(courtCaptainNum) === playerNumStr)

          const positionData = {
            number: Number(playerNum),
            isSubstituted,
            hasSanction,
            isCaptain,
            isCourtCaptain
          }

          if (position === 'I') {
            positionData.isServing = isServingTeam
          }

          if (isBackRow) {
            positionData.isLibero = isLibero
            if (isLibero) {
              positionData.replacedNumber = replacedNumber
            }
          }

          if (isSubstituted) {
            positionData.substitutedFor = substitutedFor
          }

          if (hasSanction) {
            positionData.sanctions = playerSanctions.map(s => ({ type: s.type, ts: s.ts }))
          }

          richLineup[position] = positionData
        }

        return Object.keys(richLineup).length > 0 ? richLineup : null
      }

      const lineupA = buildRichLineup(rawLineupA, initialLineupA, teamAPlayersDb, subsA, sanctionsA, servingTeam === teamAKey, captainA, courtCaptainA, liberoSubA)
      const lineupB = buildRichLineup(rawLineupB, initialLineupB, teamBPlayersDb, subsB, sanctionsB, servingTeam === teamBKey, captainB, courtCaptainB, liberoSubB)

      // Check rally status
      const lastRallyStart = currentSetEvents.filter(e => e.type === 'rally_start').sort((a, b) => (b.seq || 0) - (a.seq || 0))[0]
      const lastPoint = pointEvents[0]
      const rallyInProgress = lastRallyStart && (!lastPoint || (lastRallyStart.seq || 0) > (lastPoint.seq || 0))

      // Build set results history
      const setResults = finishedSets.map(s => ({
        index: s.index,
        pointsA: teamAKey === 'home' ? s.homePoints : s.awayPoints,
        pointsB: teamAKey === 'home' ? s.awayPoints : s.homePoints,
        winner: s.homePoints > s.awayPoints ? (teamAKey === 'home' ? 'A' : 'B') : (teamAKey === 'home' ? 'B' : 'A')
      }))

      console.log(`[PERF:snapshot] TOTAL: ${(performance.now() - _ts).toFixed(0)}ms`)
      return {
        // Match info
        matchId,
        matchStatus: match.status || 'live',
        teamAKey,
        teamAName,
        teamAShort: teamAShort || teamAName?.substring(0, 3).toUpperCase(),
        teamAColor: teamAColor || '#ef4444',
        teamBName,
        teamBShort: teamBShort || teamBName?.substring(0, 3).toUpperCase(),
        teamBColor: teamBColor || '#3b82f6',

        // Current set
        currentSetIndex: setIndex,
        sideA,
        pointsA,
        pointsB,
        setScoreA,
        setScoreB,

        // Lineups (rich format)
        lineupA,
        lineupB,

        // Game flow
        servingTeam,
        serverNumber,
        rallyInProgress: !!rallyInProgress,

        // Counts & history
        timeoutsA,
        timeoutsB,
        subsA,
        subsB,
        sanctionsA,
        sanctionsB,
        matchTeamSanctionsA,
        matchTeamSanctionsB,

        // Set results history
        setResults,

        // Match flags
        set5CourtSwitched: !!set5CourtSwitched,
        set5LeftTeam: set5LeftTeam || null
      }
    } catch (err) {
      console.error('[captureFullStateSnapshot] Error:', err)
      return null
    }
  }, [matchId])

  // Restore match state from a snapshot (used by undo)
  const restoreStateFromSnapshot = useCallback(async (snapshot) => {
    if (!snapshot || !matchId) return

    try {
      // Get current set
      const allSets = await db.sets.where({ matchId }).toArray()
      const currentSet = allSets.find(s => s.index === snapshot.currentSetIndex)
      if (!currentSet) return

      // Restore set score
      const teamAKey = snapshot.teamAKey || 'home'
      await db.sets.update(currentSet.id, {
        homePoints: teamAKey === 'home' ? snapshot.pointsA : snapshot.pointsB,
        awayPoints: teamAKey === 'home' ? snapshot.pointsB : snapshot.pointsA,
        finished: false
      })

      // Restore match status if needed
      const match = await db.matches.get(matchId)
      if (match && match.status !== snapshot.matchStatus) {
        await db.matches.update(matchId, { status: snapshot.matchStatus })
      }

      // Restore set5 court switch flag
      if (snapshot.currentSetIndex === 5 && match) {
        await db.matches.update(matchId, {
          set5CourtSwitched: snapshot.set5CourtSwitched || false
        })
      }
    } catch (err) {
      console.error('[restoreStateFromSnapshot] Error:', err)
    }
  }, [matchId])

  // Connect to WebSocket server and sync match data
  useEffect(() => {
    // If no matchId, clear all matches from server (scoreboard is source of truth)
    if (!matchId) {
      const clearAllMatches = () => {
        const ws = wsRef.current
        if (ws && ws.readyState === WebSocket.OPEN) {
          try {
            ws.send(JSON.stringify({
              type: 'clear-all-matches'
            }))
          } catch (err) {
            // Silently ignore
          }
        }
      }

      // Try to clear immediately if WebSocket is open
      clearAllMatches()

      // Also set up a connection to clear when WebSocket opens
      // Use configured backend URL if available (Railway/cloud)
      const backendUrl = import.meta.env.VITE_BACKEND_URL
      let wsUrl
      if (backendUrl) {
        const url = new URL(backendUrl)
        const protocol = url.protocol === 'https:' ? 'wss:' : 'ws:'
        wsUrl = `${protocol}//${url.host}`
      } else {
        // Fallback to local WebSocket server
        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws'
        const hostname = window.location.hostname
        const wsPort = 8080
        wsUrl = `${protocol}://${hostname}:${wsPort}`
      }

      const tempWs = new WebSocket(wsUrl)
      tempWs.onopen = () => {
        tempWs.send(JSON.stringify({ type: 'clear-all-matches' }))
        tempWs.close()
      }
      tempWs.onerror = () => {
        // Ignore - server might not be running
      }

      return () => {
        if (tempWs.readyState === WebSocket.OPEN || tempWs.readyState === WebSocket.CONNECTING) {
          tempWs.close()
        }
      }
    }

    if (!data || !data.match) {
      // Data is still loading - this is expected, wait for it
      return
    }

    let ws = null
    let reconnectTimeout = null

    const connectWebSocket = () => {
      try {
        // Check if we have a configured backend URL (Railway/cloud backend)
        const backendUrl = import.meta.env.VITE_BACKEND_URL

        let wsUrl
        if (backendUrl) {
          // Use configured backend (Railway cloud)
          const url = new URL(backendUrl)
          const protocol = url.protocol === 'https:' ? 'wss:' : 'ws:'
          wsUrl = `${protocol}//${url.host}`
        } else {
          // Fallback to local WebSocket server (development/Electron)
          const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws'
          const hostname = window.location.hostname
          let wsPort = 8080
          // Check if we have server status (from Electron or previous API call)
          const currentServerStatus = serverStatus
          if (currentServerStatus?.wsPort) {
            wsPort = currentServerStatus.wsPort
          }
          wsUrl = `${protocol}://${hostname}:${wsPort}`
        }

        ws = new WebSocket(wsUrl)
        wsRef.current = ws // Store in ref for use in callbacks

        // Set error handler first to catch any immediate errors
        ws.onerror = () => {
          // Suppress - browser will show native errors if needed
        }

        ws.onopen = () => {
          // Clear all other matches first (scoreboard is source of truth - only current match should exist)
          try {
            ws.send(JSON.stringify({
              type: 'clear-all-matches',
              keepMatchId: String(matchId) // Keep only the current match
            }))
          } catch (err) {
            // Silently ignore WebSocket errors
          }

          // Send initial match data sync (this will overwrite/add the current match)
          // No periodic sync - data is synced only when actions occur
          syncMatchData()
        }

        ws.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data)

            if (message.type === 'pin-validation-request') {
              // Respond to PIN validation request
              handlePinValidationRequest(message)
            } else if (message.type === 'match-data-request') {
              // Respond to match data request
              handleMatchDataRequest(message)
            } else if (message.type === 'game-number-request') {
              // Respond to game number request
              handleGameNumberRequest(message)
            } else if (message.type === 'pong') {
              // Heartbeat response
            }
          } catch (err) {
            console.error('[WebSocket] Error parsing message:', err)
          }
        }


        ws.onclose = (event) => {
          // Don't reconnect on normal closure (code 1000)
          if (event.code === 1000) {
            return
          }
          // Reconnect after 5 seconds
          reconnectTimeout = setTimeout(connectWebSocket, 5000)
        }
      } catch (err) {
        console.error('[WebSocket] Connection error:', err)
      }
    }

    const syncMatchData = async () => {
      // Use wsRef.current to always get the current WebSocket (not stale closure)
      const currentWs = wsRef.current
      if (!currentWs || currentWs.readyState !== WebSocket.OPEN) {
        return
      }

      try {
        // Fetch ALL fresh data from IndexedDB (not from React state which may be stale due to closures)
        const freshMatch = await db.matches.get(matchId)
        if (!freshMatch) return

        const [freshHomeTeam, freshAwayTeam, freshSets, freshEvents, freshHomePlayers, freshAwayPlayers] = await Promise.all([
          db.teams.get(freshMatch?.homeTeamId),
          db.teams.get(freshMatch?.awayTeamId),
          db.sets.where('matchId').equals(matchId).toArray(),
          db.events.where('matchId').equals(matchId).toArray(),
          freshMatch?.homeTeamId ? db.players.where('teamId').equals(freshMatch.homeTeamId).toArray() : [],
          freshMatch?.awayTeamId ? db.players.where('teamId').equals(freshMatch.awayTeamId).toArray() : []
        ])

        // Sync full match data to server - this ALWAYS overwrites existing data (scoreboard is source of truth)
        // The server will replace all data for this matchId with this data
        const sendTimestamp = Date.now()
        const syncPayload = {
          type: 'sync-match-data',
          matchId: matchId,
          match: freshMatch,
          homeTeam: freshHomeTeam || null,
          awayTeam: freshAwayTeam || null,
          homePlayers: freshHomePlayers || [],
          awayPlayers: freshAwayPlayers || [],
          sets: freshSets || [],
          events: freshEvents || [],
          _timestamp: sendTimestamp // Track when sent from scoreboard
        }

        currentWs.send(JSON.stringify(syncPayload))
      } catch (err) {
        console.error('[WebSocket] Error syncing match data:', err)
      }
    }

    // Store sync function in ref so it can be called from action handlers
    syncFunctionRef.current = syncMatchData

    const handlePinValidationRequest = async (request) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return

      try {
        const { pin, pinType, requestId } = request
        const pinStr = String(pin).trim()

        // Fetch fresh match data from IndexedDB (not from React state which may be stale due to closures)
        const freshMatch = await db.matches.get(matchId)
        if (!freshMatch) {
          ws.send(JSON.stringify({
            type: 'pin-validation-response',
            requestId,
            success: false,
            error: 'Match not found'
          }))
          return
        }

        // Check if PIN matches
        let matchPin = null
        let connectionEnabled = false

        if (pinType === 'referee') {
          matchPin = freshMatch.refereePin
          connectionEnabled = freshMatch.refereeConnectionEnabled === true
        } else if (pinType === 'homeTeam') {
          matchPin = freshMatch.homeTeamPin
          connectionEnabled = freshMatch.homeTeamConnectionEnabled === true
        } else if (pinType === 'awayTeam') {
          matchPin = freshMatch.awayTeamPin
          connectionEnabled = freshMatch.awayTeamConnectionEnabled === true
        }

        if (matchPin && String(matchPin).trim() === pinStr && connectionEnabled && freshMatch.status !== 'final') {
          // Fetch all related data fresh from IndexedDB
          const [freshHomeTeam, freshAwayTeam, freshSets, freshEvents, freshHomePlayers, freshAwayPlayers] = await Promise.all([
            db.teams.get(freshMatch?.homeTeamId),
            db.teams.get(freshMatch?.awayTeamId),
            db.sets.where('matchId').equals(matchId).toArray(),
            db.events.where('matchId').equals(matchId).toArray(),
            freshMatch?.homeTeamId ? db.players.where('teamId').equals(freshMatch.homeTeamId).toArray() : [],
            freshMatch?.awayTeamId ? db.players.where('teamId').equals(freshMatch.awayTeamId).toArray() : []
          ])

          // Send match data with full data
          ws.send(JSON.stringify({
            type: 'pin-validation-response',
            requestId,
            success: true,
            match: {
              id: freshMatch.id,
              refereePin: freshMatch.refereePin,
              homeTeamPin: freshMatch.homeTeamPin,
              awayTeamPin: freshMatch.awayTeamPin,
              homeTeamUploadPin: freshMatch.homeTeamUploadPin,
              awayTeamUploadPin: freshMatch.awayTeamUploadPin,
              refereeConnectionEnabled: freshMatch.refereeConnectionEnabled,
              homeTeamConnectionEnabled: freshMatch.homeTeamConnectionEnabled,
              awayTeamConnectionEnabled: freshMatch.awayTeamConnectionEnabled,
              status: freshMatch.status,
              homeTeamId: freshMatch.homeTeamId,
              awayTeamId: freshMatch.awayTeamId,
              gameNumber: freshMatch.gameNumber,
              game_n: freshMatch.game_n,
              createdAt: freshMatch.createdAt,
              updatedAt: freshMatch.updatedAt
            },
            fullData: {
              matchId: matchId,
              match: freshMatch,
              homeTeam: freshHomeTeam || null,
              awayTeam: freshAwayTeam || null,
              homePlayers: freshHomePlayers || [],
              awayPlayers: freshAwayPlayers || [],
              sets: freshSets || [],
              events: freshEvents || []
            }
          }))
        } else {
          // PIN doesn't match or connection disabled
          ws.send(JSON.stringify({
            type: 'pin-validation-response',
            requestId,
            success: false,
            error: connectionEnabled === false
              ? 'Connection is disabled for this match'
              : 'Invalid PIN code'
          }))
        }
      } catch (err) {
        console.error('[WebSocket] Error handling PIN validation:', err)
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'pin-validation-response',
            requestId: request.requestId,
            success: false,
            error: 'Error validating PIN'
          }))
        }
      }
    }

    const handleMatchDataRequest = async (request) => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return

      try {
        const { requestId, matchId: requestedMatchId } = request

        if (String(requestedMatchId) !== String(matchId)) {
          ws.send(JSON.stringify({
            type: 'match-data-response',
            requestId,
            matchId: requestedMatchId,
            success: false,
            error: 'Match ID mismatch'
          }))
          return
        }

        // Fetch ALL fresh data from IndexedDB (not from React state which may be stale due to closures)
        const freshMatch = await db.matches.get(matchId)
        if (!freshMatch) {
          ws.send(JSON.stringify({
            type: 'match-data-response',
            requestId,
            matchId: requestedMatchId,
            success: false,
            error: 'Match not found in database'
          }))
          return
        }

        const [freshHomeTeam, freshAwayTeam, freshSets, freshEvents, freshHomePlayers, freshAwayPlayers] = await Promise.all([
          db.teams.get(freshMatch?.homeTeamId),
          db.teams.get(freshMatch?.awayTeamId),
          db.sets.where('matchId').equals(matchId).toArray(),
          db.events.where('matchId').equals(matchId).toArray(),
          freshMatch?.homeTeamId ? db.players.where('teamId').equals(freshMatch.homeTeamId).toArray() : [],
          freshMatch?.awayTeamId ? db.players.where('teamId').equals(freshMatch.awayTeamId).toArray() : []
        ])

        ws.send(JSON.stringify({
          type: 'match-data-response',
          requestId,
          matchId: matchId,
          success: true,
          data: {
            match: freshMatch,
            homeTeam: freshHomeTeam || null,
            awayTeam: freshAwayTeam || null,
            homePlayers: freshHomePlayers || [],
            awayPlayers: freshAwayPlayers || [],
            sets: freshSets || [],
            events: freshEvents || []
          }
        }))
      } catch (err) {
        console.error('[WebSocket] Error handling match data request:', err)
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'match-data-response',
            requestId: request.requestId,
            matchId: request.matchId,
            success: false,
            error: 'Error fetching match data'
          }))
        }
      }
    }

    const handleGameNumberRequest = async (request) => {
      if (!ws || ws.readyState !== WebSocket.OPEN || !data?.match) return

      try {
        const { requestId, gameNumber } = request
        const gameNumStr = String(gameNumber).trim()

        const matchGameNumber = String(data.match.gameNumber || '')
        const matchGameN = String(data.match.game_n || '')
        const matchIdStr = String(data.match.id || '')

        if (matchGameNumber === gameNumStr || matchGameN === gameNumStr || matchIdStr === gameNumStr) {
          ws.send(JSON.stringify({
            type: 'game-number-response',
            requestId,
            success: true,
            match: data.match,
            matchId: matchId
          }))
        } else {
          ws.send(JSON.stringify({
            type: 'game-number-response',
            requestId,
            success: false,
            error: 'Match not found with this game number'
          }))
        }
      } catch (err) {
        console.error('[WebSocket] Error handling game number request:', err)
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'game-number-response',
            requestId: request.requestId,
            success: false,
            error: 'Error finding match'
          }))
        }
      }
    }

    // Removed handleMatchUpdateRequest - using sync-match-data instead

    // When matchId changes, clear the old match from server
    if (previousMatchIdRef.current && previousMatchIdRef.current !== matchId) {
      const oldMatchId = previousMatchIdRef.current
      const ws = wsRef.current
      if (ws && ws.readyState === WebSocket.OPEN) {
        try {
          ws.send(JSON.stringify({
            type: 'delete-match',
            matchId: String(oldMatchId)
          }))
        } catch (err) {
          // Silently ignore
        }
      }
    }
    previousMatchIdRef.current = matchId

    // Connect to WebSocket
    connectWebSocket()

    return () => {
      if (reconnectTimeout) clearTimeout(reconnectTimeout)

      // Clear all matches from server when component unmounts (scoreboard is source of truth)
      if (wsRef.current) {
        const ws = wsRef.current
        const readyState = ws.readyState

        // Clear all matches from server before closing
        if (readyState === WebSocket.OPEN) {
          try {
            ws.send(JSON.stringify({
              type: 'clear-all-matches'
            }))
          } catch (err) {
            // Silently ignore errors during cleanup
          }
        }

        // Remove all handlers first to prevent error logs
        try {
          ws.onerror = null
          ws.onclose = null
          ws.onopen = null
          ws.onmessage = null
        } catch (err) {
          // Ignore if handlers can't be set
        }

        // Only try to close if connection is OPEN
        // Don't close if CONNECTING - let it fail naturally to avoid browser errors
        if (readyState === WebSocket.OPEN) {
          try {
            ws.close(1000, 'Component unmounting')
          } catch (err) {
            // Ignore errors during cleanup
          }
        }
        // For CONNECTING or CLOSING states, just null the ref
        wsRef.current = null
      }
    }
  }, [matchId, serverStatus])

  // Sync when connection settings change (e.g., referee dashboard enabled/disabled)
  useEffect(() => {
    if (syncFunctionRef.current && data?.match) {
      syncFunctionRef.current()
    }
  }, [data?.match?.refereeConnectionEnabled, data?.match?.homeTeamConnectionEnabled, data?.match?.awayTeamConnectionEnabled])

  // Sync data to referee/bench - call this after any action that changes match data
  // If WebSocket isn't ready, retry after a short delay
  const syncToReferee = useCallback(() => {
    if (syncFunctionRef.current) {
      syncFunctionRef.current()
    }
    // If WebSocket isn't connected, try again after a short delay
    // This handles cases where lineup is saved while WebSocket is temporarily disconnected
    const ws = wsRef.current
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      setTimeout(() => {
        if (syncFunctionRef.current) {
          syncFunctionRef.current()
        }
      }, 1000)
    }
  }, [])

  // Send action to referee/bench for showing modals/countdowns
  const sendActionToReferee = useCallback((actionType, actionData) => {
    const ws = wsRef.current
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      return
    }

    const sendTimestamp = Date.now()
    const actionPayload = {
      type: 'match-action',
      matchId: matchId,
      action: actionType,
      data: actionData,
      timestamp: sendTimestamp,
      _timestamp: sendTimestamp // For latency tracking
    }

    ws.send(JSON.stringify(actionPayload))
  }, [matchId])

  // Sync live state to Supabase for referee.openvolley.app
  // SIMPLIFIED: Uses stateSnapshot from events instead of recomputing everything
  // cachedSnapshot: Optional snapshot passed from logEvent to avoid re-fetching/re-computing
  const syncLiveStateToSupabase = useCallback(async (eventType, eventTeam, eventData, cachedSnapshot = null) => {
    const _tl = performance.now()
    console.log(`[PERF:liveState] START: ${eventType}, cachedSnapshot: ${!!cachedSnapshot}`)
    if (!supabase || !matchId) return

    try {
      // Get match to check if it's a test match
      const match = await db.matches.get(matchId)
      if (!match || match.test) return
      console.log(`[PERF:liveState] After match.get: +${(performance.now() - _tl).toFixed(0)}ms`)

      // Get the Supabase match UUID
      let supabaseMatchId = null
      const externalId = match.externalId
      if (externalId && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(externalId)) {
        supabaseMatchId = externalId
      } else {
        const seedKey = match.seed_key || String(matchId)
        const { data: matchData, error } = await supabase
          .from('matches')
          .select('id')
          .eq('external_id', seedKey)
          .eq('sport_type', SPORT_TYPE)
          .maybeSingle()
        if (error || !matchData) return
        supabaseMatchId = matchData.id
        console.log(`[PERF:liveState] After Supabase match lookup: +${(performance.now() - _tl).toFixed(0)}ms`)
      }
      if (!supabaseMatchId) return

      // Use cached snapshot if provided, otherwise fetch/compute
      let snapshot = cachedSnapshot
      if (!snapshot) {
        if (eventType?.startsWith('manual_')) {
          // Manual change - must capture fresh to reflect the change
          snapshot = await captureFullStateSnapshot()
          console.log('[LiveState] Captured fresh snapshot for manual change')
        } else {
          // Try to get the latest event's stateSnapshot using compound index
          const lastEvent = await db.events.where('[matchId+seq]').between([matchId, Dexie.minKey], [matchId, Dexie.maxKey]).last()
          snapshot = lastEvent?.stateSnapshot

          // Fallback: capture fresh snapshot if none exists (e.g., before first event)
          if (!snapshot) {
            snapshot = await captureFullStateSnapshot()
          }
        }
        console.log(`[PERF:liveState] After snapshot fetch/compute: +${(performance.now() - _tl).toFixed(0)}ms`)
      }
      if (!snapshot) return

      // Determine match status from event type and current state
      const isSetInterval = eventType === 'set_end' || (match?.status === 'interval' && !isSetFinished)
      const isTimeout = eventType === 'timeout' || (timeoutModal !== null)

      // If it's a timeout, we need a stable start time
      const timeoutStartedAt = eventType === 'timeout'
        ? new Date().toISOString()
        : (timeoutModal?.startedAt || new Date().toISOString())

      // For intervals, we also need a stable start time
      const intervalStartedAt = eventType === 'set_end'
        ? new Date().toISOString()
        : (match?.intervalStartedAt || null)

      // For set_end, we need to show the NEXT set state (interval between sets)
      // The snapshot still has the OLD set data, so we override for set_end
      const nextSetIndex = isSetInterval ? snapshot.currentSetIndex + 1 : snapshot.currentSetIndex

      // Calculate updated set scores including the just-finished set
      // eventData.winner is 'home' or 'away' from the set_end event
      // Fallback: if eventData.winner is undefined, calculate from snapshot points
      const setWinner = eventData?.winner
        || (snapshot.pointsA > snapshot.pointsB ? snapshot.teamAKey : null)
        || (snapshot.pointsB > snapshot.pointsA ? snapshot.teamBKey : null)
      const updatedSetScoreA = isSetInterval && setWinner
        ? (setWinner === snapshot.teamAKey ? snapshot.setScoreA + 1 : snapshot.setScoreA)
        : snapshot.setScoreA
      const updatedSetScoreB = isSetInterval && setWinner
        ? (setWinner === snapshot.teamBKey ? snapshot.setScoreB + 1 : snapshot.setScoreB)
        : snapshot.setScoreB

      // Check if match is finished (one team won 3 sets) - don't increment current_set past the final set
      const isMatchFinished = updatedSetScoreA >= 3 || updatedSetScoreB >= 3
      const finalSetIndex = isSetInterval && isMatchFinished ? snapshot.currentSetIndex : nextSetIndex

      // Determine match status - 'ended' takes priority over interval
      let matchStatus = 'in_progress'
      if (isMatchFinished) matchStatus = 'ended'
      else if (isTimeout) matchStatus = 'timeout'
      else if (isSetInterval) matchStatus = 'interval'

      // Calculate side for next set (odd sets: A on left, even sets: A on right)
      // This follows the standard volleyball alternation pattern
      const nextSideA = isSetInterval
        ? (nextSetIndex % 2 === 1 ? 'left' : 'right')
        : snapshot.sideA

      // For interval, points reset to 0 for the new set
      const nextPointsA = isSetInterval ? 0 : snapshot.pointsA
      const nextPointsB = isSetInterval ? 0 : snapshot.pointsB

      // Calculate serving team for next set (for set_end, use alternation pattern)
      let nextServingTeam = snapshot.servingTeam
      if (isSetInterval) {
        // Calculate who serves first in the next set based on alternation pattern
        const set1FirstServe = match.firstServe || 'home'
        const teamAKey = snapshot.teamAKey
        const teamBKey = teamAKey === 'home' ? 'away' : 'home'

        let nextSetFirstServe
        if (nextSetIndex === 5 && match.set5FirstServe) {
          // Set 5 uses separate coin toss result if available
          nextSetFirstServe = match.set5FirstServe === 'A' ? teamAKey : teamBKey
        } else if (nextSetIndex === 5) {
          // Set 5 without set5FirstServe specified - fallback to set 1 pattern
          nextSetFirstServe = set1FirstServe
        } else {
          // Sets 1-4: odd sets (1, 3) same as set 1, even sets (2, 4) opposite
          nextSetFirstServe = nextSetIndex % 2 === 1 ? set1FirstServe : (set1FirstServe === 'home' ? 'away' : 'home')
        }
        nextServingTeam = nextSetFirstServe

        console.log('[LiveState] Next set first serve calculation:', {
          nextSetIndex,
          set1FirstServe,
          set5FirstServe: match.set5FirstServe,
          nextSetFirstServe,
          nextServingTeam
        })
      }

      // Detailed logging for set_end events
      if (isSetInterval) {
        console.log('═══════════════════════════════════════════════════════════════')
        console.log('[LiveState] SET_END Supabase Sync Calculations:')
        console.log('═══════════════════════════════════════════════════════════════')
        console.log('[LiveState] Snapshot data:', {
          currentSetIndex: snapshot.currentSetIndex,
          teamAKey: snapshot.teamAKey,
          teamBKey: snapshot.teamAKey === 'home' ? 'away' : 'home',
          setScoreA_before: snapshot.setScoreA,
          setScoreB_before: snapshot.setScoreB,
          pointsA: snapshot.pointsA,
          pointsB: snapshot.pointsB,
          sideA: snapshot.sideA
        })
        console.log('[LiveState] Set winner calculation:', {
          eventDataWinner: eventData?.winner,
          setWinner,
          teamAKey: snapshot.teamAKey,
          winnerIsTeamA: setWinner === snapshot.teamAKey
        })
        console.log('[LiveState] Score updates:', {
          setScoreA_before: snapshot.setScoreA,
          setScoreA_after: updatedSetScoreA,
          setScoreB_before: snapshot.setScoreB,
          setScoreB_after: updatedSetScoreB
        })
        console.log('[LiveState] Next set state:', {
          nextSetIndex,
          nextSideA,
          nextPointsA,
          nextPointsB,
          calculation: `Set ${nextSetIndex} is ${nextSetIndex % 2 === 1 ? 'odd' : 'even'}, so Team A is on ${nextSideA}`
        })
      }

      // Map directly from snapshot to Supabase table
      const liveStateData = {
        match_id: supabaseMatchId,
        current_set: finalSetIndex,
        // Team A/B info (from snapshot)
        team_a_name: snapshot.teamAName,
        team_a_short: snapshot.teamAShort,
        team_a_color: snapshot.teamAColor,
        team_b_name: snapshot.teamBName,
        team_b_short: snapshot.teamBShort,
        team_b_color: snapshot.teamBColor,
        // Scores by team (updated for set_end)
        sets_won_a: updatedSetScoreA,
        sets_won_b: updatedSetScoreB,
        points_a: nextPointsA,
        points_b: nextPointsB,
        // Which side Team A is on (updated for set_end)
        side_a: nextSideA,
        // Rich lineups with all position data
        lineup_a: snapshot.lineupA,
        lineup_b: snapshot.lineupB,
        // Timeouts and subs (send full array for referee to see substitution details)
        timeouts_a: snapshot.timeoutsA,
        timeouts_b: snapshot.timeoutsB,
        subs_a: snapshot.subsA?.length > 0 ? snapshot.subsA : null,
        subs_b: snapshot.subsB?.length > 0 ? snapshot.subsB : null,
        // All sanctions (team, players, bench officials) - match-wide, persist across sets
        sanctions_a: snapshot.matchTeamSanctionsA?.length > 0 ? snapshot.matchTeamSanctionsA : null,
        sanctions_b: snapshot.matchTeamSanctionsB?.length > 0 ? snapshot.matchTeamSanctionsB : null,
        // Serving team (convert to left/right) - use next set values for set_end
        serving_team: nextServingTeam === snapshot.teamAKey ? nextSideA : (nextSideA === 'left' ? 'right' : 'left'),
        // Event info
        last_event_type: eventType || null,
        last_event_team: eventTeam || null,
        last_event_data: eventData || null,
        last_event_ts: new Date().toISOString(),
        timeout_active: isTimeout,
        timeout_started_at: isTimeout ? (timeoutModal?.startedAt || timeoutStartedAt) : null,
        set_interval_active: isSetInterval,
        set_interval_started_at: isSetInterval ? (match?.intervalStartedAt || intervalStartedAt) : null,
        match_status: matchStatus,
        scorer_attention_trigger: scorerAttentionTrigger,
        // Match metadata (from IndexedDB match record)
        game_n: match.gameN || match.game_n || null,
        league: match.league || null,
        gender: match.match_type_2 || null,
        updated_at: new Date().toISOString()
      }

      console.log('[LiveState] Syncing to Supabase:', {
        eventType,
        teamAKey: snapshot.teamAKey,
        teamAName: snapshot.teamAName,
        teamBName: snapshot.teamBName,
        sideA: snapshot.sideA,
        servingTeam: snapshot.servingTeam,
        pointsA: snapshot.pointsA,
        pointsB: snapshot.pointsB,
        setScoreA: snapshot.setScoreA,
        setScoreB: snapshot.setScoreB
      })

      // DIRECT SUPABASE WRITE (bypasses sync_queue) - see architecture note at top of file
      // Reason: match_live_state needs sub-second latency for real-time spectator display.
      // Queuing would add 1s+ delay from the polling interval in useSyncQueue.
      const [liveStateResult, matchResult] = await Promise.all([
        supabase.from('match_live_state').upsert(liveStateData, { onConflict: 'match_id' }),
        supabase.from('matches').update({ current_set: finalSetIndex }).eq('id', supabaseMatchId)
      ])

      if (liveStateResult.error) {
        console.error('[LiveState] Sync error:', liveStateResult.error)
        // Show error notification for direct write failure
        setScoresheetErrorModal({
          error: t('errors.syncFailed'),
          details: liveStateResult.error.message || t('errors.databaseWriteError')
        })
      } else {
        console.log('[LiveState] Synced successfully - side_a:', snapshot.sideA, 'serving:', snapshot.servingTeam)
      }

      if (matchResult.error) {
        console.error('[LiveState] Match current_set update error:', matchResult.error)
        // matchResult error is also critical but usually fails together with liveState
        if (!liveStateResult.error) {
          setScoresheetErrorModal({
            error: t('errors.syncFailed'),
            details: matchResult.error.message || t('errors.databaseWriteError')
          })
        }
      }
      console.log(`[PERF:liveState] TOTAL: ${(performance.now() - _tl).toFixed(0)}ms`)
    } catch (err) {
      console.error('[LiveState] Exception:', err)
    }
  }, [matchId, captureFullStateSnapshot])



  // Check connection statuses
  const checkConnectionStatuses = useCallback(async () => {
    const statuses = {
      api: 'unknown',
      server: 'unknown',
      websocket: 'unknown',
      scoreboard: 'unknown',
      match: 'unknown',
      db: 'unknown'
    }
    const debugInfo = {}

    // Get the backend URL - use VITE_BACKEND_URL if configured, otherwise relative URL
    const backendUrl = import.meta.env.VITE_BACKEND_URL || ''
    const isStaticHosting = !import.meta.env.DEV && (
      window.location.hostname.includes('github.io') ||
      window.location.hostname.endsWith('.openvolley.app') // All openvolley.app subdomains are static
    )

    // Skip API checks if on static hosting AND no backend URL configured
    if (isStaticHosting && !backendUrl) {
      statuses.api = 'n/a'
      statuses.server = 'n/a'
      statuses.websocket = 'n/a'
      debugInfo.api = { status: 'n/a', message: 'Static hosting - no backend configured' }
      debugInfo.server = { status: 'n/a', message: 'Static hosting - no backend configured' }
      debugInfo.websocket = { status: 'n/a', message: 'Static hosting - no WebSocket configured' }
    } else try {
      // Use configured backend URL or relative URL
      const apiUrl = backendUrl ? `${backendUrl}/api/match/list` : '/api/match/list'
      const response = await fetch(apiUrl)
      if (response.ok) {
        statuses.api = 'connected'
        statuses.server = 'connected'
        debugInfo.api = { status: 'connected', message: 'API endpoint responding' }
        debugInfo.server = { status: 'connected', message: 'Server is reachable' }
      } else {
        statuses.api = 'disconnected'
        statuses.server = 'disconnected'
        debugInfo.api = { status: 'disconnected', message: `API returned status ${response.status}: ${response.statusText}` }
        debugInfo.server = { status: 'disconnected', message: `Server returned status ${response.status}: ${response.statusText}` }
      }
    } catch (err) {
      statuses.api = 'disconnected'
      statuses.server = 'disconnected'
      const errMsg = import.meta.env.DEV
        ? `Network error: ${err.message || 'Failed to connect to API'}`
        : 'Server not available (running in standalone mode)'
      debugInfo.api = { status: 'disconnected', message: errMsg }
      debugInfo.server = { status: 'disconnected', message: errMsg }
    }

    // Check WebSocket connection
    if (wsRef.current) {
      const ws = wsRef.current
      if (ws.readyState === WebSocket.OPEN) {
        statuses.websocket = 'connected'
      } else if (ws.readyState === WebSocket.CONNECTING) {
        statuses.websocket = 'connecting'
      } else {
        statuses.websocket = 'disconnected'
      }
    } else {
      // Test if WebSocket server is available
      try {
        // Use configured backend URL if available (Railway/cloud)
        const backendUrlForWs = import.meta.env.VITE_BACKEND_URL
        let wsUrl
        if (backendUrlForWs) {
          const url = new URL(backendUrlForWs)
          const protocol = url.protocol === 'https:' ? 'wss:' : 'ws:'
          wsUrl = `${protocol}//${url.host}`
        } else {
          // Fallback to local WebSocket server
          const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws'
          const hostname = window.location.hostname
          const wsPort = serverStatus?.wsPort || 8080
          wsUrl = `${protocol}://${hostname}:${wsPort}`
        }

        const wsTest = new WebSocket(wsUrl)
        let resolved = false

        await new Promise((resolve) => {
          const timeout = setTimeout(() => {
            if (!resolved) {
              resolved = true
              try {
                if (wsTest.readyState === WebSocket.CONNECTING || wsTest.readyState === WebSocket.OPEN) {
                  wsTest.close()
                }
              } catch (e) {
                // Ignore errors when closing
              }
              statuses.websocket = 'disconnected'
              resolve()
            }
          }, 2000)

          wsTest.onopen = () => {
            if (!resolved) {
              resolved = true
              clearTimeout(timeout)
              try {
                wsTest.close()
              } catch (e) {
                // Ignore errors when closing
              }
              statuses.websocket = 'connected'
              resolve()
            }
          }

          wsTest.onerror = () => {
            if (!resolved) {
              resolved = true
              clearTimeout(timeout)
              try {
                if (wsTest.readyState === WebSocket.CONNECTING || wsTest.readyState === WebSocket.OPEN) {
                  wsTest.close()
                }
              } catch (e) {
                // Ignore errors when closing
              }
              statuses.websocket = 'disconnected'
              resolve()
            }
          }

          wsTest.onclose = () => {
            if (!resolved) {
              resolved = true
              clearTimeout(timeout)
              statuses.websocket = 'disconnected'
              resolve()
            }
          }
        })
      } catch (err) {
        statuses.websocket = 'disconnected'
      }
    }

    // Check Scoreboard connection (same as server for now)
    statuses.scoreboard = statuses.server

    // Check Match status
    if (data?.match) {
      statuses.match = data.match.status === 'live' ? 'live' : data.match.status === 'scheduled' ? 'scheduled' : data.match.status === 'final' ? 'final' : 'unknown'
    } else {
      statuses.match = 'no_match'
    }

    // Check DB (IndexedDB) - always available in browser
    try {
      await db.matches.count()
      statuses.db = 'connected'
    } catch (err) {
      statuses.db = 'disconnected'
    }

    setConnectionStatuses(statuses)
  }, [data?.match, serverStatus])

  // Periodically check connection statuses (60s interval to reduce console spam when server is down)
  useEffect(() => {
    checkConnectionStatuses()
    const interval = setInterval(checkConnectionStatuses, 60000) // Check every 60 seconds
    return () => clearInterval(interval)
  }, [checkConnectionStatuses])

  const ensuringSetRef = useRef(false)
  const setCreationInProgressRef = useRef(false) // Prevent race condition: don't auto-create set while confirmSetEndTime is running

  const ensureActiveSet = useCallback(async () => {
    if (!matchId) return

    // Set lock immediately to prevent race conditions
    setCreationInProgressRef.current = true

    console.log('[SET_END_DEBUG] [ensureActiveSet] Checking for active set... matchId=', matchId)

    // GUARD 1: Check if match is over by status
    const match = await db.matches.get(matchId)
    console.log('[SET_END_DEBUG] [ensureActiveSet] Match status:', match?.status)
    if (match?.status === 'ended' || match?.status === 'approved' || match?.status === 'final') {
      console.log('[SET_END_DEBUG] [ensureActiveSet] Match status is', match.status, '- STOPPING, not creating new set')
      setCreationInProgressRef.current = false
      return
    }

    // GUARD 2: Check if match is over by sets won (3 sets = match over)
    const allSetsForGuard = await db.sets.where('matchId').equals(matchId).toArray()
    const finishedSetsForGuard = allSetsForGuard.filter(s => s.finished)
    const homeSetsWon = finishedSetsForGuard.filter(s => s.homePoints > s.awayPoints).length
    const awaySetsWon = finishedSetsForGuard.filter(s => s.awayPoints > s.homePoints).length
    console.log('[SET_END_DEBUG] [ensureActiveSet] Sets:', JSON.stringify({
      total: allSetsForGuard.length,
      finished: finishedSetsForGuard.length,
      homeSetsWon,
      awaySetsWon,
      allSets: allSetsForGuard.map(s => ({ id: s.id, index: s.index, finished: s.finished }))
    }))
    if (homeSetsWon >= 3 || awaySetsWon >= 3) {
      console.log('[SET_END_DEBUG] [ensureActiveSet] Match is over (sets won:', homeSetsWon, '-', awaySetsWon, ') - STOPPING, not creating new set')
      setCreationInProgressRef.current = false
      return
    }

    const existing = await db.sets
      .where('matchId')
      .equals(matchId)
      .and(s => !s.finished)
      .first()

    if (existing) {
      console.log('[SET_END_DEBUG] [ensureActiveSet] Active set exists:', JSON.stringify({ id: existing.id, index: existing.index }))
      setCreationInProgressRef.current = false
      return
    }

    const allSets = await db.sets
      .where('matchId')
      .equals(matchId)
      .sortBy('index')

    const nextIndex =
      allSets.length > 0
        ? Math.max(...allSets.map(s => s.index || 0)) + 1
        : 1

    // Enhanced recovery logging to help debug incomplete set transitions
    console.log('[ensureActiveSet] RECOVERY: No active set found. Creating set', nextIndex,
      'Previous sets:', JSON.stringify(allSets.map(s => ({ index: s.index, finished: s.finished, homePoints: s.homePoints, awayPoints: s.awayPoints }))))
    console.log('[ensureActiveSet] Creating set with index:', nextIndex, 'Total sets:', allSets.length)

    // CRITICAL VALIDATION 1: Check if a set with this index already exists
    const duplicate = allSets.find(s => s.index === nextIndex)
    if (duplicate) {
      console.log('[ensureActiveSet] ⛔ Duplicate detected! Set', nextIndex, 'already exists:', duplicate.id)
      setCreationInProgressRef.current = false
      return
    }

    // CRITICAL VALIDATION 2: Check if previous set (nextIndex - 1) is finished
    if (nextIndex > 1) {
      const previousSet = allSets.find(s => s.index === nextIndex - 1)
      if (!previousSet || !previousSet.finished) {
        console.log('[ensureActiveSet] ⛔ Cannot create set', nextIndex, '- previous set', (nextIndex - 1), 'is not finished:', previousSet)
        setCreationInProgressRef.current = false
        return
      }
    }

    // CRITICAL VALIDATION 3: Fresh duplicate check right before creation (race condition guard)
    const freshDuplicateCheck = await db.sets.where({ matchId }).and(s => s.index === nextIndex).first()
    if (freshDuplicateCheck) {
      console.log('[ensureActiveSet] ⛔ Fresh duplicate check failed! Set', nextIndex, 'was created by another process:', freshDuplicateCheck.id)
      setCreationInProgressRef.current = false
      return
    }

    const setId = await db.sets.add({
      matchId,
      index: nextIndex,
      homePoints: 0,
      awayPoints: 0,
      finished: false
    })

    // Use match from guard check above (already fetched)
    const isTest = match?.test || false

    // Only sync official matches (not test matches)
    if (!isTest) {
      await db.sync_queue.add({
        resource: 'set',
        action: 'insert',
        payload: {
          external_id: String(setId),
          match_id: match?.seed_key || String(matchId),
          index: nextIndex,
          home_points: 0,
          away_points: 0,
          finished: false,
          test: isTest,
          start_time: roundToMinute(new Date().toISOString())
        },
        ts: roundToMinute(new Date().toISOString()),
        status: 'queued'
      })
    }

    // Release the lock after successful creation
    setCreationInProgressRef.current = false
  }, [matchId])

  useEffect(() => {
    // Skip if: no match, data exists with active set, already ensuring, or confirmSetEndTime is creating a set
    if (!matchId || !data || data.set || ensuringSetRef.current || setCreationInProgressRef.current) return
    ensuringSetRef.current = true
    ensureActiveSet()
      .catch(err => {
        // Silently handle error, but ensure lock is released
        setCreationInProgressRef.current = false
      })
      .finally(() => {
        ensuringSetRef.current = false
      })
  }, [data, ensureActiveSet, matchId])

  // Sync remarks text when modal opens
  useEffect(() => {
    if (showRemarks) {
      const currentRemarks = data?.match?.remarks || ''
      // If there are existing remarks, add a newline at the end for new input
      setRemarksText(currentRemarks ? `${currentRemarks}\n` : '')
      // Focus textarea after modal opens
      setTimeout(() => {
        if (remarksTextareaRef.current) {
          remarksTextareaRef.current.focus()
          const len = remarksTextareaRef.current.value.length
          remarksTextareaRef.current.setSelectionRange(len, len)
        }
      }, 100)
    }
  }, [showRemarks, data?.match?.remarks])

  // Server management - Only check in Electron
  useEffect(() => {
    const isElectron = typeof window !== 'undefined' && window.electronAPI?.server

    // Only check server status in Electron mode
    if (!isElectron) {
      return
    }

    const checkServerStatus = async () => {
      try {
        const status = await window.electronAPI.server.getStatus()
        setServerStatus(status)
        setServerRunning(status.running)
      } catch (err) {
        setServerRunning(false)
      }
    }

    checkServerStatus()
    const interval = setInterval(checkServerStatus, 5000)
    return () => clearInterval(interval)
  }, [])

  const handleStartServer = async () => {
    const isElectron = typeof window !== 'undefined' && window.electronAPI?.server

    if (!isElectron) {
      // In browser/PWA - show instructions instead of error
      // The server status will be checked automatically, so we just need to show instructions
      return
    }

    setServerLoading(true)
    try {
      const result = await window.electronAPI.server.start({ https: true })
      if (result.success) {
        setServerStatus(result.status)
        setServerRunning(true)
      } else {
        showAlert(`Failed to start server: ${result.error}`, 'error')
      }
    } catch (error) {
      showAlert(`Error starting server: ${error.message}`, 'error')
    } finally {
      setServerLoading(false)
    }
  }

  const handleStopServer = async () => {
    setServerLoading(true)
    try {
      const isElectron = typeof window !== 'undefined' && window.electronAPI?.server

      if (isElectron) {
        const result = await window.electronAPI.server.stop()
        if (result.success) {
          setServerRunning(false)
          setServerStatus(null)
        }
      }
    } catch (error) {
      showAlert(`Error stopping server: ${error.message}`, 'error')
    } finally {
      setServerLoading(false)
    }
  }

  // Determine which team is A and which is B based on coin toss
  const teamAKey = useMemo(() => {
    if (!data?.match) return 'home'
    return data.match.coinTossTeamA || 'home'
  }, [data?.match])

  const teamBKey = useMemo(() => {
    if (!data?.match) return 'away'
    return data.match.coinTossTeamB || 'away'
  }, [data?.match])

  const leftIsHome = useMemo(() => {
    // Before coin toss, default to home left, away right
    const isBeforeCoinToss = !data?.match?.coinTossTeamA || !data?.match?.coinTossTeamB
    if (isBeforeCoinToss || !data?.set) return true

    const setIndex = data.set.index

    // Check for manual override first (for sets 1-4)
    if (setIndex >= 1 && setIndex <= 4 && data.match?.setLeftTeamOverrides) {
      const override = data.match.setLeftTeamOverrides[setIndex]
      if (override) {
        // Override is 'A' or 'B'
        const leftTeamKey = override === 'A' ? teamAKey : teamBKey
        return leftTeamKey === 'home'
      }
    }

    // Set 1: Team A on left
    if (setIndex === 1) {
      return teamAKey === 'home'
    }

    // Set 5: Special case with court switch at 8 points
    if (setIndex === 5) {
      // Use set5LeftTeam if specified, otherwise default to teams switched (like set 2)
      if (data.match?.set5LeftTeam) {
        const leftTeamKey = data.match.set5LeftTeam === 'A' ? teamAKey : teamBKey
        let isHome = leftTeamKey === 'home'

        // If court switch has happened at 8 points, switch again
        if (data.match?.set5CourtSwitched) {
          isHome = !isHome
        }

        return isHome
      }

      // Fallback: Set 5 starts with teams switched (like set 2)
      let isHome = teamAKey !== 'home'

      // If court switch has happened at 8 points, switch again
      if (data.match?.set5CourtSwitched) {
        isHome = !isHome
      }

      return isHome
    }

    // Sets 2, 3, 4: Teams alternate sides (automatic if no override)
    // Set 1: Team A left, Team B right
    // Set 2: Team A right, Team B left (switched)
    // Set 3: Team A left, Team B right (switched back - same as Set 1)
    // Set 4: Team A right, Team B left (switched - same as Set 2)
    // Pattern: odd sets (1, 3) have Team A on left, even sets (2, 4) have Team A on right
    return setIndex % 2 === 1 ? (teamAKey === 'home') : (teamAKey !== 'home')
  }, [data?.set, data?.match?.set5CourtSwitched, data?.match?.set5LeftTeam, data?.match?.setLeftTeamOverrides, teamAKey])

  // Calculate sets won by each team
  const setsWon = useMemo(() => {
    if (!data) return { home: 0, away: 0, left: 0, right: 0 }

    const allSets = data.sets || []
    const finishedSets = allSets.filter(s => s.finished)

    const homeSetsWon = finishedSets.filter(s => s.homePoints > s.awayPoints).length
    const awaySetsWon = finishedSets.filter(s => s.awayPoints > s.homePoints).length

    const leftSetsWon = leftIsHome ? homeSetsWon : awaySetsWon
    const rightSetsWon = leftIsHome ? awaySetsWon : homeSetsWon

    return { home: homeSetsWon, away: awaySetsWon, left: leftSetsWon, right: rightSetsWon }
  }, [data, leftIsHome])

  // Check if each team's captain is on court (for showing "Designate Captain on Court" button)
  const captainOnCourtStatus = useMemo(() => {
    if (!data) return { home: { captainOnCourt: true, hasCourtCaptain: false }, away: { captainOnCourt: true, hasCourtCaptain: false } }

    const checkTeam = (teamKey) => {
      const teamPlayers = teamKey === 'home' ? data.homePlayers || [] : data.awayPlayers || []
      const teamLineupEvents = (data.events || [])
        .filter(e => e.type === 'lineup' && e.payload?.team === teamKey && e.setIndex === data.set?.index)
        .sort((a, b) => (b.seq || 0) - (a.seq || 0))

      const latestLineup = teamLineupEvents[0]?.payload?.lineup || {}
      const playersOnCourt = Object.values(latestLineup).map(n => String(n))

      // Find team captain
      const teamCaptain = teamPlayers.find(p => p.isCaptain || p.captain)
      if (!teamCaptain || !teamCaptain.number) return { captainOnCourt: true, hasCourtCaptain: false }

      const captainNumberStr = String(teamCaptain.number)
      const captainOnCourt = playersOnCourt.includes(captainNumberStr)

      // Get current court captain from match
      const courtCaptainField = teamKey === 'home' ? 'homeCourtCaptain' : 'awayCourtCaptain'
      const currentCourtCaptain = data.match?.[courtCaptainField]

      const result = {
        captainOnCourt,
        hasCourtCaptain: !!currentCourtCaptain,
        courtCaptainNumber: currentCourtCaptain
      }

      return result
    }

    return {
      home: checkTeam('home'),
      away: checkTeam('away')
    }
  }, [data])

  const mapSideToTeamKey = useCallback(
    side => {
      if (!data?.set) return 'home'
      if (side === 'left') {
        return leftIsHome ? 'home' : 'away'
      }
      return leftIsHome ? 'away' : 'home'
    },
    [data?.set, leftIsHome]
  )

  const mapTeamKeyToSide = useCallback(
    teamKey => {
      if (!data?.set) return 'left'
      if (teamKey === 'home') {
        return leftIsHome ? 'left' : 'right'
      }
      return leftIsHome ? 'right' : 'left'
    },
    [data?.set, leftIsHome]
  )

  const pointsBySide = useMemo(() => {
    if (!data?.set) return { left: 0, right: 0 }
    return leftIsHome
      ? { left: data.set.homePoints, right: data.set.awayPoints }
      : { left: data.set.awayPoints, right: data.set.homePoints }
  }, [data?.set, leftIsHome])

  const timeoutsUsed = useMemo(() => {
    if (!data?.events || !data?.set) return { home: 0, away: 0 }
    // Only count timeouts for the current set
    return data.events
      .filter(event => event.type === 'timeout' && event.setIndex === data.set.index)
      .reduce(
        (acc, event) => {
          const team = event.payload?.team
          if (team === 'home' || team === 'away') {
            acc[team] = (acc[team] || 0) + 1
          }
          return acc
        },
        { home: 0, away: 0 }
      )
  }, [data?.events, data?.set])

  const substitutionsUsed = useMemo(() => {
    if (!data?.events || !data?.set) return { home: 0, away: 0 }
    // Only count substitutions for the current set
    return data.events
      .filter(event => event.type === 'substitution' && event.setIndex === data.set.index)
      .reduce(
        (acc, event) => {
          const team = event.payload?.team
          if (team === 'home' || team === 'away') {
            acc[team] = (acc[team] || 0) + 1
          }
          return acc
        },
        { home: 0, away: 0 }
      )
  }, [data?.events, data?.set])

  const rallyStatus = useMemo(() => {
    if (!data?.events || !data?.set || data.events.length === 0) return 'idle'

    // Get events for current set only and sort by sequence number (most recent first)
    const currentSetEvents = data.events
      .filter(e => e.setIndex === data.set.index)
      .sort((a, b) => {
        // Sort by sequence number if available, otherwise by timestamp
        const aSeq = a.seq || 0
        const bSeq = b.seq || 0
        if (aSeq !== 0 || bSeq !== 0) {
          return bSeq - aSeq // Descending by sequence (most recent first)
        }
        // Fallback to timestamp for legacy events
        const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
        const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
        return bTime - aTime
      })

    if (currentSetEvents.length === 0) return 'idle'

    const lastEvent = currentSetEvents[0] // Most recent event is now first

    // Check if last event is point or replay first (these end the rally)
    if (lastEvent.type === 'point' || lastEvent.type === 'replay') {
      return 'idle'
    }

    if (lastEvent.type === 'rally_start') {
      return 'in_play'
    }

    // set_start means set is ready but rally hasn't started yet
    if (lastEvent.type === 'set_start') {
      return 'idle'
    }

    // For lineup events after points, the rally is idle (waiting for next rally_start)
    return 'idle'
  }, [data?.events, data?.set])

  // Check if the rally is replayed (last event is a replay)
  const isRallyReplayed = useMemo(() => {
    if (!data?.events || !data?.set || data.events.length === 0) return false

    // Get events for current set only and sort by sequence number (most recent first)
    const currentSetEvents = data.events
      .filter(e => e.setIndex === data.set.index)
      .sort((a, b) => {
        const aSeq = a.seq || 0
        const bSeq = b.seq || 0
        if (aSeq !== 0 || bSeq !== 0) {
          return bSeq - aSeq
        }
        const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
        const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
        return bTime - aTime
      })

    if (currentSetEvents.length === 0) return false

    const lastEvent = currentSetEvents[0]
    return lastEvent.type === 'replay'
  }, [data?.events, data?.set])

  // Check if the last event was a point (can replay rally)
  const canReplayRally = useMemo(() => {
    if (!data?.events || !data?.set || data.events.length === 0) {
      return false
    }

    // Get events for current set only and sort by sequence number (most recent first)
    const currentSetEvents = data.events
      .filter(e => e.setIndex === data.set.index)
      .sort((a, b) => {
        const aSeq = a.seq || 0
        const bSeq = b.seq || 0
        if (aSeq !== 0 || bSeq !== 0) {
          return bSeq - aSeq
        }
        const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
        const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
        return bTime - aTime
      })

    if (currentSetEvents.length === 0) {
      return false
    }

    const lastEvent = currentSetEvents[0]

    // Can replay rally if the last event was a point
    // OR if the last event is a rotation lineup that followed a point (same base seq)
    if (lastEvent.type === 'point') {
      return true
    }

    // Check if last event is a sub-event following a point (decimal seq like 5.1 or 5.2)
    // This covers rotation lineups, libero_exit, etc. that happen automatically after a point
    const lastSeq = lastEvent.seq || 0
    const isSubEvent = lastSeq !== Math.floor(lastSeq)
    if (isSubEvent) {
      // This is a sub-event - check if parent event was a point
      const baseSeq = Math.floor(lastSeq)
      const parentEvent = currentSetEvents.find(e => Math.floor(e.seq || 0) === baseSeq && e.type === 'point')
      if (parentEvent) {
        return true
      }
    }

    return false
  }, [data?.events, data?.set])

  const isFirstRally = useMemo(() => {
    if (!data?.events || !data?.set) return true
    // Check if there are any points in the current set
    // This determines if we show "Start set" vs "Start rally"
    const hasPoints = data.events.some(e => e.type === 'point' && e.setIndex === data.set.index)
    return !hasPoints
  }, [data?.events, data?.set])

  // Check if we're between sets (previous set finished, current set hasn't started)
  const isBetweenSets = useMemo(() => {
    if (!data?.sets || !data?.set) return false
    const allSets = data.sets.sort((a, b) => a.index - b.index)
    const currentSetIndex = data.set.index
    if (currentSetIndex === 1) return false // First set, not between sets

    const previousSet = allSets.find(s => s.index === currentSetIndex - 1)
    if (!previousSet || !previousSet.finished) return false

    // Check if current set has started (has points or set_start event)
    const hasSetStarted = data.events?.some(e =>
      (e.type === 'point' || e.type === 'set_start') && e.setIndex === currentSetIndex
    )

    return !hasSetStarted
  }, [data?.sets, data?.set, data?.events])

  // Start between-sets countdown when we detect we're between sets
  useEffect(() => {
    // Only start countdown if between sets AND countdown is null (not started yet)
    // Don't restart if countdown exists (even if finished) or was dismissed
    if (isBetweenSets && betweenSetsCountdown === null && !countdownDismissedRef.current) {
      // Calculate remaining time based on previous set's endTime
      const currentSetIndex = data?.set?.index || 1
      const previousSet = data?.sets?.find(s => s.index === currentSetIndex - 1)
      let remainingTime = setIntervalDuration

      if (previousSet?.endTime) {
        const endTime = new Date(previousSet.endTime).getTime()
        const now = Date.now()
        const elapsedSeconds = Math.floor((now - endTime) / 1000)
        remainingTime = Math.max(0, setIntervalDuration - elapsedSeconds)
      }

      // If time has already elapsed, mark as dismissed
      if (remainingTime <= 0) {
        countdownDismissedRef.current = true
      } else {
        setBetweenSetsCountdown({ countdown: remainingTime, started: true })
      }
    } else if (!isBetweenSets) {
      // Reset to null only when no longer between sets (new set started)
      setBetweenSetsCountdown(null)
      countdownDismissedRef.current = false // Reset for next time
    }
  }, [isBetweenSets, setIntervalDuration, data?.set?.index, data?.sets]) // Removed betweenSetsCountdown from deps to prevent restart loop

  // Handle between-sets countdown timer
  useEffect(() => {
    if (!betweenSetsCountdown || !betweenSetsCountdown.started) return

    // Initialize refs when interval starts
    if (!betweenSetsStartTimestampRef.current) {
      betweenSetsStartTimestampRef.current = Date.now()
      betweenSetsInitialCountdownRef.current = betweenSetsCountdown.countdown || 180
    }

    // Don't set interval if already at 0
    if (betweenSetsCountdown.countdown <= 0) {
      betweenSetsStartTimestampRef.current = null // Reset for next interval
      return
    }

    // Update every 100ms for smooth visuals (instead of 1000ms)
    const timer = setInterval(() => {
      const elapsed = Math.floor((Date.now() - betweenSetsStartTimestampRef.current) / 1000)
      const remaining = Math.max(0, betweenSetsInitialCountdownRef.current - elapsed)

      if (remaining <= 0) {
        // Auto-end the set interval when countdown reaches 0
        countdownDismissedRef.current = true
        setBetweenSetsCountdown(null)
        betweenSetsStartTimestampRef.current = null // Reset for next interval
      } else {
        setBetweenSetsCountdown(prev => {
          if (!prev || !prev.started) return prev
          return { ...prev, countdown: remaining }
        })
      }
    }, 100) // 100ms for smooth visual updates

    return () => clearInterval(timer)
  }, [betweenSetsCountdown])

  // Check if set has ended on page load/refresh (score indicates set over but modal not shown)
  useEffect(() => {
    // Don't run if set creation is in progress (prevents race condition)
    if (setCreationInProgressRef.current) return
    if (!data?.set || setEndTimeModal || data.set.finished) return

    // Don't re-show if user dismissed via undo for this set
    if (setEndModalDismissedRef.current === data.set.index) return

    // Don't show modal if this set was already confirmed (prevents race condition on double-confirm)
    if (confirmedSetEndRef.current.has(data.set.index)) return

    const homePoints = data.set.homePoints || 0
    const awayPoints = data.set.awayPoints || 0
    const is5thSet = data.set.index === 5
    const pointsToWin = is5thSet ? 15 : 25

    // Check if score indicates set should have ended
    const homeWon = homePoints >= pointsToWin && homePoints - awayPoints >= 2
    const awayWon = awayPoints >= pointsToWin && awayPoints - homePoints >= 2

    if (homeWon || awayWon) {
      // Set should have ended - show modal
      const winner = homeWon ? 'home' : 'away'

      // Calculate if this is match end
      const finishedSets = data.sets?.filter(s => s.finished) || []
      const homeSetsWon = finishedSets.filter(s => s.homePoints > s.awayPoints).length
      const awaySetsWon = finishedSets.filter(s => s.awayPoints > s.homePoints).length
      const isMatchEnd = winner === 'home' ? (homeSetsWon + 1) >= 3 : (awaySetsWon + 1) >= 3

      setSetEndTimeModal({
        setIndex: data.set.index,
        winner,
        homePoints,
        awayPoints,
        defaultTime: new Date().toISOString(),
        isMatchEnd
      })
    } else {
      // Score no longer indicates set end - clear the dismissed flag so modal can show again if needed
      if (setEndModalDismissedRef.current === data.set.index) {
        setEndModalDismissedRef.current = null
      }
    }
  }, [data?.set, data?.sets, setEndTimeModal])

  // Format countdown time: mm:ss format, but only seconds when < 60
  const formatCountdown = useCallback((seconds) => {
    if (seconds < 60) {
      return String(seconds)
    }
    const minutes = Math.floor(seconds / 60)
    const remainingSeconds = seconds % 60
    return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`
  }, [])

  // Format timeout: always just seconds
  const formatTimeout = useCallback((seconds) => {
    return String(seconds)
  }, [])

  // Get font family based on scoreFont setting
  const getScoreFont = useCallback(() => {
    const fonts = {
      'default': 'inherit',
      'orbitron': "'Orbitron', monospace",
      'roboto-mono': "'Roboto Mono', monospace",
      'jetbrains-mono': "'JetBrains Mono', monospace",
      'space-mono': "'Space Mono', monospace",
      'ibm-plex-mono': "'IBM Plex Mono', monospace"
    }
    return fonts[scoreFont] || 'inherit'
  }, [scoreFont])

  const stopBetweenSetsCountdown = useCallback(() => {
    setBetweenSetsCountdown(null)
  }, [])

  const endSetInterval = useCallback(() => {
    // Clear countdown and mark as dismissed so it doesn't restart
    setBetweenSetsCountdown(null)
    countdownDismissedRef.current = true
    // Notify referee to also close their countdown
    sendActionToReferee('end_interval', {})
    // Sync match_status back to 'in_progress' in Supabase
    syncLiveStateToSupabase('end_interval', null, null)
    // The set will start when user clicks "Start set" button
  }, [sendActionToReferee, syncLiveStateToSupabase])

  const getTeamLineupState = useCallback((teamKey) => {
    if (!data?.events || !data?.set) {
      return {
        lineupEvents: [],
        currentLineup: null,
        playersOnCourt: [],
        positionLiberoMap: {},
        playerLiberoMap: {}
      }
    }

    const teamPlayers = teamKey === 'home' ? data?.homePlayers || [] : data?.awayPlayers || []

    const lineupEvents = data.events
      .filter(e =>
        e.type === 'lineup' &&
        e.payload?.team === teamKey &&
        e.setIndex === data.set.index
      )
      .sort((a, b) => {
        // Sort by sequence number
        const aSeq = a.seq || 0
        const bSeq = b.seq || 0
        if (aSeq !== 0 || bSeq !== 0) {
          return aSeq - bSeq // Ascending
        }
        // Fallback to timestamp
        return new Date(a.ts) - new Date(b.ts)
      })

    if (lineupEvents.length === 0) {
      return {
        lineupEvents,
        currentLineup: null,
        playersOnCourt: [],
        positionLiberoMap: {},
        playerLiberoMap: {}
      }
    }

    const currentLineup = lineupEvents[lineupEvents.length - 1]?.payload?.lineup || {}


    // Ensure currentLineup only has valid positions (defensive check against 7 players bug)
    // If a position has an empty string, try to recover it from previous lineup events
    const validPositions = ['I', 'II', 'III', 'IV', 'V', 'VI']
    const cleanedCurrentLineup = {}

    // First pass: collect all valid player numbers from current lineup
    const currentPlayerNumbers = new Set()
    for (const pos of validPositions) {
      const playerNumber = currentLineup[pos]
      if (playerNumber !== undefined && playerNumber !== null && playerNumber !== '') {
        cleanedCurrentLineup[pos] = playerNumber
        currentPlayerNumbers.add(String(playerNumber))
      }
    }

    // Second pass: for missing positions, try to recover from previous lineup events
    // but only if the recovered player isn't already on court
    for (const pos of validPositions) {
      if (cleanedCurrentLineup[pos] !== undefined) {
        continue // Already has a valid player
      }

      // Look backwards through lineup events to find the last valid player number for this position
      for (let i = lineupEvents.length - 2; i >= 0; i--) {
        const prevLineup = lineupEvents[i]?.payload?.lineup
        const prevPlayerNumber = prevLineup?.[pos]
        if (prevPlayerNumber && prevPlayerNumber !== '' && prevPlayerNumber !== null && prevPlayerNumber !== undefined) {
          // Only use this recovered player if they're not already on court in another position
          const prevPlayerNumberStr = String(prevPlayerNumber)
          if (!currentPlayerNumbers.has(prevPlayerNumberStr)) {
            cleanedCurrentLineup[pos] = prevPlayerNumber
            currentPlayerNumbers.add(prevPlayerNumberStr)
            break
          }
        }
      }
    }

    const playersOnCourt = Object.values(cleanedCurrentLineup)
      .filter(num => num !== undefined && num !== null && num !== '')
      .map(num => Number(num))
      .filter(num => !Number.isNaN(num) && num !== 0)


    const positionLiberoMap = {}
    const playerLiberoMap = {}

    const findLatestLiberoSubstitution = (liberoNumber) => {
      // Find the most recent libero substitution for this libero, regardless of position
      // This is important because positions change during rotation, but the libero number stays the same
      for (let i = lineupEvents.length - 1; i >= 0; i--) {
        const maybeSub = lineupEvents[i]?.payload?.liberoSubstitution
        if (
          maybeSub &&
          String(maybeSub.liberoNumber) === String(liberoNumber)
        ) {
          return maybeSub
        }
      }
      return null
    }

    for (const [position, playerNumber] of Object.entries(cleanedCurrentLineup)) {
      const player = teamPlayers.find(p => String(p.number) === String(playerNumber))
      if (player?.libero && player.libero !== '') {
        // Find the libero substitution by libero number (not position, since position changes during rotation)
        const subInfo = findLatestLiberoSubstitution(playerNumber)
        const originalPlayerNumber = subInfo?.playerNumber ?? null

        positionLiberoMap[position] = {
          liberoNumber: Number(playerNumber),
          liberoType: player.libero,
          playerNumber: originalPlayerNumber
        }

        if (originalPlayerNumber !== null && originalPlayerNumber !== undefined) {
          playerLiberoMap[String(originalPlayerNumber)] = {
            liberoNumber: Number(playerNumber),
            liberoType: player.libero
          }
        }
      }
    }

    return {
      lineupEvents,
      currentLineup: cleanedCurrentLineup, // Return cleaned lineup
      playersOnCourt,
      positionLiberoMap,
      playerLiberoMap
    }
  }, [data?.events, data?.set, data?.homePlayers, data?.awayPlayers])

  // Check if captain is on court and show modal to select new captain if needed
  const checkAndRequestCaptainOnCourt = useCallback(async (teamKey) => {
    // Check if manage captain on court is enabled
    if (!localManageCaptainOnCourt) return

    const teamPlayers = teamKey === 'home' ? data?.homePlayers || [] : data?.awayPlayers || []
    const teamLineupState = getTeamLineupState(teamKey)
    const playersOnCourt = teamLineupState.playersOnCourt || []

    // Find team captain
    const teamCaptain = teamPlayers.find(p => p.isCaptain || p.captain)
    if (!teamCaptain || !teamCaptain.number) return

    // Check if captain is on court (use string comparison to avoid type mismatch issues)
    const captainNumberStr = String(teamCaptain.number)
    const captainOnCourt = playersOnCourt.some(n => String(n) === captainNumberStr)

    // Get current captain on court from match
    const courtCaptainField = teamKey === 'home' ? 'homeCourtCaptain' : 'awayCourtCaptain'
    const rememberedField = teamKey === 'home' ? 'homeRememberedCourtCaptain' : 'awayRememberedCourtCaptain'
    const match = await db.matches.get(matchId)
    const currentCourtCaptain = match?.[courtCaptainField]
    const rememberedCourtCaptain = match?.[rememberedField]

    // If team captain is on court, they automatically become captain on court
    // Team captain has precedence over everyone - clear court captain (but keep in memory)
    if (captainOnCourt) {
      if (currentCourtCaptain && String(currentCourtCaptain) !== captainNumberStr) {
        // Clear court captain (team captain takes over) but don't clear memory
        await db.matches.update(matchId, { [courtCaptainField]: null })
        console.log(`[CaptainOnCourt] Team captain #${captainNumberStr} returned, cleared court captain`)
        // Sync the cleared court captain to Supabase/Referee
        syncLiveStateToSupabase('court_captain_cleared', teamKey, { captainNumber: teamCaptain.number })
        syncToReferee()
      }
      return
    }

    // Captain is NOT on court - check if we need to designate someone
    console.log(`[CaptainOnCourt DEBUG] Team captain #${captainNumberStr} is NOT on court`)
    console.log(`[CaptainOnCourt DEBUG] playersOnCourt:`, playersOnCourt)
    console.log(`[CaptainOnCourt DEBUG] currentCourtCaptain:`, currentCourtCaptain)
    console.log(`[CaptainOnCourt DEBUG] rememberedCourtCaptain:`, rememberedCourtCaptain)

    // If there's already a valid court captain on court, no need to do anything
    if (currentCourtCaptain) {
      const courtCaptainStr = String(currentCourtCaptain)
      const courtCaptainOnCourt = playersOnCourt.some(n => String(n) === courtCaptainStr)
      console.log(`[CaptainOnCourt DEBUG] currentCourtCaptain #${courtCaptainStr} on court?`, courtCaptainOnCourt)
      if (courtCaptainOnCourt) {
        console.log(`[CaptainOnCourt DEBUG] --> Court captain still on court, no action needed`)
        return // Court captain is still on court, no action needed
      }
    }

    // No valid court captain - check if remembered captain is on court for auto-designation
    if (rememberedCourtCaptain) {
      const rememberedStr = String(rememberedCourtCaptain)
      const rememberedOnCourt = playersOnCourt.some(n => String(n) === rememberedStr)
      console.log(`[CaptainOnCourt DEBUG] rememberedCourtCaptain #${rememberedStr} on court?`, rememberedOnCourt)
      if (rememberedOnCourt) {
        // Auto-designate remembered captain
        console.log(`[CaptainOnCourt DEBUG] --> AUTO-DESIGNATING remembered captain #${rememberedCourtCaptain}`)
        await db.matches.update(matchId, { [courtCaptainField]: rememberedCourtCaptain })
        // Log the event using ref to avoid circular dependency
        if (logEventRef.current) {
          await logEventRef.current('court_captain_designation', {
            team: teamKey,
            playerNumber: rememberedCourtCaptain,
            previousCourtCaptain: currentCourtCaptain || null,
            auto: true  // Mark as automatic
          })
        }
        return
      }
    }

    // No remembered captain on court - show modal to select new captain
    console.log(`[CaptainOnCourt DEBUG] --> No valid captain, SHOWING MODAL`)
    console.log(`[CaptainOnCourt] Showing modal for ${teamKey} - playersOnCourt:`, playersOnCourt, `captain #${captainNumberStr}`)
    setCaptainOnCourtModal({ team: teamKey })
  }, [localManageCaptainOnCourt, data, matchId, getTeamLineupState, syncLiveStateToSupabase, syncToReferee])

  // Keep ref updated with latest function to avoid stale closures in setTimeout
  useEffect(() => {
    checkAndRequestCaptainOnCourtRef.current = checkAndRequestCaptainOnCourt
  }, [checkAndRequestCaptainOnCourt])

  const buildOnCourt = useCallback((players, isLeft, teamKey) => {
    const { currentLineup, positionLiberoMap } = getTeamLineupState(teamKey)

    // Check if there's an INITIAL lineup set for this team in the current set
    const hasInitialLineup = data?.events?.some(e =>
      e.type === 'lineup' &&
      e.payload?.team === teamKey &&
      e.setIndex === data?.set?.index &&
      e.payload?.isInitial === true
    )

    // Fixed positions:
    // Left team: Front row (0,1,2): IV, III, II | Back row (3,4,5): V, VI, I
    // Right team: Front row (0,1,2): II, III, IV | Back row (3,4,5): I, VI, V (I is top right)
    const leftPositions = ['IV', 'III', 'II', 'V', 'VI', 'I']
    const rightPositions = ['II', 'III', 'IV', 'I', 'VI', 'V']
    const fixedPositions = isLeft ? leftPositions : rightPositions

    // If initial lineup hasn't been set for this set, show empty placeholders
    // This ensures all players are on the bench (available for sanctions)
    if (!hasInitialLineup) {
      return Array(6).fill(null).map((_, idx) => {
        return {
          id: `placeholder-${idx}`,
          number: '',
          isPlaceholder: true,
          position: fixedPositions[idx],
          isCaptain: false
        }
      })
    }

    // Use the current lineup (could be initial, rotation, or substitution)
    const savedLineup = currentLineup

    // If lineup is saved, use it to map players to fixed positions
    if (savedLineup) {
      // Ensure savedLineup only has valid positions (defensive check)
      const validPositions = ['I', 'II', 'III', 'IV', 'V', 'VI']
      const cleanedLineup = {}
      for (const pos of validPositions) {
        // Only include positions that have a valid player number (not undefined, null, or empty string)
        const playerNumber = savedLineup[pos]
        if (playerNumber !== undefined && playerNumber !== null && playerNumber !== '') {
          cleanedLineup[pos] = playerNumber
        }
      }
      // Ensure we only return exactly 6 players, using only the fixed positions
      const result = fixedPositions.slice(0, 6).map((pos, idx) => {
        const playerNumber = cleanedLineup[pos]
        // Handle both undefined/null and empty string cases, but preserve 0 as valid
        const hasPlayerNumber = playerNumber !== undefined && playerNumber !== null && playerNumber !== ''
        // Convert both to strings for comparison to handle number/string mismatches
        const player = hasPlayerNumber ? players?.find(p => String(p.number) === String(playerNumber)) : null
        const isLibero = player?.libero && player.libero !== ''
        const liberoSub = positionLiberoMap[pos]

        // Check if this player is the court captain (only when team captain is NOT on court)
        const courtCaptainField = teamKey === 'home' ? 'homeCourtCaptain' : 'awayCourtCaptain'
        const courtCaptainNum = data?.match?.[courtCaptainField]
        const teamCaptain = players?.find(p => p.isCaptain || p.captain)
        const captainOnCourt = teamCaptain && currentLineup && Object.values(currentLineup).some(num => String(num) === String(teamCaptain.number))
        const isCourtCaptain = !captainOnCourt && hasPlayerNumber && courtCaptainNum && String(courtCaptainNum) === String(playerNumber)

        const playerData = {
          id: player?.id ?? `placeholder-${idx}`,
          number: hasPlayerNumber ? String(playerNumber) : '',
          name: player?.name || '',
          firstName: player?.firstName || '',
          lastName: player?.lastName || '',
          isPlaceholder: !hasPlayerNumber,
          position: pos, // Fixed position on court
          isCaptain: player?.isCaptain || false,
          isCourtCaptain: isCourtCaptain,
          isLibero: isLibero || !!liberoSub,
          substitutedPlayerNumber: liberoSub?.playerNumber || null,
          liberoType: liberoSub?.liberoType || (isLibero ? player.libero : null)
        }
        return playerData
      })

      // Safety check: ensure we return exactly 6 players
      if (result.length !== 6) {
        // Pad or trim to exactly 6
        while (result.length < 6) {
          const idx = result.length
          result.push({
            id: `placeholder-${idx}`,
            number: '',
            isPlaceholder: true,
            position: fixedPositions[idx] || '',
            isCaptain: false
          })
        }
        return result.slice(0, 6)
      }

      return result
    }

    // Fallback: use default player list
    const trimmed = (players || []).slice(0, 6)
    const placeholders = Array.from({ length: 6 - trimmed.length }, (_, idx) => ({
      placeholder: true,
      number: `–`
    }))
    const allPlayers = [...trimmed, ...placeholders]

    return allPlayers.map((player, idx) => {
      const assignedPos = fixedPositions[idx]
      return {
        id: player.id ?? `placeholder-${idx}`,
        number:
          player.number !== undefined && player.number !== null
            ? player.number
            : player.placeholder
              ? '–'
              : '',
        name: player.name || '',
        firstName: player.firstName || '',
        lastName: player.lastName || '',
        isPlaceholder: !!player.placeholder,
        position: assignedPos,
        isCaptain: player.isCaptain || false
      }
    })
  }, [rallyStatus, isFirstRally, getTeamLineupState, data?.events, data?.set, data?.match?.homeCourtCaptain, data?.match?.awayCourtCaptain])

  const getCurrentLineup = useCallback(
    teamKey => {
      if (!data?.events || !data?.set) return null
      const lineupEvents = data.events
        .filter(
          e =>
            e.type === 'lineup' &&
            e.payload?.team === teamKey &&
            e.setIndex === data.set.index
        )
        .sort((a, b) => {
          // Sort by sequence number
          const aSeq = a.seq || 0
          const bSeq = b.seq || 0
          if (aSeq !== 0 || bSeq !== 0) {
            return aSeq - bSeq // Ascending
          }
          // Fallback to timestamp
          return new Date(a.ts) - new Date(b.ts)
        })

      if (lineupEvents.length === 0) return null
      return lineupEvents[lineupEvents.length - 1].payload?.lineup || null
    },
    [data?.events, data?.set]
  )

  const leftTeam = useMemo(() => {
    if (!data) return { name: 'Team A', color: '#ef4444', players: [] }
    const players = leftIsHome ? data.homePlayers : data.awayPlayers
    const team = leftIsHome ? data.homeTeam : data.awayTeam
    const teamKey = leftIsHome ? 'home' : 'away'
    const isTeamA = teamKey === teamAKey
    return {
      name: team?.name || (leftIsHome ? 'Home' : 'Away'),
      color: team?.color || (leftIsHome ? '#ef4444' : '#3b82f6'),
      playersOnCourt: buildOnCourt(players, true, teamKey),
      isTeamA
    }
  }, [buildOnCourt, data, leftIsHome, teamAKey])

  const rightTeam = useMemo(() => {
    if (!data) return { name: 'Team B', color: '#3b82f6', players: [] }
    const players = leftIsHome ? data.awayPlayers : data.homePlayers
    const team = leftIsHome ? data.awayTeam : data.homeTeam
    const teamKey = leftIsHome ? 'away' : 'home'
    const isTeamA = teamKey === teamAKey
    return {
      name: team?.name || (leftIsHome ? 'Away' : 'Home'),
      color: team?.color || (leftIsHome ? '#3b82f6' : '#ef4444'),
      playersOnCourt: buildOnCourt(players, false, teamKey),
      isTeamA
    }
  }, [buildOnCourt, data, leftIsHome, teamAKey])

  // Check if lineups are set for each team in the current set
  const leftTeamLineupSet = useMemo(() => {
    if (!data?.events || !data?.set) return false
    const teamKey = leftIsHome ? 'home' : 'away'
    return data.events.some(e =>
      e.type === 'lineup' &&
      e.payload?.team === teamKey &&
      e.setIndex === data.set.index &&
      e.payload?.isInitial
    )
  }, [data?.events, data?.set, leftIsHome])

  const rightTeamLineupSet = useMemo(() => {
    if (!data?.events || !data?.set) return false
    const teamKey = leftIsHome ? 'away' : 'home'
    return data.events.some(e =>
      e.type === 'lineup' &&
      e.payload?.team === teamKey &&
      e.setIndex === data.set.index &&
      e.payload?.isInitial
    )
  }, [data?.events, data?.set, leftIsHome])

  // Track which lineups we've already validated (to prevent infinite modal loops)
  const validatedLineupRef = useRef({ home: null, away: null })

  // Validate lineup - check if any player in lineup has become a libero
  // If so, invalidate the lineup and reopen lineup modal (only once per issue)
  useEffect(() => {
    if (!data?.events || !data?.set || !data?.homePlayers || !data?.awayPlayers) return
    if (lineupModal) return // Don't interfere if modal already open

    const validateTeamLineup = (teamKey) => {
      const players = teamKey === 'home' ? data.homePlayers : data.awayPlayers
      const liberoNumbers = new Set(
        players.filter(p => p.libero && p.libero !== '').map(p => Number(p.number))
      )

      // Find the most recent initial lineup event for this team in current set
      const initialLineups = data.events
        .filter(e =>
          e.type === 'lineup' &&
          e.payload?.team === teamKey &&
          e.setIndex === data.set.index &&
          e.payload?.isInitial
        )
        .sort((a, b) => new Date(b.ts) - new Date(a.ts)) // Most recent first

      const initialLineup = initialLineups[0]
      if (!initialLineup || !initialLineup.payload?.lineup) return null

      // Check if any player in lineup is now a libero
      const lineup = initialLineup.payload.lineup
      const invalidPlayers = []
      for (const [position, playerNumber] of Object.entries(lineup)) {
        if (liberoNumbers.has(Number(playerNumber))) {
          invalidPlayers.push({ position, playerNumber })
        }
      }

      if (invalidPlayers.length > 0) {
        // Create a key for this specific issue
        const issueKey = `${data.set.index}-${invalidPlayers.map(p => p.playerNumber).sort().join(',')}`

        // Only show modal if we haven't already shown it for this exact issue
        if (validatedLineupRef.current[teamKey] !== issueKey) {
          validatedLineupRef.current[teamKey] = issueKey
          return teamKey
        }
      } else {
        // Lineup is valid, clear the validation flag
        validatedLineupRef.current[teamKey] = null
      }
      return null
    }

    const leftTeamKey = leftIsHome ? 'home' : 'away'
    const rightTeamKey = leftIsHome ? 'away' : 'home'

    // Check if left team lineup has invalid players
    const invalidLeftTeam = leftTeamLineupSet ? validateTeamLineup(leftTeamKey) : null
    const invalidRightTeam = rightTeamLineupSet ? validateTeamLineup(rightTeamKey) : null

    if (invalidLeftTeam) {
      setLineupModal({ team: invalidLeftTeam, mode: 'initial', reason: 'Player in lineup is now a libero - please update lineup' })
    } else if (invalidRightTeam) {
      setLineupModal({ team: invalidRightTeam, mode: 'initial', reason: 'Player in lineup is now a libero - please update lineup' })
    }
  }, [data?.events, data?.set, data?.homePlayers, data?.awayPlayers, leftIsHome, leftTeamLineupSet, rightTeamLineupSet, lineupModal])

  // Get bench players, liberos, and bench officials for each team
  const leftTeamBench = useMemo(() => {
    if (!data) return { benchPlayers: [], liberos: [], benchOfficials: [] }
    const teamKey = leftIsHome ? 'home' : 'away'
    const players = leftIsHome ? data.homePlayers : data.awayPlayers
    const benchOfficials = leftIsHome ? (data.match?.bench_home || []) : (data.match?.bench_away || [])

    const { playersOnCourt, playerLiberoMap } = getTeamLineupState(teamKey)
    const playersOnCourtSet = new Set(playersOnCourt.map(num => Number(num)))


    const benchPlayers = players
      .filter(p => {
        const playerNumber = Number(p.number)
        if (Number.isNaN(playerNumber) || playersOnCourtSet.has(playerNumber) || (p.libero && p.libero !== '')) {
          return false
        }

        // Keep expelled/disqualified/exceptionally substituted players on bench (they'll show with X)
        // They should be visible but not selectable for substitutions/lineups

        return true
      })
      .map(p => {
        const playerNumber = Number(p.number)
        const substitutedInfo = playerLiberoMap[String(playerNumber)] || null
        return {
          ...p,
          substitutedByLibero: substitutedInfo
        }
      })

    const liberos = players
      .filter(p => {
        const playerNumber = Number(p.number)
        return p.libero && p.libero !== '' && !playersOnCourtSet.has(playerNumber)
      })
      .sort((a, b) => (Number(a.number) || 0) - (Number(b.number) || 0))

    return {
      benchPlayers,
      liberos,
      benchOfficials
    }
  }, [data, leftIsHome, getTeamLineupState, teamAKey, data?.events])

  const rightTeamBench = useMemo(() => {
    if (!data) return { benchPlayers: [], liberos: [], benchOfficials: [] }
    const teamKey = leftIsHome ? 'away' : 'home'
    const players = leftIsHome ? data.awayPlayers : data.homePlayers
    const benchOfficials = leftIsHome ? (data.match?.bench_away || []) : (data.match?.bench_home || [])

    const { playersOnCourt, playerLiberoMap } = getTeamLineupState(teamKey)
    const playersOnCourtSet = new Set(playersOnCourt.map(num => Number(num)))


    const benchPlayers = players
      .filter(p => {
        const playerNumber = Number(p.number)
        if (Number.isNaN(playerNumber) || playersOnCourtSet.has(playerNumber) || (p.libero && p.libero !== '')) {
          return false
        }

        // Keep expelled/disqualified/exceptionally substituted players on bench (they'll show with X)
        // They should be visible but not selectable for substitutions/lineups

        return true
      })
      .map(p => {
        const playerNumber = Number(p.number)
        const substitutedInfo = playerLiberoMap[String(playerNumber)] || null
        return {
          ...p,
          substitutedByLibero: substitutedInfo
        }
      })

    const liberos = players
      .filter(p => {
        const playerNumber = Number(p.number)
        return p.libero && p.libero !== '' && !playersOnCourtSet.has(playerNumber)
      })
      .sort((a, b) => (Number(a.number) || 0) - (Number(b.number) || 0))

    return {
      benchPlayers,
      liberos,
      benchOfficials
    }
  }, [data, leftIsHome, getTeamLineupState, teamAKey, data?.events])

  const formatTimestamp = useCallback(date => {
    return date.toLocaleString(undefined, {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    })
  }, [])

  const isBrightColor = useCallback(color => {
    if (!color || color === 'image.png') return false
    const hex = color.replace('#', '')
    const r = parseInt(hex.substr(0, 2), 16)
    const g = parseInt(hex.substr(2, 2), 16)
    const b = parseInt(hex.substr(4, 2), 16)
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255
    return luminance > 0.5
  }, [])

  // Helper function to get next sequence number for events (returns integer only)
  const getNextSeq = useCallback(async () => {
    const allEvents = await db.events.where('matchId').equals(matchId).toArray()
    const coinTossEvent = allEvents.find(e => e.type === 'coin_toss')

    // Get the maximum base ID (integer part only, ignoring decimals)
    const maxBaseSeq = allEvents.reduce((max, e) => {
      const seq = e.seq || 0
      const baseSeq = Math.floor(seq) // Get integer part only
      return Math.max(max, baseSeq)
    }, 0)

    // If coin toss exists and has seq=1, ensure next seq is at least 2
    // Otherwise, if no coin toss exists, the next event should be seq=1 (for coin toss)
    // But if coin toss already exists, start from maxBaseSeq + 1
    if (coinTossEvent && Math.floor(coinTossEvent.seq || 0) === 1) {
      return Math.max(2, maxBaseSeq + 1)
    }
    return maxBaseSeq + 1
  }, [matchId])

  // Helper function to get next sub-sequence number for related events (returns decimal like 1.1, 1.2, etc.)
  const getNextSubSeq = useCallback(async (parentSeq) => {
    const allEvents = await db.events.where('matchId').equals(matchId).toArray()
    const baseSeq = Math.floor(parentSeq)

    // Find all events with the same base ID (1, 1.1, 1.2, etc.)
    const relatedEvents = allEvents.filter(e => {
      const eSeq = e.seq || 0
      return Math.floor(eSeq) === baseSeq
    })

    // Find the highest sub-sequence number for this base ID
    const maxSubSeq = relatedEvents.reduce((max, e) => {
      const eSeq = e.seq || 0
      const eBaseSeq = Math.floor(eSeq)
      if (eBaseSeq === baseSeq && eSeq !== baseSeq) {
        // This is a sub-event (has decimal part)
        const subPart = eSeq - baseSeq // e.g., 1.2 - 1 = 0.2
        return Math.max(max, subPart)
      }
      return max
    }, 0)

    // Return next sub-sequence (increment by 0.1)
    return baseSeq + (maxSubSeq + 0.1)
  }, [matchId])

  // Debug functions (available in console)
  useEffect(() => {
    if (typeof window !== 'undefined') {
      // Debug function to export match data as JSON (for testing fillable PDF)
      window.debugExportMatchData = async () => {
        try {
          const allEvents = await db.events.where('matchId').equals(matchId).toArray()
          const allSets = await db.sets.where('matchId').equals(matchId).toArray()
          const allReferees = await db.referees.toArray()
          const allScorers = await db.scorers.toArray()

          const matchData = {
            match: data?.match,
            homeTeam: data?.homeTeam,
            awayTeam: data?.awayTeam,
            homePlayers: data?.homePlayers || [],
            awayPlayers: data?.awayPlayers || [],
            sets: allSets,
            events: allEvents,
            referees: allReferees,
            scorers: allScorers
          }

          // Log to console

          // Also download as file
          const blob = new Blob([JSON.stringify(matchData, null, 2)], { type: 'application/json' })
          const url = URL.createObjectURL(blob)
          const a = document.createElement('a')
          a.href = url
          a.download = `match-data-${matchId || 'export'}.json`
          document.body.appendChild(a)
          a.click()
          document.body.removeChild(a)
          URL.revokeObjectURL(url)

        } catch (error) {
          console.error('Error exporting match data:', error)
        }
      }

      // Function to generate fillable PDF (simple form filling)
      window.debugGenerateFillablePDF = async () => {
        try {
          const match = data?.match
          if (!match) {
            console.error('No match data available')
            return
          }

          // Prepare match data in the format expected by fillPdfForm
          const fillableData = {
            match_type_1: match.matchType || match.match_type_1 || 'championship',
            match_type_2: match.gender || match.match_type_2 || '',
            league: match.league || '',
            gameNumber: match.gameNumber || match.externalId || '',
            homeTeam: data?.homeTeam?.name || '',
            awayTeam: data?.awayTeam?.name || '',
            city: match.city || '',
            hall: match.venue || match.hall || '',
            scheduledAt: match.scheduledAt,
            bench_home: match.bench_home || [],
            bench_away: match.bench_away || [],
            officials: match.officials || []
          }

          await generateFillablePdf(fillableData)
        } catch (error) {
          console.error('Error generating fillable PDF:', error)
        }
      }

      // Debug function to check games in progress
      window.debugCheckGamesInProgress = async () => {
        try {
          console.log('[DEBUG] Checking games from two sources:')
          console.log('   1. Local IndexedDB (current match data)')
          console.log('   2. Server API (what Referee Dashboard sees)')
          console.log('')

          // 1. Check local IndexedDB
          const allMatches = await db.matches.toArray()
          const inProgressMatches = allMatches.filter(m =>
            m.status === 'live' || m.status === 'scheduled'
          )

          console.log(`[DEBUG] Local IndexedDB: ${inProgressMatches.length} match(es)`)

          // 2. Check server API (what Referee Dashboard actually uses)
          let serverMatches = []
          try {
            const { listAvailableMatches } = await import('../utils_beach/serverDataSync_beach')
            const serverResult = await listAvailableMatches()
            if (serverResult.success && serverResult.matches) {
              serverMatches = serverResult.matches
            }
          } catch (err) {
            console.warn('[DEBUG] Could not fetch from server API:', err.message)
          }

          console.log(`[DEBUG] Server API: ${serverMatches.length} match(es) available in Referee Dashboard`)
          console.log('')

          if (serverMatches.length > 0 && inProgressMatches.length === 0) {
            console.log('[DEBUG] DISCREPANCY DETECTED!')
            console.log('   Server has matches but local DB does not.')
            console.log('   This means matches exist in server memory but not synced to local DB.')
            console.log('')
          }

          // Show server matches (what actually appears in dropdown)
          if (serverMatches.length > 0) {
            console.log('[DEBUG] Matches available in Referee Dashboard dropdown:')
            console.table(serverMatches.map(m => ({
              id: m.id,
              gameNumber: m.gameNumber,
              homeTeam: m.homeTeam,
              awayTeam: m.awayTeam,
              status: m.status,
              dateTime: m.dateTime,
              refereeConnectionEnabled: m.refereeConnectionEnabled
            })))

            serverMatches.forEach((m, idx) => {
              console.log(`\n[DEBUG] Server Match ${idx + 1}:`)
              console.log(`   ID: ${m.id}`)
              console.log(`   Game #: ${m.gameNumber}`)
              console.log(`   Teams: ${m.homeTeam} vs ${m.awayTeam}`)
              console.log(`   Status: ${m.status}`)
              console.log(`   Date/Time: ${m.dateTime}`)
              console.log(`   Referee Connection: ${m.refereeConnectionEnabled ? 'Enabled' : 'Disabled'}`)
            })
          }

          // Show local DB matches with details
          if (inProgressMatches.length > 0) {
            const matchesWithDetails = await Promise.all(
              inProgressMatches.map(async (match) => {
                const homeTeam = match.homeTeamId ? await db.teams.get(match.homeTeamId) : null
                const awayTeam = match.awayTeamId ? await db.teams.get(match.awayTeamId) : null
                const sets = await db.sets.where('matchId').equals(match.id).toArray()
                const currentSet = sets.find(s => !s.finished) || sets[sets.length - 1]
                const eventCount = await db.events.where('matchId').equals(match.id).count()
                const isCurrentMatch = matchId && String(match.id) === String(matchId)

                return {
                  id: match.id,
                  gameNumber: match.gameNumber || match.externalId || 'N/A',
                  homeTeam: homeTeam?.name || 'Unknown',
                  awayTeam: awayTeam?.name || 'Unknown',
                  status: match.status,
                  isLive: match.status === 'live',
                  currentSet: currentSet ? {
                    index: currentSet.index,
                    homePoints: currentSet.homePoints,
                    awayPoints: currentSet.awayPoints
                  } : null,
                  totalSets: sets.length,
                  eventCount: eventCount,
                  refereeConnectionEnabled: match.refereeConnectionEnabled === true,
                  isCurrentMatch: isCurrentMatch
                }
              })
            )

            console.log('\n[DEBUG] Local IndexedDB matches:')
            console.table(matchesWithDetails)

            matchesWithDetails.forEach((m, idx) => {
              const statusLabel = m.isLive ? '[LIVE]' : '[SCHEDULED]'
              console.log(`\n${statusLabel} Local Match ${idx + 1}:${m.isCurrentMatch ? ' (CURRENT)' : ''}`)
              console.log(`   ID: ${m.id}`)
              console.log(`   Game #: ${m.gameNumber}`)
              console.log(`   Teams: ${m.homeTeam} vs ${m.awayTeam}`)
              console.log(`   Status: ${m.status} ${m.isLive ? '(LIVE)' : '(SCHEDULED)'}`)
              if (m.currentSet) {
                console.log(`   Current Set: Set ${m.currentSet.index + 1} - ${m.currentSet.homePoints} - ${m.currentSet.awayPoints}`)
              }
              console.log(`   Total Sets: ${m.totalSets}, Events: ${m.eventCount}`)
            })
          }

          return {
            localDB: { matches: inProgressMatches, count: inProgressMatches.length },
            serverAPI: { matches: serverMatches, count: serverMatches.length }
          }
        } catch (error) {
          console.error('[DEBUG] Error checking games in progress:', error)
          return { localDB: { matches: [], count: 0 }, serverAPI: { matches: [], count: 0 }, error: error.message }
        }
      }
    }
    return () => {
      if (typeof window !== 'undefined') {
        if (window.debugExportMatchData) delete window.debugExportMatchData
        if (window.debugGenerateFillablePDF) delete window.debugGenerateFillablePDF
        if (window.debugCheckGamesInProgress) delete window.debugCheckGamesInProgress
      }
    }
  }, [matchId, data?.match, data?.homeTeam, data?.awayTeam, data?.homePlayers, data?.awayPlayers])

  // Helper function to log manual changes for the summary
  const logManualChange = useCallback((category, field, before, after, description) => {
    const change = {
      ts: new Date().toISOString(),
      category,
      field,
      before,
      after,
      description: description || `Changed ${field} from "${before}" to "${after}"`
    }
    console.log('[ManualChange] New change:', change)
    setManualChangesLog(prev => [...prev, change])

    // Also update the match record with the new change
    if (matchId && data?.match) {
      const existingChanges = data.match.manualChanges || []
      const updatedChanges = [...existingChanges, change]
      console.log('[ManualChange] Saving to IndexedDB:', { matchId, existingCount: existingChanges.length, newCount: updatedChanges.length })
      db.matches.update(matchId, { manualChanges: updatedChanges }).catch((err) => {
        console.error('[ManualChange] IndexedDB error:', err)
      })

      // Sync to Supabase
      if (supabase && data.match?.seed_key) {
        console.log('[ManualChange] Syncing to Supabase:', { seed_key: data.match.seed_key, changes: updatedChanges })
        supabase
          .from('matches')
          .update({ manual_changes: updatedChanges })
          .eq('external_id', data.match.seed_key)
          .eq('sport_type', SPORT_TYPE)
          .select('id, external_id, manual_changes')
          .then((result) => {
            console.log('[ManualChange] Supabase result:', result)
            if (result.data && result.data.length > 0) {
              console.log('[ManualChange] Updated row:', result.data[0])
            } else {
              console.warn('[ManualChange] NO ROWS UPDATED! external_id not found:', data.match.seed_key)
            }
          })
          .catch((err) => {
            console.error('[ManualChange] Supabase error:', err)
          })
      } else {
        console.log('[ManualChange] No Supabase sync:', { hasSupabase: !!supabase, seed_key: data.match?.seed_key })
      }
    } else {
      console.log('[ManualChange] No match data:', { matchId, hasMatch: !!data?.match })
    }

    return change
  }, [matchId, data?.match, supabase])

  const logEvent = useCallback(
    async (type, payload = {}, options = {}) => {
      const _t0 = performance.now()
      console.log(`[PERF] logEvent START: ${type}`)

      if (!data?.set) return null

      // skipMutex: true if caller already holds the mutex (e.g., confirmSubstitution)
      const shouldAcquireMutex = !options.skipMutex

      // MUTEX: Wait for any in-progress event to complete to prevent race conditions
      // This ensures snapshots always see all previous events
      if (shouldAcquireMutex) {
        const maxWaitTime = 5000 // 5 seconds max wait
        const startWait = Date.now()
        while (eventInProgressRef.current && (Date.now() - startWait) < maxWaitTime) {
          await new Promise(resolve => setTimeout(resolve, 10))
        }
        if (eventInProgressRef.current) {
          console.warn('[logEvent] Timeout waiting for previous event, proceeding anyway')
        }
        eventInProgressRef.current = true
      }
      console.log(`[PERF] After mutex: +${(performance.now() - _t0).toFixed(0)}ms`)

      try {
        // CRITICAL: Use setIndexOverride if provided, otherwise query fresh from IndexedDB
        let actualSetIndex = options.setIndexOverride
        if (actualSetIndex === undefined) {
          // Query fresh current set to avoid stale data after set transitions
          const allSets = await db.sets.where('matchId').equals(matchId).toArray()
          const freshCurrentSet = allSets.find(s => !s.finished) || allSets[allSets.length - 1]
          actualSetIndex = freshCurrentSet?.index || data.set.index
        }
        console.log(`[PERF] After sets query: +${(performance.now() - _t0).toFixed(0)}ms`)

        // Get max sequence using compound index (O(log n) instead of O(n) full scan)
        const lastEvent = await db.events.where('[matchId+seq]').between([matchId, Dexie.minKey], [matchId, Dexie.maxKey]).last()
        const maxExistingSeq = lastEvent?.seq || 0
        console.log(`[PERF] After seq query (compound idx): +${(performance.now() - _t0).toFixed(0)}ms`)

        // If parentSeq is provided, create a sub-event with decimal ID (e.g., 1.1, 1.2)
        // Otherwise, create a main event with integer ID
        let nextSeq
        if (options.parentSeq !== undefined) {
          nextSeq = await getNextSubSeq(options.parentSeq)
        } else {
          nextSeq = await getNextSeq()
        }
        console.log(`[PERF] After getNextSeq: +${(performance.now() - _t0).toFixed(0)}ms`)

        // CRITICAL: Validate sequence number is always increasing
        if (nextSeq <= maxExistingSeq && Math.floor(nextSeq) !== Math.floor(maxExistingSeq)) {
          console.error(`[SEQUENCE ERROR] New seq ${nextSeq} is not greater than existing max ${maxExistingSeq}! Type: ${type}`)
          debugLogger.log('SEQUENCE_ERROR', {
            error: 'Sequence number not incrementing correctly',
            newSeq: nextSeq,
            maxExistingSeq,
            eventType: type,
            payload
          })
        }

        // Simple timestamp for reference (not used for ordering)
        const timestamp = options.timestamp ? new Date(options.timestamp) : new Date()

        // Add event first (without snapshot - we need the event to exist to capture state)
        const eventId = await db.events.add({
          matchId,
          setIndex: actualSetIndex,
          type,
          payload,
          ts: timestamp.toISOString(), // Store as ISO string for reference
          seq: nextSeq // Use sequence for ordering
        })
        console.log(`[PERF] After db.events.add: +${(performance.now() - _t0).toFixed(0)}ms`)

        // Capture FULL state snapshot AFTER the event is applied
        // This is the key to the snapshot-based undo system
        const stateSnapshot = await captureFullStateSnapshot()
        console.log(`[PERF] After captureFullStateSnapshot: +${(performance.now() - _t0).toFixed(0)}ms`)

        // Update the event with the snapshot
        if (stateSnapshot) {
          await db.events.update(eventId, { stateSnapshot })
        }
        console.log(`[PERF] After db.events.update (snapshot): +${(performance.now() - _t0).toFixed(0)}ms`)

        // Log the event with state snapshots
        debugLogger.log('EVENT_CREATED', {
          eventId,
          type,
          payload,
          seq: nextSeq,
          setIndex: actualSetIndex,
          hasSnapshot: !!stateSnapshot
        })

        // Get match to check if it's a test match
        const match = await db.matches.get(matchId)
        const isTest = match?.test || false
        console.log(`[PERF] After match.get: +${(performance.now() - _t0).toFixed(0)}ms`)

        // Only sync official matches to Supabase, not test matches
        if (!isTest) {
          // Query fresh events from IndexedDB to get current lineups (avoid stale closure)
          const allEventsForSync = await db.events.where({ matchId }).toArray()
          console.log(`[PERF] After allEventsForSync query: +${(performance.now() - _t0).toFixed(0)}ms`)
          const setIndex = actualSetIndex // Use the fresh set index, not stale data.set.index

          // Get rich lineup for a team from fresh event data (same format as match_live_state)
          const getRichLineupForTeamFresh = (teamKey, isServingTeam) => {
            const lineupEvents = allEventsForSync
              .filter(e => e.type === 'lineup' && e.payload?.team === teamKey && e.setIndex === setIndex)
              .sort((a, b) => (a.seq || 0) - (b.seq || 0))
            if (lineupEvents.length === 0) return null

            const lastLineupEvent = lineupEvents[lineupEvents.length - 1]
            const rawLineup = lastLineupEvent.payload?.lineup || {}
            const liberoSubstitution = lastLineupEvent.payload?.liberoSubstitution

            // Get initial lineup (first lineup event)
            const initialLineup = lineupEvents[0]?.payload?.lineup || {}

            // Get players for this team
            const teamPlayers = teamKey === 'home' ? data.homePlayers : data.awayPlayers

            // Get substitution events for this team in this set
            const substitutionEvents = allEventsForSync
              .filter(e => e.type === 'substitution' && e.payload?.team === teamKey && e.setIndex === setIndex)

            // Get captain info
            const captainNum = teamKey === 'home' ? match?.homeCaptain : match?.awayCaptain
            const courtCaptainNum = teamKey === 'home' ? match?.homeCourtCaptain : match?.awayCourtCaptain

            const backRowPositions = ['I', 'V', 'VI']
            const richLineup = {}

            for (const position of ['I', 'II', 'III', 'IV', 'V', 'VI']) {
              const playerNum = rawLineup[position]
              if (!playerNum && playerNum !== 0) continue

              const playerNumStr = String(playerNum)
              const player = teamPlayers?.find(p => String(p.number) === playerNumStr)
              const isBackRow = backRowPositions.includes(position)

              const positionData = {
                number: Number(playerNum) || playerNum
              }

              // Add serving info for position I
              if (position === 'I' && isServingTeam) {
                positionData.isServing = true
              }

              // Add libero info
              if (player?.libero && player.libero !== '') {
                positionData.isLibero = true
                positionData.liberoType = player.libero
                // Find who the libero replaced
                if (liberoSubstitution && String(liberoSubstitution.liberoNumber) === playerNumStr) {
                  positionData.replacedNumber = liberoSubstitution.playerNumber
                }
              }

              // Add substitution info
              const subEvent = substitutionEvents.find(e => String(e.payload?.playerIn) === playerNumStr)
              if (subEvent) {
                positionData.isSubstituted = true
                positionData.substitutedFor = subEvent.payload?.playerOut
              }

              // Add captain info
              if (String(captainNum) === playerNumStr) {
                positionData.isCaptain = true
              }
              if (String(courtCaptainNum) === playerNumStr) {
                positionData.isCourtCaptain = true
              }

              richLineup[position] = positionData
            }

            return Object.keys(richLineup).length > 0 ? richLineup : null
          }

          // Simple lineup getter for server number lookup
          const getLineupForTeamFresh = (teamKey) => {
            const lineupEvents = allEventsForSync
              .filter(e => e.type === 'lineup' && e.payload?.team === teamKey && e.setIndex === setIndex)
              .sort((a, b) => (a.seq || 0) - (b.seq || 0))
            if (lineupEvents.length === 0) return null
            const lastLineup = lineupEvents[lineupEvents.length - 1]
            return lastLineup.payload?.lineup || null
          }

          // A/B Model: Team A = coin toss winner (constant), side_a = which side they're on
          const teamAKey = match?.coinTossTeamA || 'home'
          const teamBKey = teamAKey === 'home' ? 'away' : 'home'
          const setLeftTeamOverrides = match?.setLeftTeamOverrides || {}

          // Determine which side Team A is on this set
          // setLeftTeamOverrides stores 'A' or 'B', set5LeftTeam stores 'A' or 'B'
          let sideA // 'left' or 'right'
          if (setLeftTeamOverrides[setIndex] !== undefined) {
            sideA = setLeftTeamOverrides[setIndex] === 'A' ? 'left' : 'right'
          } else if (setIndex === 5 && match?.set5CourtSwitched && match?.set5LeftTeam) {
            sideA = match.set5LeftTeam === 'A' ? 'left' : 'right'
          } else {
            // Default: Team A on left in odd sets (1, 3, 5), right in even sets (2, 4)
            sideA = setIndex % 2 === 1 ? 'left' : 'right'
          }

          // Derive left/right team keys from A/B model
          const leftTeamKey = sideA === 'left' ? teamAKey : teamBKey
          const rightTeamKey = sideA === 'left' ? teamBKey : teamAKey

          // Calculate serving team (same logic as getCurrentServe)
          const set1FirstServe = match?.firstServe || 'home'
          let currentSetFirstServe
          if (setIndex === 5 && match?.set5FirstServe) {
            currentSetFirstServe = match.set5FirstServe === 'A' ? teamAKey : teamBKey
          } else if (setIndex === 5) {
            currentSetFirstServe = set1FirstServe
          } else {
            currentSetFirstServe = setIndex % 2 === 1 ? set1FirstServe : (set1FirstServe === 'home' ? 'away' : 'home')
          }

          // Find last point event from fresh data to determine current serve
          const pointEventsForSync = allEventsForSync
            .filter(e => e.type === 'point' && e.setIndex === setIndex)
            .sort((a, b) => (b.seq || 0) - (a.seq || 0))
          const servingTeam = pointEventsForSync.length > 0 ? (pointEventsForSync[0].payload?.team || currentSetFirstServe) : currentSetFirstServe

          // Get server number from position I of serving team's lineup
          const servingTeamLineup = getLineupForTeamFresh(servingTeam)
          const serverNumber = servingTeamLineup?.['I'] ? Number(servingTeamLineup['I']) : null

          // Get fresh score from the current set for this event
          const allSetsForScore = await db.sets.where('matchId').equals(matchId).toArray()
          const currentSetForScore = allSetsForScore.find(s => s.index === setIndex)
          // teamAKey already defined above at line 3265
          const scoreA = teamAKey === 'home' ? (currentSetForScore?.homePoints || 0) : (currentSetForScore?.awayPoints || 0)
          const scoreB = teamAKey === 'home' ? (currentSetForScore?.awayPoints || 0) : (currentSetForScore?.homePoints || 0)

          await db.sync_queue.add({
            resource: 'event',
            action: 'insert',
            payload: {
              external_id: String(eventId),
              match_id: match?.seed_key || String(matchId), // Use seed_key (external_id) for Supabase lookup
              set_index: setIndex,
              type,
              payload: payload || {},
              seq: nextSeq,
              test: false,
              created_at: new Date().toISOString(),
              // Rich lineup format (same as match_live_state) with libero, sub, captain info
              lineup_left: getRichLineupForTeamFresh(leftTeamKey, servingTeam === leftTeamKey),
              lineup_right: getRichLineupForTeamFresh(rightTeamKey, servingTeam === rightTeamKey),
              serve_team: servingTeam,
              serve_player: serverNumber,
              // Score AFTER this event (Team A/B model)
              score_a: scoreA,
              score_b: scoreB,
              // Full state snapshot for snapshot-based undo/restore
              state_snapshot: stateSnapshot
            },
            ts: Date.now(),
            status: 'queued'
          })
          console.log(`[PERF] After sync_queue.add: +${(performance.now() - _t0).toFixed(0)}ms`)
        }

        // Sync to referee after every event
        syncToReferee()
        console.log(`[PERF] After syncToReferee: +${(performance.now() - _t0).toFixed(0)}ms`)

        // Sync live state to Supabase for key events
        const keyEvents = ['point', 'timeout', 'substitution', 'set_start', 'set_end', 'lineup', 'sanction', 'libero_entry', 'libero_exit', 'libero_exchange', 'court_captain_designation']
        if (keyEvents.includes(type)) {
          const eventTeam = payload?.team || null
          let eventData = null
          if (type === 'substitution') {
            eventData = { playerIn: payload?.playerIn, playerOut: payload?.playerOut }
          } else if (type === 'timeout') {
            eventData = { duration: 30 }
          } else if (type === 'set_end') {
            // Note: logEvent('set_end', { team: winner, ... }) uses 'team' for the winner
            eventData = { setIndex: payload?.setIndex || data.set.index, winner: payload?.team }
          } else if (type === 'libero_entry' || type === 'libero_exit') {
            eventData = { liberoNumber: payload?.liberoNumber, playerNumber: payload?.playerNumber }
          } else if (type === 'libero_exchange') {
            eventData = { liberoIn: payload?.liberoIn, liberoOut: payload?.liberoOut }
          } else if (type === 'court_captain_designation') {
            eventData = { playerNumber: payload?.playerNumber }
          } else if (type === 'sanction') {
            eventData = {
              type: payload?.type,
              playerType: payload?.playerType || null,
              playerNumber: payload?.playerNumber || null,
              role: payload?.role || null
            }
          }
          // For events that change the lineup, don't use cached snapshot - it was captured BEFORE the event
          // was added to the database. Let syncLiveStateToSupabase fetch a fresh one.
          const lineupChangingEvents = ['libero_entry', 'libero_exit', 'libero_exchange', 'substitution', 'lineup']
          const useSnapshot = lineupChangingEvents.includes(type) ? null : stateSnapshot
          syncLiveStateToSupabase(type, eventTeam, eventData, useSnapshot)
          console.log(`[PERF] After syncLiveStateToSupabase: +${(performance.now() - _t0).toFixed(0)}ms`)
        }

        // Continuous cloud backup after every event (non-blocking, throttled)
        if (!isTest) {
          const gameNum = data?.match?.gameNumber || data?.match?.game_n || null
          triggerContinuousBackup(matchId, () => exportMatchData(matchId), gameNum)
        }

        // Return the sequence number so it can be used for related events
        console.log(`[PERF] logEvent END: ${type} - TOTAL: ${(performance.now() - _t0).toFixed(0)}ms`)
        return nextSeq
      } finally {
        // MUTEX: Only release the lock if we acquired it
        if (shouldAcquireMutex) {
          eventInProgressRef.current = false
        }
      }
    },
    [data?.set, matchId, getNextSeq, getNextSubSeq, captureFullStateSnapshot, syncToReferee, syncLiveStateToSupabase]
  )

  // Keep logEventRef updated with latest function to avoid circular dependencies
  useEffect(() => {
    logEventRef.current = logEvent
  }, [logEvent])

  const checkSetEnd = useCallback(async (set, homePoints, awayPoints) => {
    // Don't show modal if it's already open
    if (setEndTimeModal) return false

    // Determine if this is the 3rd set (tie-break set)
    const is3rdSet = set.index === 3
    const pointsToWin = is3rdSet ? 15 : 21

    // Check if this point would end the set
    if (homePoints >= pointsToWin && homePoints - awayPoints >= 2) {
      // Close all libero modals
      setLiberoRotationModal(null)
      setLiberoReentryModal(null)
      setLiberoConfirm(null)
      setLiberoDropdown(null)
      setExchangeLiberoDropdown(null)

      // Calculate current set scores to determine if this is match-ending
      const allSets = await db.sets.where({ matchId }).toArray()
      const finishedSets = allSets.filter(s => s.finished)
      const homeSetsWon = finishedSets.filter(s => s.homePoints > s.awayPoints).length
      const awaySetsWon = finishedSets.filter(s => s.awayPoints > s.homePoints).length

      // If home wins this set, will they have 2 sets?
      const isMatchEnd = (homeSetsWon + 1) >= 2

      // Show set end time confirmation modal
      const defaultTime = new Date().toISOString()
      setSetEndTimeModal({ setIndex: set.index, winner: 'home', homePoints, awayPoints, defaultTime, isMatchEnd })
      return true
    }
    if (awayPoints >= pointsToWin && awayPoints - homePoints >= 2) {
      // Close all libero modals
      setLiberoRotationModal(null)
      setLiberoReentryModal(null)
      setLiberoConfirm(null)
      setLiberoDropdown(null)
      setExchangeLiberoDropdown(null)

      // Calculate current set scores to determine if this is match-ending
      const allSets = await db.sets.where({ matchId }).toArray()
      const finishedSets = allSets.filter(s => s.finished)
      const homeSetsWon = finishedSets.filter(s => s.homePoints > s.awayPoints).length
      const awaySetsWon = finishedSets.filter(s => s.awayPoints > s.homePoints).length

      // If away wins this set, will they have 2 sets?
      const isMatchEnd = (awaySetsWon + 1) >= 2

      // Show set end time confirmation modal
      const defaultTime = new Date().toISOString()
      setSetEndTimeModal({ setIndex: set.index, winner: 'away', homePoints, awayPoints, defaultTime, isMatchEnd })
      return true
    }
    return false
  }, [matchId, setEndTimeModal])

  // Determine who has serve based on events
  const getCurrentServe = useCallback(() => {
    if (!data?.set || !data?.match) {
      return data?.match?.firstServe || 'home'
    }

    const setIndex = data.set.index
    const set1FirstServe = data.match.firstServe || 'home'

    // Calculate first serve for current set based on alternation pattern
    // Set 1: set1FirstServe
    // Set 2: opposite of set1FirstServe
    // Set 3: same as set1FirstServe
    // Set 4: opposite of set1FirstServe
    // Set 5: uses set5FirstServe (separate coin toss)
    let currentSetFirstServe

    if (setIndex === 5 && data.match?.set5FirstServe) {
      // Set 5 uses separate coin toss
      const teamAKey = data.match.coinTossTeamA || 'home'
      const teamBKey = data.match.coinTossTeamB || 'away'
      currentSetFirstServe = data.match.set5FirstServe === 'A' ? teamAKey : teamBKey
    } else if (setIndex === 5) {
      // Set 5 without set5FirstServe specified - fallback to alternation
      currentSetFirstServe = set1FirstServe
    } else {
      // Sets 1-4: odd sets (1, 3) same as set 1, even sets (2, 4) opposite
      currentSetFirstServe = setIndex % 2 === 1 ? set1FirstServe : (set1FirstServe === 'home' ? 'away' : 'home')
    }

    if (!data?.events || data.events.length === 0) {
      return currentSetFirstServe
    }

    // Find the last point event in the current set to determine serve
    const pointEvents = data.events
      .filter(e => e.type === 'point' && e.setIndex === data.set.index)
      .sort((a, b) => {
        const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
        const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
        return bTime - aTime // Most recent first
      })

    if (pointEvents.length === 0) {
      return currentSetFirstServe
    }

    // The team that scored the last point now has serve
    const lastPoint = pointEvents[0]
    return lastPoint.payload?.team || currentSetFirstServe
  }, [data?.events, data?.set, data?.match, data?.match?.set5FirstServe])

  const leftServeTeamKey = leftIsHome ? 'home' : 'away'
  const rightServeTeamKey = leftIsHome ? 'away' : 'home'

  // Before coin toss or before set starts, show serve on left (home) as placeholder
  const isBeforeCoinToss = !data?.match?.coinTossTeamA || !data?.match?.coinTossTeamB
  const hasNoSet = !data?.set

  const currentServeTeam = data?.set ? getCurrentServe() : null

  // Show serve on left as placeholder before coin toss or before set starts
  const leftServing = (isBeforeCoinToss || hasNoSet)
    ? true // Placeholder: serve on left (home) before coin toss
    : (data?.set ? currentServeTeam === leftServeTeamKey : false)
  const rightServing = (isBeforeCoinToss || hasNoSet)
    ? false
    : (data?.set ? currentServeTeam === rightServeTeamKey : false)

  const serveBallBaseStyle = useMemo(
    () => ({
      width: '28px',
      height: '28px',
      filter: 'drop-shadow(0 2px 6px rgba(0, 0, 0, 0.35))'
    }),
    []
  )

  const renderScoreDisplay = useCallback(
    (style = {}) => (
      <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', ...style }}>
        {/* Score display container - all elements absolute, colon at center */}
        <div
          className="set-score-display"
          style={{
            position: 'relative',
            width: isCompactMode ? '200px' : isLaptopMode ? '280px' : '350px',
            height: isCompactMode ? '60px' : isLaptopMode ? '85px' : '105px',
            padding: '5px 0',
            letterSpacing: 0
          }}
        >
          {/* Left score - right edge ends before colon */}
          <span style={{
            position: 'absolute',
            right: '50%',
            marginRight: isCompactMode ? '24px' : isLaptopMode ? '32px' : '40px',
            fontVariantNumeric: 'tabular-nums',
            fontSize: isCompactMode ? '52px' : isLaptopMode ? '75px' : '95px',
            fontFamily: getScoreFont(),
            lineHeight: 1,
            letterSpacing: 0,
            minWidth: isCompactMode ? '60px' : isLaptopMode ? '85px' : '110px',
            textAlign: 'right'
          }}>{pointsBySide.left}</span>
          {/* Colon - absolute at center */}
          <span style={{
            position: 'absolute',
            left: '50%',
            transform: 'translateX(-50%)',
            fontSize: isCompactMode ? '52px' : isLaptopMode ? '75px' : '95px',
            fontFamily: getScoreFont(),
            lineHeight: 1,
            letterSpacing: 0
          }}>:</span>
          {/* Right score - left edge starts after colon */}
          <span style={{
            position: 'absolute',
            left: '50%',
            marginLeft: isCompactMode ? '24px' : isLaptopMode ? '32px' : '40px',
            fontVariantNumeric: 'tabular-nums',
            fontSize: isCompactMode ? '52px' : isLaptopMode ? '75px' : '95px',
            fontFamily: getScoreFont(),
            lineHeight: 1,
            letterSpacing: 0,
            minWidth: isCompactMode ? '60px' : isLaptopMode ? '85px' : '110px',
            textAlign: 'left'
          }}>{pointsBySide.right}</span>
        </div>
      </div>
    ),
    [pointsBySide.left, pointsBySide.right, isCompactMode, isLaptopMode]
  )

  const openManualLineup = useCallback(
    teamKey => {
      if (!data?.set) return
      const existingLineup = getCurrentLineup(teamKey)
      setLineupModal({ team: teamKey, mode: 'manual', lineup: existingLineup })
    },
    [data?.set, getCurrentLineup]
  )

  // Rotate lineup: II→I, III→II, IV→III, V→IV, VI→V, I→VI
  const rotateLineup = useCallback((lineup) => {
    if (!lineup) return null

    const newLineup = {
      I: lineup.II || '',
      II: lineup.III || '',
      III: lineup.IV || '',
      IV: lineup.V || '',
      V: lineup.VI || '',
      VI: lineup.I || ''
    }

    return newLineup
  }, [])

  const handlePoint = useCallback(
    async (side, skipConfirmation = false) => {
      cLogger.logHandler('handlePoint', { side, skipConfirmation })
      if (!data?.set) return
      const teamKey = mapSideToTeamKey(side)

      // Check for accidental point award (if enabled and rally just started)
      if (checkAccidentalPointAward && !skipConfirmation && rallyStartTimeRef.current) {
        const timeSinceRallyStart = (Date.now() - rallyStartTimeRef.current) / 1000
        if (timeSinceRallyStart < accidentalPointAwardDuration) {
          setAccidentalPointConfirmModal({
            team: teamKey,
            onConfirm: () => {
              setAccidentalPointConfirmModal(null)
              handlePoint(side, true) // Call with skipConfirmation = true
            }
          })
          return
        }
      }

      // CRITICAL: Query fresh current set from IndexedDB to avoid stale data after set transitions
      // Use same deduplication logic as useLiveQuery: prefer highest ID for duplicate indices
      const allSets = await db.sets.where('matchId').equals(matchId).toArray()
      const setsByIndex = new Map()
      for (const set of allSets) {
        const existing = setsByIndex.get(set.index)
        if (!existing || set.id > existing.id) {
          setsByIndex.set(set.index, set)
        }
      }
      const dedupedSets = Array.from(setsByIndex.values()).sort((a, b) => a.index - b.index)
      const freshCurrentSet = dedupedSets.find(s => !s.finished) || dedupedSets[dedupedSets.length - 1]
      if (!freshCurrentSet) return

      const field = teamKey === 'home' ? 'homePoints' : 'awayPoints'
      const newPoints = (freshCurrentSet[field] || 0) + 1
      const homePoints = teamKey === 'home' ? newPoints : (freshCurrentSet.homePoints || 0)
      const awayPoints = teamKey === 'away' ? newPoints : (freshCurrentSet.awayPoints || 0)

      // Check who has serve BEFORE this point by querying database directly
      // The team that scored the last point has serve, so check the last point in DB
      const allEventsBeforePoint = await db.events
        .where('matchId')
        .equals(matchId)
        .toArray()
      const pointEventsBefore = allEventsBeforePoint
        .filter(e => e.type === 'point' && e.setIndex === freshCurrentSet.index)
        .sort((a, b) => {
          const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
          const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
          return bTime - aTime // Most recent first
        })

      // Calculate first serve for current set based on alternation pattern
      // Set 1: firstServe, Set 2: opposite, Set 3: same as Set 1, etc.
      const setIndex = freshCurrentSet.index
      const set1FirstServe = data?.match?.firstServe || 'home'
      let currentSetFirstServe

      if (setIndex === 5 && data.match?.set5FirstServe) {
        const teamAKey = data.match.coinTossTeamA || 'home'
        const teamBKey = data.match.coinTossTeamB || 'away'
        currentSetFirstServe = data.match.set5FirstServe === 'A' ? teamAKey : teamBKey
      } else if (setIndex === 5) {
        currentSetFirstServe = set1FirstServe
      } else {
        // Sets 1-4: odd sets (1, 3) same as set 1, even sets (2, 4) opposite
        currentSetFirstServe = setIndex % 2 === 1 ? set1FirstServe : (set1FirstServe === 'home' ? 'away' : 'home')
      }

      let serveBeforePoint = currentSetFirstServe
      if (pointEventsBefore.length > 0) {
        // The last point event shows who has serve now (before this new point)
        const lastPoint = pointEventsBefore[0] // Most recent is first after sorting
        serveBeforePoint = lastPoint.payload?.team || serveBeforePoint
      }

      const scoringTeamHadServe = serveBeforePoint === teamKey

      // Update score and log point FIRST (using fresh set ID)
      await db.sets.update(freshCurrentSet.id, {
        [field]: newPoints
      })
      const pointSeq = await logEvent('point', { team: teamKey, score: { home: homePoints, away: awayPoints } }, { setIndexOverride: setIndex })

      // Debug log: point awarded
      debugLogger.log('POINT_AWARDED', {
        team: teamKey,
        side,
        newScore: { home: homePoints, away: awayPoints },
        serveBeforePoint,
        scoringTeamHadServe,
        setIndex: setIndex,
        pointSeq
      }, getStateSnapshot())

      // Track when point was awarded (for accidental rally start check)
      lastPointAwardedTimeRef.current = Date.now()
      // Reset rally start time since rally ended
      rallyStartTimeRef.current = null

      // If scoring team didn't have serve, they rotate their lineup AFTER the point
      if (!scoringTeamHadServe) {
        // Query database directly for the most recent lineup (data.events might be stale)
        const allLineupEvents = await db.events
          .where('matchId')
          .equals(matchId)
          .toArray()
        const teamLineupEvents = allLineupEvents
          .filter(e => e.type === 'lineup' && e.payload?.team === teamKey && e.setIndex === setIndex)
          .sort((a, b) => new Date(b.ts) - new Date(a.ts)) // Most recent first

        let currentLineup = null
        let liberoSubstitution = null

        if (teamLineupEvents.length > 0) {
          // Use the most recent lineup
          const lastLineupEvent = teamLineupEvents[0]
          currentLineup = lastLineupEvent.payload?.lineup
          liberoSubstitution = lastLineupEvent?.payload?.liberoSubstitution
        }

        if (currentLineup) {

          // Rotate the lineup
          const rotatedLineup = rotateLineup(currentLineup)
          if (rotatedLineup) {
            // Rotate the libero substitution position if it exists
            let rotatedLiberoSubstitution = null
            if (liberoSubstitution) {
              // Map old position to new position after rotation
              const positionMap = {
                'I': 'VI',
                'II': 'I',
                'III': 'II',
                'IV': 'III',
                'V': 'IV',
                'VI': 'V'
              }
              const newPosition = positionMap[liberoSubstitution.position]
              if (newPosition) {
                rotatedLiberoSubstitution = {
                  ...liberoSubstitution,
                  position: newPosition
                }
              }
            }

            // Check if any libero is in front-row positions (II, III, IV) - remove them immediately
            const teamPlayers = teamKey === 'home' ? data.homePlayers : data.awayPlayers
            const frontRowPositions = ['II', 'III', 'IV']
            let liberoInFrontRow = null

            for (const [pos, num] of Object.entries(rotatedLineup)) {
              if (frontRowPositions.includes(pos)) {
                const player = teamPlayers?.find(p => String(p.number) === String(num))
                if (player?.libero && player.libero !== '') {
                  liberoInFrontRow = [pos, num]
                  break
                }
              }
            }

            // If libero is in front row, automatically remove them
            let liberoExitedInfo = null
            if (liberoInFrontRow) {
              const [position, liberoNumber] = liberoInFrontRow

              // Find the original player that should be in this position
              // Query database directly for lineup events (data.events might be stale)
              const allLineupEventsForLibero = await db.events
                .where('matchId')
                .equals(matchId)
                .toArray()
              const allLineupEventsFiltered = allLineupEventsForLibero
                .filter(e =>
                  e.type === 'lineup' &&
                  e.payload?.team === teamKey &&
                  e.setIndex === setIndex
                )
                .sort((a, b) => new Date(b.ts) - new Date(a.ts)) // Most recent first

              let originalPlayerNumber = null

              console.log('[Rotation] Libero in front row detected:', {
                position,
                liberoNumber,
                rotatedLiberoSubstitution,
                rotatedLineup
              })

              // First, try to use the rotated libero substitution if the libero matches
              // The position in rotatedLiberoSubstitution is the NEW position after rotation
              // But we need to check if this libero is the one in the front row position
              if (rotatedLiberoSubstitution &&
                String(rotatedLiberoSubstitution.liberoNumber) === String(liberoNumber)) {
                // Check if this is the same libero (regardless of position match, since position was rotated)
                originalPlayerNumber = rotatedLiberoSubstitution.playerNumber
                console.log('[Rotation] Found original player from rotatedLiberoSubstitution:', originalPlayerNumber)
              } else {
                // If rotatedLiberoSubstitution doesn't match, search for the original libero substitution
                // We need to find the libero substitution BEFORE rotation to get the original player
                for (const event of allLineupEventsFiltered) {
                  if (event.payload?.liberoSubstitution &&
                    String(event.payload.liberoSubstitution.liberoNumber) === String(liberoNumber)) {
                    // Found the libero substitution - use the original player
                    originalPlayerNumber = event.payload.liberoSubstitution.playerNumber
                    break
                  }
                }

                // If still not found, we need to find who was in the PRE-ROTATION position
                // The current position is AFTER rotation, so we need to reverse the rotation
                // to find who was there before rotation
                if (!originalPlayerNumber) {
                  // Reverse rotation map: if libero is now in position X after rotation,
                  // they were in position Y before rotation, where Y rotates to X
                  // Rotation: II→I, III→II, IV→III, V→IV, VI→V, I→VI
                  // Reverse: I→II, II→III, III→IV, IV→V, V→VI, VI→I
                  const reversePositionMap = {
                    'I': 'II',
                    'II': 'III',
                    'III': 'IV',
                    'IV': 'V',
                    'V': 'VI',
                    'VI': 'I'
                  }
                  const preRotationPosition = reversePositionMap[position]

                  // Now find who was in the pre-rotation position before the libero entered
                  for (const event of allLineupEventsFiltered) {
                    const lineup = event.payload?.lineup
                    if (lineup && lineup[preRotationPosition]) {
                      const playerNum = lineup[preRotationPosition]
                      const player = teamPlayers?.find(p => String(p.number) === String(playerNum))
                      // If this position had a non-libero player, and it's not the libero, use it
                      if (player && (!player.libero || player.libero === '') &&
                        String(playerNum) !== String(liberoNumber)) {
                        // But check if this player is already in the rotated lineup
                        let playerAlreadyInRotatedLineup = false
                        for (const [pos, num] of Object.entries(rotatedLineup)) {
                          if (String(num) === String(playerNum)) {
                            playerAlreadyInRotatedLineup = true
                            break
                          }
                        }
                        if (!playerAlreadyInRotatedLineup) {
                          originalPlayerNumber = Number(playerNum)
                          break
                        }
                      }
                    }
                  }
                }
              }

              // If we found the original player, restore them
              if (originalPlayerNumber) {
                // Check if the original player is already in the rotated lineup in another position
                // If so, we should NOT restore them (they're already on court in their rotated position)
                let originalPlayerAlreadyOnCourt = false
                for (const [pos, playerNum] of Object.entries(rotatedLineup)) {
                  if (pos !== position && String(playerNum) === String(originalPlayerNumber)) {
                    // The original player is already in another position after rotation
                    // This means they rotated to a different position, so we should NOT restore them here
                    originalPlayerAlreadyOnCourt = true
                    break
                  }
                }

                if (originalPlayerAlreadyOnCourt) {
                  // The original player is already on court in another position
                  // This indicates a bug in libero tracking - the recorded "original player" is wrong
                  // BUG: This should NEVER happen - the player replaced by libero should be on bench
                  console.error('[Rotation] BUG: Original player', originalPlayerNumber,
                    'found in rotatedLineup at another position. This is a libero tracking bug!',
                    { rotatedLineup, liberoNumber, position, liberoSubstitution })
                  // NEVER leave position empty - restore the original player anyway
                  // The duplicate will need to be fixed manually
                  rotatedLineup[position] = String(originalPlayerNumber)
                  rotatedLiberoSubstitution = null
                } else {
                  // Original player is not on court, safe to restore them
                  rotatedLineup[position] = String(originalPlayerNumber)
                  rotatedLiberoSubstitution = null // Clear libero substitution since libero is out
                }

                // Store info about the libero that was removed
                const liberoPlayer = teamPlayers?.find(p => String(p.number) === String(liberoNumber))
                liberoExitedInfo = {
                  liberoNumber: Number(liberoNumber),
                  liberoType: liberoPlayer?.libero,
                  originalPlayerNumber: originalPlayerNumber
                }

                // Calculate if this point finishes the set
                const isSet5 = setIndex === 5
                const winningScore = isSet5 ? 15 : 25
                // We must use the NEW scores that were just calculated above
                // homePoints/awayPoints variables hold the updated score
                const currentDiff = Math.abs(homePoints - awayPoints)
                const leaderPoints = Math.max(homePoints, awayPoints)
                const isSetFinished = leaderPoints >= winningScore && currentDiff >= 2

                // Show modal that libero must go out (if option enabled) AND set is not finished
                if (liberoExitConfirmation && !isSetFinished) {
                  setLiberoRotationModal({
                    team: teamKey,
                    position: position,
                    liberoNumber: Number(liberoNumber),
                    playerNumber: originalPlayerNumber,
                    liberoType: liberoPlayer?.libero
                  })
                }

                // Log libero exit (after point, so use point relative time + 2ms)
                // Use decimal ID based on the point's action ID (e.g., if point is 1, libero_exit is 1.2)
                await logEvent('libero_exit', {
                  team: teamKey,
                  position: position,
                  liberoOut: liberoNumber,
                  playerIn: originalPlayerNumber,
                  liberoType: liberoPlayer?.libero,
                  reason: 'rotation_to_front_row'
                }, { parentSeq: pointSeq })

                // Check if the libero leaving is the court captain
                const captainOnCourtField = teamKey === 'home' ? 'homeCourtCaptain' : 'awayCourtCaptain'
                const currentCourtCaptain = data?.match?.[captainOnCourtField]
                if (String(currentCourtCaptain) === String(liberoNumber)) {
                  setTimeout(() => {
                    checkAndRequestCaptainOnCourtRef.current?.(teamKey)
                  }, 300)
                }
              } else {
                // Fallback: if we can't find the original player, keep libero there
                // NEVER leave position empty - libero in front row is wrong but 5 players is worse
                console.warn('[Rotation] Cannot find original player for libero at position', position,
                  '. Keeping libero in front row. Libero:', liberoNumber)
                // Don't set to empty - keep libero there (will need manual fix)
                rotatedLiberoSubstitution = null
              }
            }

            // Ensure rotated lineup only has exactly 6 positions (defensive check)
            const validPositions = ['I', 'II', 'III', 'IV', 'V', 'VI']
            const cleanedRotatedLineup = {}
            for (const pos of validPositions) {
              if (rotatedLineup[pos] !== undefined && rotatedLineup[pos] !== '' && rotatedLineup[pos] !== null) {
                cleanedRotatedLineup[pos] = rotatedLineup[pos]
              }
            }

            // CRITICAL: Validate all 6 positions have players - never allow empty positions
            const missingPositions = validPositions.filter(pos => !cleanedRotatedLineup[pos])
            if (missingPositions.length > 0) {
              console.error('[Rotation] CRITICAL BUG: Missing players at positions:', missingPositions,
                { rotatedLineup, cleanedRotatedLineup, currentLineup, liberoSubstitution })
              // Try to recover from current lineup (pre-rotation)
              for (const pos of missingPositions) {
                if (currentLineup[pos]) {
                  cleanedRotatedLineup[pos] = currentLineup[pos]
                  console.log('[Rotation] Recovered position', pos, 'with player', currentLineup[pos], 'from pre-rotation lineup')
                }
              }
            }

            // Save the rotated lineup as a new lineup event (but don't log it - it's automatic rotation)
            // Use decimal ID based on the point's action ID (e.g., if point is 1, rotation is 1.1)
            const rotationSeq = await getNextSubSeq(pointSeq)
            const rotationStateBefore = getStateSnapshot()
            const rotationEventId = await db.events.add({
              matchId,
              setIndex: data.set.index,
              type: 'lineup',
              payload: {
                team: teamKey,
                lineup: cleanedRotatedLineup,
                liberoSubstitution: rotatedLiberoSubstitution // Include rotated libero substitution if it exists
              },
              ts: new Date().toISOString(),
              seq: rotationSeq, // Decimal ID for ordering (e.g., 1.1)
              stateBefore: rotationStateBefore
            })

            // Debug log: rotation
            debugLogger.log('ROTATION', {
              team: teamKey,
              newLineup: cleanedRotatedLineup,
              liberoSubstitution: rotatedLiberoSubstitution,
              rotationSeq
            }, getStateSnapshot())

            // Don't add to sync_queue for rotation lineups
            // But sync to referee so they see the updated lineup after rotation
            syncToReferee()
            // Also sync to Supabase so live state has the rotated lineup
            syncLiveStateToSupabase('rotation', teamKey, { lineup: cleanedRotatedLineup })
          }
        }
      }

      // After point is logged, the scoring team (teamKey) now has serve
      // So the OTHER team is receiving - check if they had a libero exit
      // Note: We use teamKey directly instead of getCurrentServe() because the event
      // might not be in data.events yet (async update), but we know teamKey has serve
      const otherTeamKey = teamKey === 'home' ? 'away' : 'home'

      // Check if the other team had a libero exit recently
      const otherTeamLiberoExits = data.events.filter(e =>
        e.type === 'libero_exit' &&
        e.payload?.team === otherTeamKey &&
        e.setIndex === data.set.index &&
        e.payload?.reason === 'rotation_to_front_row'
      ).sort((a, b) => new Date(b.ts) - new Date(a.ts))

      if (otherTeamLiberoExits.length > 0) {
        const lastLiberoExit = otherTeamLiberoExits[0]
        const liberoNumber = lastLiberoExit.payload?.liberoOut
        const liberoType = lastLiberoExit.payload?.liberoType

        // Check if libero is not currently on court
        const liberoOnCourt = getLiberoOnCourt(otherTeamKey)
        if (!liberoOnCourt && liberoNumber && liberoType) {
          // Get the other team's current lineup
          const otherTeamLineupEvents = data.events.filter(e =>
            e.type === 'lineup' &&
            e.payload?.team === otherTeamKey &&
            e.setIndex === data.set.index
          ).sort((a, b) => new Date(b.ts) - new Date(a.ts))

          if (otherTeamLineupEvents.length > 0) {
            const otherTeamLineup = otherTeamLineupEvents[0].payload?.lineup
            const playerInI = otherTeamLineup?.['I']

            if (playerInI && playerInI !== '') {
              // Get all liberos for this team
              const teamPlayers = otherTeamKey === 'home' ? data.homePlayers : data.awayPlayers
              const teamLiberos = teamPlayers?.filter(p => p.libero && p.libero !== '' && !isLiberoUnable(otherTeamKey, p.number)) || []

              // Build available liberos list
              const availableLiberos = teamLiberos.map(libero => ({
                number: libero.number,
                type: libero.libero,
                label: libero.libero === 'libero1' ? 'L1' : libero.libero === 'redesignated' ? 'LR' : 'L2'
              }))

              // Find which libero was last on court (default selection)
              const defaultLiberoIndex = availableLiberos.findIndex(l => String(l.number) === String(liberoNumber) && l.type === liberoType)

              // Ask if they want to put a libero back in at position I (if option enabled)
              // But don't show if set is ending (set end modal should show first/only)
              const is5thSetLibero = data.set.index === 5
              const pointsToWinLibero = is5thSetLibero ? 15 : 25
              // The ">= 2" check handles deuce scenarios (e.g., 25-24 doesn't end, 26-24 does)
              const willSetEnd = (homePoints >= pointsToWinLibero && homePoints - awayPoints >= 2) ||
                (awayPoints >= pointsToWinLibero && awayPoints - homePoints >= 2)

              // Check if this specific libero exit was already dismissed (don't repeat suggestion)
              const dismissedForThisExit = liberoSuggestionDismissedForExit[otherTeamKey] === lastLiberoExit.ts

              if (liberoEntrySuggestion && !willSetEnd && !dismissedForThisExit) {
                setLiberoReentryModal({
                  team: otherTeamKey,
                  position: 'I',
                  playerNumber: Number(playerInI),
                  liberoNumber: Number(liberoNumber),
                  liberoType: liberoType,
                  availableLiberos: availableLiberos,
                  selectedLiberoIndex: defaultLiberoIndex >= 0 ? defaultLiberoIndex : 0
                })
              }
            }
          }
        }
      }

      // Beach Volleyball: Court change and TTO logic
      const totalScore = homePoints + awayPoints
      const is3rdSet = data.set.index === 3

      // Court change: every 7 pts in S1/S2, every 5 pts in S3
      const courtChangeInterval = is3rdSet ? 5 : 7
      if (totalScore > 0 && totalScore % courtChangeInterval === 0) {
        // Show court switch modal
        setCourtSwitchModal({
          set: data.set,
          homePoints,
          awayPoints,
          teamThatScored: teamKey
        })
        return // Don't check for set end yet, wait for court switch confirmation
      }

      const setEnded = checkSetEnd(freshCurrentSet, homePoints, awayPoints)
      // If set didn't end, we're done. If it did, checkSetEnd will show the confirmation modal
    },
    [data?.set, data?.events, logEvent, mapSideToTeamKey, checkSetEnd, getCurrentServe, rotateLineup, matchId, syncToReferee]
  )

  const handleStartRally = useCallback(async (skipConfirmation = false) => {
    cLogger.logHandler('handleStartRally', { skipConfirmation })
    // Check for accidental rally start (if enabled and point was just awarded)
    if (checkAccidentalRallyStart && !skipConfirmation && lastPointAwardedTimeRef.current) {
      const timeSinceLastPoint = (Date.now() - lastPointAwardedTimeRef.current) / 1000
      if (timeSinceLastPoint < accidentalRallyStartDuration) {
        setAccidentalRallyConfirmModal({
          onConfirm: () => {
            setAccidentalRallyConfirmModal(null)
            handleStartRally(true) // Call with skipConfirmation = true
          }
        })
        return
      }
    }

    // If this is the first rally, show set start time confirmation
    if (isFirstRally) {
      // Check if liberos exist and haven't been entered
      const homeLiberos = data?.homePlayers?.filter(p => p.libero && p.libero !== '') || []
      const awayLiberos = data?.awayPlayers?.filter(p => p.libero && p.libero !== '') || []

      // Check if any libero has been entered in the current set for each team
      const homeLiberoEvents = data?.events?.filter(e =>
        (e.type === 'libero_entry' || e.type === 'libero_exit') &&
        e.payload?.team === 'home' &&
        e.setIndex === data?.set?.index
      ) || []

      const awayLiberoEvents = data?.events?.filter(e =>
        (e.type === 'libero_entry' || e.type === 'libero_exit') &&
        e.payload?.team === 'away' &&
        e.setIndex === data?.set?.index
      ) || []

      const teamsNeedingReminder = []
      if (homeLiberos.length > 0 && homeLiberoEvents.length === 0) {
        teamsNeedingReminder.push('home')
      }
      if (awayLiberos.length > 0 && awayLiberoEvents.length === 0) {
        teamsNeedingReminder.push('away')
      }

      if (teamsNeedingReminder.length > 0) {
        setLiberoReminder({ teams: teamsNeedingReminder })
        return
      }

      // Show set start time confirmation
      // For set 1, use scheduled time, for set 2+, use 3 minutes after previous set end
      let defaultTime = roundToMinute(new Date().toISOString())

      if (data?.set?.index === 1) {
        // Use scheduled time from match
        if (data?.match?.scheduledAt) {
          defaultTime = roundToMinute(data.match.scheduledAt)
        }
      } else {
        // Get previous set's end time
        const allSets = await db.sets.where('matchId').equals(matchId).toArray()
        const previousSet = allSets.find(s => s.index === (data.set.index - 1))
        if (previousSet?.endTime) {
          // Add 3 minutes to previous set end time
          const prevEndTime = new Date(previousSet.endTime)
          prevEndTime.setMinutes(prevEndTime.getMinutes() + 3)
          defaultTime = prevEndTime.toISOString()
        }
      }

      setSetStartTimeModal({ setIndex: data?.set?.index, defaultTime })
      return
    }

    setLiberoReminder(null)
    await logEvent('rally_start')
    // Track when rally started (for accidental point award check)
    rallyStartTimeRef.current = Date.now()

    // Clear the recently substituted players flash (rally starting clears it)
    if (recentSubFlashTimeoutRef.current) {
      clearTimeout(recentSubFlashTimeoutRef.current)
    }
    setRecentlySubstitutedPlayers([])
  }, [logEvent, isFirstRally, data?.homePlayers, data?.awayPlayers, data?.events, data?.set, data?.match, matchId, getNextSubSeq, syncToReferee, checkAccidentalRallyStart, accidentalRallyStartDuration])

  const handleReplay = useCallback(async () => {
    // During rally: just log replay event (no point to undo)
    if (rallyStatus === 'in_play') {
      await logEvent('replay')
      return
    }
    // After point: show confirmation modal to undo point
    if (rallyStatus === 'idle' && canReplayRally && data?.events) {
      // Find the last event by sequence number (highest seq)
      const allEvents = [...data.events].sort((a, b) => {
        const aSeq = a.seq || 0
        const bSeq = b.seq || 0
        if (aSeq !== 0 || bSeq !== 0) {
          return bSeq - aSeq // Descending
        }
        const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
        const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
        return bTime - aTime
      })

      const lastEvent = allEvents[0]
      let pointEvent = null

      if (lastEvent && lastEvent.type === 'point') {
        // Last event is the point itself
        pointEvent = lastEvent
      } else if (lastEvent) {
        // Last event might be a sub-event (decimal seq) following a point
        const lastSeq = lastEvent.seq || 0
        const isSubEvent = lastSeq !== Math.floor(lastSeq)
        if (isSubEvent) {
          // Find the parent point event
          const baseSeq = Math.floor(lastSeq)
          pointEvent = allEvents.find(e => Math.floor(e.seq || 0) === baseSeq && e.type === 'point')
        }
      }

      if (pointEvent) {
        // Simple description for decision change confirmation
        const teamName = pointEvent.payload?.team === 'home'
          ? (data?.homeTeam?.name || 'Home')
          : (data?.awayTeam?.name || 'Away')
        const description = `Point for ${teamName}`
        setReplayRallyConfirm({ event: pointEvent, description, selectedOption: 'swap' }) // Default to swap
      }
    }
  }, [logEvent, rallyStatus, canReplayRally, data?.events, data?.homeTeam?.name, data?.awayTeam?.name])

  // Handle Improper Request sanction
  const handleImproperRequest = useCallback((side) => {
    if (!data?.match || rallyStatus !== 'idle') return
    setSanctionConfirm({ side, type: 'improper_request' })
  }, [data?.match, rallyStatus])

  // Handle Delay Warning sanction
  const handleDelayWarning = useCallback((side) => {
    if (!data?.match || rallyStatus !== 'idle') return
    setSanctionConfirm({ side, type: 'delay_warning' })
  }, [data?.match, rallyStatus])

  // Handle Delay Penalty sanction
  const handleDelayPenalty = useCallback((side) => {
    if (!data?.match || !data?.set || rallyStatus !== 'idle') return
    setSanctionConfirm({ side, type: 'delay_penalty' })
  }, [data?.match, data?.set, rallyStatus])

  // Handle team sanction (for smartphone mode) - takes team key instead of side
  const handleTeamSanction = useCallback((teamKey, sanctionType) => {
    cLogger.logHandler('handleTeamSanction', { teamKey, sanctionType })
    if (!data?.match || rallyStatus !== 'idle') return
    // Convert team key to side
    const side = (teamKey === 'home' && leftIsHome) || (teamKey === 'away' && !leftIsHome) ? 'left' : 'right'
    setSanctionConfirm({ side, type: sanctionType })
  }, [data?.match, rallyStatus, leftIsHome])

  // Confirm sanction
  const confirmSanction = useCallback(async () => {
    if (!sanctionConfirm || !data?.match || !data?.set) return

    const { side, type } = sanctionConfirm
    const teamKey = mapSideToTeamKey(side)
    const teamKeyCapitalized = teamKey === 'home' ? 'Home' : 'Away'

    // Update match sanctions for improper request and delay warning
    // Store by team key (Home/Away) so sanctions follow the team when sides switch
    if (type === 'improper_request' || type === 'delay_warning') {
      const currentSanctions = data.match.sanctions || {}
      await db.matches.update(matchId, {
        sanctions: {
          ...currentSanctions,
          [`${type === 'improper_request' ? 'improperRequest' : 'delayWarning'}${teamKeyCapitalized}`]: true
        }
      })
    }

    // Log the sanction event
    await logEvent('sanction', {
      team: teamKey,
      type: type
    })

    // Debug log: sanction
    debugLogger.log('SANCTION', {
      team: teamKey,
      type,
      side
    }, getStateSnapshot())

    // If delay penalty, award point to the other team (but only if lineups are set)
    if (type === 'delay_penalty') {
      // Check if both lineups are set before awarding point
      const homeLineupSet = data.events?.some(e =>
        e.type === 'lineup' &&
        e.payload?.team === 'home' &&
        e.setIndex === data.set.index &&
        e.payload?.isInitial
      )
      const awayLineupSet = data.events?.some(e =>
        e.type === 'lineup' &&
        e.payload?.team === 'away' &&
        e.setIndex === data.set.index &&
        e.payload?.isInitial
      )

      setSanctionConfirm(null)

      if (homeLineupSet && awayLineupSet) {
        // Both lineups are set - award point immediately
        const otherSide = side === 'left' ? 'right' : 'left'
        await handlePoint(otherSide)
      } else {
        // Lineups not set - show message
        showAlert('Delay penalty recorded. Point will be awarded after both teams set their lineups.', 'info')
      }
    } else {
      setSanctionConfirm(null)
    }
  }, [sanctionConfirm, data?.match, data?.set, data?.events, mapSideToTeamKey, matchId, logEvent, handlePoint])

  // Confirm set start time
  const confirmSetStartTime = useCallback(async (time) => {
    if (!setStartTimeModal || !data?.set) return

    // Check if the confirmed time differs from the expected time
    // Compare only hours and minutes since the modal only shows time, not date
    const expectedDate = new Date(setStartTimeModal.defaultTime)
    const confirmedDate = new Date(time)
    const expectedMinutes = expectedDate.getUTCHours() * 60 + expectedDate.getUTCMinutes()
    const confirmedMinutes = confirmedDate.getUTCHours() * 60 + confirmedDate.getUTCMinutes()
    const timeDifferent = expectedMinutes !== confirmedMinutes

    // Update set with start time (absolute timestamp)
    await db.sets.update(data.set.id, { startTime: roundToMinute(time) })

    // Get the highest sequence number for this match
    const nextSeq1 = await getNextSeq()
    const nextSeq2 = nextSeq1 + 1
    const setStartStateBefore = getStateSnapshot()

    // Log set_start event
    const setStartEventId = await db.events.add({
      matchId,
      setIndex: data.set.index,
      type: 'set_start',
      payload: {
        setIndex: setStartTimeModal.setIndex,
        startTime: roundToMinute(time)
      },
      ts: roundToMinute(time),
      seq: nextSeq1,
      stateBefore: setStartStateBefore
    })

    // Debug log: set start
    debugLogger.log('SET_START', {
      setIndex: setStartTimeModal.setIndex,
      startTime: time,
      seq: nextSeq1
    }, setStartStateBefore)

    setSetStartTimeModal(null)

    // Trigger event backup for Safari/Firefox
    onTriggerEventBackup?.('set_start')

    // Now actually start the rally
    const rallyStartStateBefore = getStateSnapshot()
    await db.events.add({
      matchId,
      setIndex: data.set.index,
      type: 'rally_start',
      payload: {},
      ts: new Date().toISOString(),
      seq: nextSeq2,
      stateBefore: rallyStartStateBefore
    })

    // Sync to referee immediately after set start
    syncToReferee()

    // If the start time differs from expected, automatically open remarks
    if (timeDifferent) {
      setShowRemarks(true)
    }
  }, [setStartTimeModal, data?.set, matchId, onTriggerEventBackup, syncToReferee])

  // Confirm set end time
  const confirmSetEndTime = useCallback(async (time) => {
    console.log('═══════════════════════════════════════════════════════════════')
    console.log('[SET_END_DEBUG] STEP 1: confirmSetEndTime STARTED at', new Date().toISOString())
    console.log('═══════════════════════════════════════════════════════════════')

    if (!setEndTimeModal || !data?.match || !data?.set) {
      console.log('[SET_END_DEBUG] STEP 1 FAILED - missing data:', {
        hasModal: !!setEndTimeModal,
        hasMatch: !!data?.match,
        hasSet: !!data?.set
      })
      return
    }

    const { setIndex, winner, homePoints, awayPoints } = setEndTimeModal

    // Guard: Check if this set was already confirmed to prevent double-processing
    if (confirmedSetEndRef.current.has(setIndex)) {
      console.log('[SET_END] Set', setIndex, 'already confirmed - ignoring duplicate call')
      setSetEndTimeModal(null)
      return
    }

    // Mark this set as being confirmed
    confirmedSetEndRef.current.add(setIndex)

    console.log('[SET_END_DEBUG] STEP 2: Modal data:', JSON.stringify({
      setIndex,
      winner,
      homePoints,
      awayPoints,
      endTime: time,
      currentSetId: data.set.id,
      currentSetIndex: data.set.index,
      matchId: matchId,
      matchStatus: data.match.status
    }))

    // Close modal immediately to prevent multiple confirmations
    setSetEndTimeModal(null)

    // Show loading overlay
    setSetTransitionLoading({ step: 'Finishing set...' })

    // Show sync progress modal
    setSyncModalOpen(true)

    // CRITICAL: Acquire lock IMMEDIATELY to prevent ensureActiveSet from creating duplicate sets
    // This must happen BEFORE we mark the current set as finished
    setCreationInProgressRef.current = true
    console.log('[SET_END] Set creation lock acquired EARLY (before marking set finished)')

    // Cleanup function to ensure resources are released on any failure
    const cleanup = (reason) => {
      console.log('[SET_END] Cleanup triggered:', reason)
      setCreationInProgressRef.current = false
      setSetTransitionLoading(null)
      setSyncModalOpen(false)
      resetSyncState()
    }

    try {
      // Reset libero suggestion dismissed state for new set
      setLiberoSuggestionDismissedForExit({ home: null, away: null })

      // Determine team labels (A or B) based on coin toss
      const teamAKey = data.match.coinTossTeamA || 'home'
      const teamBKey = teamAKey === 'home' ? 'away' : 'home'
      const winnerLabel = winner === 'home'
        ? (teamAKey === 'home' ? 'A' : 'B')
        : (teamAKey === 'away' ? 'A' : 'B')

      // Get start time from current set
      const startTime = data.set.startTime

      // STEP 3: Log set_end event to local DB
      console.log('[SET_END_DEBUG] STEP 3: Logging set_end event...')
      await logEvent('set_end', {
        team: winner,
        teamLabel: winnerLabel,
        setIndex: setIndex,
        homePoints,
        awayPoints,
        startTime: startTime,
        endTime: roundToMinute(time)
      })
      console.log('[SET_END_DEBUG] STEP 3 DONE: set_end event logged')

      // Debug log: set end
      debugLogger.log('SET_END', {
        winner,
        winnerLabel,
        setIndex,
        homePoints,
        awayPoints,
        startTime,
        endTime: roundToMinute(time)
      }, getStateSnapshot())

      // STEP 4: Update set with end time and finished status in local DB
      // CRITICAL FIX: Find set by matchId + setIndex to avoid updating wrong set if duplicates exist
      const allSetsBeforeUpdate = await db.sets.where('matchId').equals(matchId).toArray()
      console.log('[SET_END_DEBUG] STEP 4: All sets BEFORE update:', JSON.stringify(allSetsBeforeUpdate.map(s => ({
        id: s.id,
        index: s.index,
        finished: s.finished,
        homePoints: s.homePoints,
        awayPoints: s.awayPoints
      }))))

      // Find the UNFINISHED set with this index (the one we're actually playing)
      const setToUpdate = allSetsBeforeUpdate.find(s => s.index === setIndex && !s.finished)

      // SAFE FALLBACK: Only use data.set.id if it has the correct index
      let setIdToUpdate = setToUpdate?.id
      if (!setIdToUpdate) {
        // No unfinished set with matching index found - check if data.set has correct index
        if (data.set.index === setIndex) {
          setIdToUpdate = data.set.id
          console.warn('[SET_END] Fallback to data.set.id - set may already be finished but index matches:', setIdToUpdate)
        } else {
          // Check if the set is ALREADY finished (e.g. from a previous confirmation call)
          const alreadyFinishedSet = allSetsBeforeUpdate.find(s => s.index === setIndex && s.finished)
          if (alreadyFinishedSet) {
            console.log('[SET_END] Set', setIndex, 'is already finished. Aborting confirmSetEndTime gracefully.')
            cleanup('set already finished')
            return
          }

          // CRITICAL: Cannot find correct set to update - abort to prevent data corruption
          console.error('[SET_END] CRITICAL: Cannot find set with index', setIndex, 'to update.')
          console.error('[SET_END] data.set has index', data.set.index, '- aborting to prevent wrong set update')
          console.error('[SET_END] Available sets:', allSetsBeforeUpdate.map(s => ({ id: s.id, index: s.index, finished: s.finished })))
          showAlert(t('scoreboard.errors.setNotFound'), 'error')
          cleanup('set not found')
          return
        }
      }

      console.log('[SET_END_DEBUG] STEP 4: About to update set:', JSON.stringify({
        setIdFromData: data.set.id,
        setIdToUpdate: setIdToUpdate,
        usingCorrectSet: setIdToUpdate === setToUpdate?.id,
        setIndex: setIndex,
        willSetFinished: true,
        homePoints,
        awayPoints,
        endTime: roundToMinute(time)
      }))

      if (setIdToUpdate !== data.set.id) {
        console.warn('[SET_END_DEBUG] WARNING: data.set.id differs from the unfinished set! Using correct set id:', setIdToUpdate)
      }

      setSetTransitionLoading({ step: 'Saving set data...' })
      const updateResult = await db.sets.update(setIdToUpdate, { finished: true, homePoints, awayPoints, endTime: roundToMinute(time) })
      console.log('[SET_END_DEBUG] STEP 4: Update result (rows affected):', updateResult)

      // STEP 5: Verify the update actually worked
      const verifySet = await db.sets.get(setIdToUpdate)
      console.log('[SET_END_DEBUG] STEP 5: Verification - set after update:', JSON.stringify({
        id: verifySet?.id,
        index: verifySet?.index,
        finished: verifySet?.finished,
        homePoints: verifySet?.homePoints,
        awayPoints: verifySet?.awayPoints
      }))

      if (!verifySet?.finished) {
        console.error('[SET_END_DEBUG] STEP 5 FAILED: Set was NOT marked as finished! This is a bug.')
      } else {
        console.log('[SET_END_DEBUG] STEP 5 SUCCESS: Set is marked as finished=true')
      }

      // Also verify all sets after update to catch any issues
      const allSetsAfterUpdate = await db.sets.where('matchId').equals(matchId).toArray()
      console.log('[SET_END_DEBUG] STEP 5: All sets AFTER update:', JSON.stringify(allSetsAfterUpdate.map(s => ({
        id: s.id,
        index: s.index,
        finished: s.finished
      }))))

      // STEP 6: Get all sets and calculate sets won by each team
      const sets = await db.sets.where({ matchId }).toArray()
      const finishedSets = sets.filter(s => s.finished)
      const homeSetsWon = finishedSets.filter(s => s.homePoints > s.awayPoints).length
      const awaySetsWon = finishedSets.filter(s => s.awayPoints > s.homePoints).length

      console.log('[SET_END_DEBUG] STEP 6: Sets Summary:', JSON.stringify({
        totalSets: sets.length,
        finishedSetsCount: finishedSets.length,
        allSets: sets.map(s => ({ index: s.index, home: s.homePoints, away: s.awayPoints, finished: s.finished })),
        homeSetsWon,
        awaySetsWon
      }))

      // STEP 7: Check if either team has won 3 sets (match win)
      const isMatchEnd = homeSetsWon >= 3 || awaySetsWon >= 3
      console.log('[SET_END_DEBUG] STEP 7: Match End Check:', JSON.stringify({ isMatchEnd, homeSetsWon, awaySetsWon }))

      // Get match record for both branches (test check, cloud backup)
      const matchRecord = await db.matches.get(matchId)
      console.log('[SET_END_DEBUG] STEP 7: Match info:', JSON.stringify({
        matchId,
        isTest: matchRecord?.test,
        seed_key: matchRecord?.seed_key,
        currentStatus: matchRecord?.status
      }))

      // Track sync result for conditional backup download
      let syncResult = null

      // STEP 8: IMMEDIATE SYNC TO SUPABASE (if not a test match)
      // Sync happens FIRST before any UI operations to ensure data is saved
      if (matchRecord?.test !== true && matchRecord?.seed_key) {
        setSetTransitionLoading({ step: 'Syncing to cloud...' })
        console.log('[SET_END_DEBUG] STEP 8: Starting IMMEDIATE sync to Supabase')

        // Prepare set update payload
        const setPayload = {
          external_id: String(setIdToUpdate),
          home_points: homePoints,
          away_points: awayPoints,
          finished: true,
          end_time: time
        }

        // Prepare match payload if match end
        let matchPayload = null
        if (isMatchEnd) {
          const setResults = finishedSets
            .sort((a, b) => a.index - b.index)
            .map(s => ({ set: s.index, home: s.homePoints, away: s.awayPoints }))
          const matchWinner = homeSetsWon > awaySetsWon ? 'home' : 'away'
          const finalScore = `${homeSetsWon}-${awaySetsWon}`

          matchPayload = {
            id: matchRecord.seed_key,
            status: 'ended',
            set_results: setResults,
            winner: matchWinner,
            final_score: finalScore,
            sanctions: matchRecord?.sanctions || null
          }
        }

        // Execute sequential sync (shows progress modal)
        syncResult = await syncSetEnd({
          lastPointPayload: null, // Last point already synced by logEvent
          setPayload,
          matchPayload
        })

        console.log('[SET_END_DEBUG] STEP 8 DONE: Sync completed:', syncResult)

        // Handle sync completion based on result
        // - Success: brief 1s delay to show success, then proceed
        // - Warning (offline): 1.5s delay, then proceed
        // - Error: wait for user to click button in modal (with 5s timeout fallback)
        if (!syncResult.success) {
          // Error - wait for modal callback or timeout
          const SYNC_MODAL_TIMEOUT = 5000
          let syncTimeoutId = null

          await Promise.race([
            new Promise((resolve) => {
              syncProceedCallbackRef.current = () => {
                if (syncTimeoutId) clearTimeout(syncTimeoutId)
                setSyncModalOpen(false)
                resetSyncState()
                resolve()
              }
            }),
            new Promise((resolve) => {
              syncTimeoutId = setTimeout(() => {
                console.warn('[SET_END] Sync modal timeout after 5s - proceeding anyway')
                syncProceedCallbackRef.current = null
                setSyncModalOpen(false)
                resetSyncState()
                resolve()
              }, SYNC_MODAL_TIMEOUT)
            })
          ])
        } else {
          // Success or warning - show completion briefly then proceed
          const delay = syncResult.hasWarning ? 1500 : 1000
          console.log('[SET_END] Sync succeeded - showing result for', delay, 'ms')
          await new Promise(resolve => setTimeout(resolve, delay))
          setSyncModalOpen(false)
          resetSyncState()
        }
      } else {
        console.log('[SET_END_DEBUG] STEP 8 SKIPPED: Test match or no seed_key')
        // For test matches, close sync modal immediately
        setSyncModalOpen(false)
        resetSyncState()
      }

      console.log('[SET_END_DEBUG] STEP 9: Match record status BEFORE any changes:', matchRecord?.status)

      // STEP 9+: Branch based on match end or set end
      if (isMatchEnd) {
        console.log('[SET_END_DEBUG] STEP 10: MATCH END BRANCH - isMatchEnd=true')
        // IMPORTANT: When match ends, preserve ALL data in database:
        // - All sets remain in db.sets
        // - All events remain in db.events
        // - All players remain in db.players
        // - All teams remain in db.teams
        // - Set status to 'ended' - MatchEnd component will set to 'approved' after approval
        // Status flow: live -> ended -> approved

        // Update local match status to 'ended'
        console.log('[SET_END_DEBUG] STEP 10: Setting match status to "ended"...')
        await db.matches.update(matchId, { status: 'ended' })

        // Verify the status was updated
        const matchAfterStatusUpdate = await db.matches.get(matchId)
        console.log('[SET_END_DEBUG] STEP 10: Match status after update:', matchAfterStatusUpdate?.status)

        // NOTE: Match update sync is now done in STEP 8 (sequential sync) above

        // Notify server to delete match from matchDataStore (since it's now final)
        const currentWs = wsRef.current
        if (currentWs && currentWs.readyState === WebSocket.OPEN) {
          try {
            currentWs.send(JSON.stringify({
              type: 'delete-match',
              matchId: String(matchId)
            }))
          } catch (err) {
            // Silently ignore WebSocket errors
          }
        }

        // Trigger event backup for Safari/Firefox (match end)
        onTriggerEventBackup?.('match_end')

        // Cloud backup at match end (non-blocking)
        if (matchRecord?.test !== true) {
          const gameNum = matchRecord?.gameNumber || matchRecord?.game_n || null
          exportMatchData(matchId).then(backupData => {
            uploadBackupToCloud(matchId, backupData)
            uploadLogsToCloud(matchId, gameNum)
          }).catch(() => { })
        }

        // Only call onFinishSet for match end, not between sets
        // (Scoreboard now handles set creation internally)
        console.log('[SET_END_DEBUG] STEP 11: Calling onFinishSet callback with set:', JSON.stringify({
          setId: data.set.id,
          setIndex: data.set.index
        }))
        if (onFinishSet) onFinishSet(data.set)
        console.log('[SET_END_DEBUG] STEP 11: onFinishSet callback completed')

        // Release lock for match end path (no new set to create)
        setCreationInProgressRef.current = false
        setSetTransitionLoading(null) // Clear loading overlay
        console.log('[SET_END] Lock released (match end - no new set needed)')

        console.log('═══════════════════════════════════════════════════════════════')
        console.log('[SET_END_DEBUG] MATCH END FLOW COMPLETE')
        console.log('═══════════════════════════════════════════════════════════════')
        return // Exit early for match end - don't fall through to new set creation
      } else {
        console.log('[SET_END_DEBUG] STEP 9: SET END BRANCH (not match end) - continuing to next set')
        // Trigger event backup for Safari/Firefox (set end)
        onTriggerEventBackup?.('set_end')

        // Cloud backup at set end (non-blocking)
        if (matchRecord?.test !== true) {
          setSetTransitionLoading({ step: 'Uploading backup...' })
          const gameNum = matchRecord?.gameNumber || matchRecord?.game_n || null
          exportMatchData(matchId).then(backupData => {
            uploadBackupToCloud(matchId, backupData)
            uploadLogsToCloud(matchId, gameNum)
          }).catch(() => { })
        }

        // Auto-download game data at set end if enabled AND sync failed/offline
        // If sync succeeded and we're online, data is safe in cloud - no need to download
        const syncSucceeded = syncResult?.success && !syncResult?.hasWarning
        const isOffline = !navigator.onLine

        if (autoDownloadAtSetEnd && (!syncSucceeded || isOffline)) {
          console.log('[SET_END] Downloading backup - sync failed/skipped or offline:', {
            syncSucceeded,
            isOffline,
            syncResult
          })
          setSetTransitionLoading({ step: 'Downloading backup...' })
          try {
            const allMatches = await db.matches.toArray()
            const allTeams = await db.teams.toArray()
            const allPlayers = await db.players.toArray()
            const allSets = await db.sets.toArray()
            const allEvents = await db.events.toArray()
            const allReferees = await db.referees.toArray()
            const allScorers = await db.scorers.toArray()

            const exportData = {
              exportDate: new Date().toISOString(),
              exportReason: `set_${setIndex}_end`,
              matchId: matchId,
              matches: allMatches,
              teams: allTeams,
              players: allPlayers,
              sets: allSets,
              events: allEvents,
              referees: allReferees,
              scorers: allScorers
            }

            const jsonString = JSON.stringify(exportData, null, 2)
            const blob = new Blob([jsonString], { type: 'application/json' })
            const url = URL.createObjectURL(blob)
            const link = document.createElement('a')
            link.href = url
            link.download = `backup_set${setIndex}_${matchId}_${new Date().toISOString().replace(/[:.]/g, '-')}.json`
            document.body.appendChild(link)
            link.click()
            document.body.removeChild(link)
            URL.revokeObjectURL(url)
          } catch (error) {
            console.error('Auto-download at set end failed:', error)
          }
        }

        // Start countdown immediately when set ends (not match end)
        // Reset dismissed flag and start countdown
        console.log('[SET_END] Starting between-sets countdown:', { duration: setIntervalDuration })
        countdownDismissedRef.current = false
        setBetweenSetsCountdown({ countdown: setIntervalDuration, started: true })

        // Send set_end action to referee to show countdown
        console.log('[SET_END] Sending set_end action to Referee:', {
          setIndex,
          winner: winner,
          homePoints: homePoints,
          awayPoints: awayPoints,
          countdown: setIntervalDuration,
          homeSetsWon,
          awaySetsWon
        })
        sendActionToReferee('set_end', {
          setIndex,
          winner: winner,
          homePoints: homePoints,
          awayPoints: awayPoints,
          countdown: setIntervalDuration,
          startTimestamp: Date.now(),
          homeSetsWon,
          awaySetsWon
        })

        // Lock was already acquired early in confirmSetEndTime
        // Verify it's still held (should be true)
        console.log('[SET_END] Set creation lock still held:', setCreationInProgressRef.current)

        // Upload scoresheet to cloud (async, non-blocking) - Set Finished state
        const matchForScoresheet = await db.matches.get(matchId)
        const allSetsForScoresheet = await db.sets.where('matchId').equals(matchId).sortBy('index')
        const allEventsForScoresheet = await db.events.where('matchId').equals(matchId).sortBy('seq')
        const homePlayersForScoresheet = await db.players.where('teamId').equals(matchForScoresheet?.homeTeamId || '').toArray()
        const awayPlayersForScoresheet = await db.players.where('teamId').equals(matchForScoresheet?.awayTeamId || '').toArray()
        const homeTeamForScoresheet = matchForScoresheet?.homeTeamId ? await db.teams.get(matchForScoresheet.homeTeamId) : null
        const awayTeamForScoresheet = matchForScoresheet?.awayTeamId ? await db.teams.get(matchForScoresheet.awayTeamId) : null

        uploadScoresheetAsync({
          match: matchForScoresheet,
          homeTeam: homeTeamForScoresheet,
          awayTeam: awayTeamForScoresheet,
          homePlayers: homePlayersForScoresheet,
          awayPlayers: awayPlayersForScoresheet,
          sets: allSetsForScoresheet,
          events: allEventsForScoresheet
        })

        console.log('═══════════════════════════════════════════════════════════════')
        console.log('[SET_END] confirmSetEndTime COMPLETED - Creating next set immediately')
        console.log('═══════════════════════════════════════════════════════════════')

        // Create next set immediately (lock is still held from earlier)
        // This prevents ensureActiveSet from racing with manual set creation
        try {
          const newSetIndex = setIndex + 1
          console.log('[SET_END] Creating new set:', { previousSetIndex: setIndex, newSetIndex })

          // Special handling for Set 5 - need to set up coin toss defaults
          if (newSetIndex === 5) {
            console.log('[SET_END] Set 4 ended - preparing Set 5 setup')

            // Get team A/B assignments for set 5
            const set4TeamAKey = data?.match?.coinTossTeamA || 'home'

            // Determine current positions at end of set 4 (set 2, 3, 4 have teams switched)
            const set4LeftIsHome = set4TeamAKey !== 'home'
            const set4LeftTeamKey = set4LeftIsHome ? 'home' : 'away'
            const set4LeftTeamLabel = set4LeftTeamKey === set4TeamAKey ? 'A' : 'B'

            // Get current serve at end of set 4
            const currentServe = getCurrentServe()
            const set4ServingTeamLabel = currentServe === set4TeamAKey ? 'A' : 'B'

            // Use existing values if set, otherwise use current positions
            const selectedLeftTeam = data?.match?.set5LeftTeam || set4LeftTeamLabel
            const selectedFirstServe = data?.match?.set5FirstServe || set4ServingTeamLabel

            // Set default values for inline setup UI
            setSet5SelectedLeftTeam(selectedLeftTeam)
            setSet5SelectedFirstServe(selectedFirstServe)
            setSet5SetupConfirmed(false) // Mark as not confirmed - inline UI will show

            // Update match with default Set 5 configuration
            await db.matches.update(matchId, {
              set5LeftTeam: selectedLeftTeam,
              set5FirstServe: selectedFirstServe,
              set5CourtSwitched: false
            })
          }

          // Check if a set with this index already exists
          const allSetsForMatch = await db.sets.where('matchId').equals(matchId).toArray()
          const existingSet = allSetsForMatch.find(s => s.index === newSetIndex)

          let newSetId
          if (existingSet) {
            console.log('[SET_END] Resetting existing set:', existingSet.id)
            await db.sets.update(existingSet.id, { finished: false, homePoints: 0, awayPoints: 0 })
            newSetId = existingSet.id
          } else {
            console.log('[SET_END] Adding new set to database')
            newSetId = await db.sets.add({
              matchId,
              index: newSetIndex,
              homePoints: 0,
              awayPoints: 0,
              finished: false
            })
            console.log('[SET_END] New set added:', { newSetId, newSetIndex })
          }

          // Reset set5CourtSwitched flag (for non-set-5 transitions)
          if (newSetIndex !== 5) {
            await db.matches.update(matchId, { set5CourtSwitched: false })
          }

          // Sync new set to cloud (if not test match)
          const matchRecordForNewSet = await db.matches.get(matchId)
          const isTest = matchRecordForNewSet?.test || false
          if (!isTest && !existingSet) {
            await db.sync_queue.add({
              resource: 'set',
              action: 'insert',
              payload: {
                external_id: String(newSetId),
                match_id: matchRecordForNewSet?.seed_key || String(matchId),
                index: newSetIndex,
                home_points: 0,
                away_points: 0,
                finished: false,
                test: isTest,
                start_time: new Date().toISOString()
              },
              ts: new Date().toISOString(),
              status: 'queued'
            })
          }

          console.log('[SET_END] Next set created successfully:', { newSetId, newSetIndex })
        } finally {
          // Release lock and clear loading overlay
          setCreationInProgressRef.current = false
          setSetTransitionLoading(null)
          console.log('[SET_END] Lock released, loading cleared')
        }
      }
    } catch (error) {
      // COMPREHENSIVE ERROR HANDLER - ensures cleanup on ANY failure
      console.error('[SET_END] CRITICAL ERROR in confirmSetEndTime:', error)
      console.error('[SET_END] Error stack:', error.stack)

      // Show user-friendly error message
      showAlert(t('scoreboard.errors.setEndFailed', 'Set end failed. Data saved locally.'), 'error')

      // Ensure cleanup happens
      cleanup('uncaught exception: ' + error.message)

      // Don't re-throw - the match can continue from local data
    }
  }, [setEndTimeModal, data?.match, data?.set, matchId, logEvent, onFinishSet, getCurrentServe, teamAKey, onTriggerEventBackup, syncSetEnd, resetSyncState, setIntervalDuration, showAlert, t])

  // Confirm set 5 side and service choices (works with both modal and inline UI)
  const confirmSet5SideService = useCallback(async (leftTeam, firstServe, inlineMode = false) => {
    // For inline mode, we don't need the modal - just verify we have match data and it's set 5
    if (!inlineMode && !set5SideServiceModal) return
    if (!data?.match) return

    const setIndex = inlineMode ? 5 : set5SideServiceModal.setIndex
    const teamAKey = data.match.coinTossTeamA || 'home'
    const teamBKey = data.match.coinTossTeamB || 'away'

    // Determine which team (home/away) is on the left
    const leftTeamKey = leftTeam === 'A' ? teamAKey : teamBKey

    // Determine which team (home/away) serves first
    const firstServeTeamKey = firstServe === 'A' ? teamAKey : teamBKey

    // For inline mode, database is already updated on button press, so just log the event
    // For modal mode, update the database now
    if (!inlineMode) {
      // Update match with set 5 configuration
      await db.matches.update(matchId, {
        set5LeftTeam: leftTeam,
        set5FirstServe: firstServe,
        set5CourtSwitched: false
      })

      // Create set 5 (check if already exists first)
      const existingSet5 = await db.sets.where({ matchId, index: setIndex }).first()
      let newSetId
      if (existingSet5) {
        await db.sets.update(existingSet5.id, { finished: false, homePoints: 0, awayPoints: 0 })
        newSetId = existingSet5.id
      } else {
        newSetId = await db.sets.add({
          matchId,
          index: setIndex,
          homePoints: 0,
          awayPoints: 0,
          finished: false
        })
      }

      // Get match to check if it's a test match
      const match = await db.matches.get(matchId)
      const isTest = match?.test || false

      // Only add to sync queue if set was newly created and it's an official match
      if (!existingSet5 && !isTest) {
        await db.sync_queue.add({
          resource: 'set',
          action: 'insert',
          payload: {
            external_id: String(newSetId),
            match_id: match?.seed_key || String(matchId),
            index: setIndex,
            home_points: 0,
            away_points: 0,
            finished: false,
            test: isTest,
            start_time: new Date().toISOString()
          },
          ts: new Date().toISOString(),
          status: 'queued'
        })
      }
    }

    // Log the set 5 coin toss event so it can be undone
    const nextSeq = await getNextSeq()
    const set5CoinTossStateBefore = getStateSnapshot()
    await db.events.add({
      matchId,
      setIndex: setIndex,
      type: 'set5_coin_toss',
      payload: {
        leftTeam,
        firstServe,
        leftTeamKey,
        firstServeTeamKey
      },
      ts: new Date().toISOString(),
      seq: nextSeq,
      stateBefore: set5CoinTossStateBefore
    })

    // Close modal or confirm inline setup
    if (inlineMode) {
      setSet5SetupConfirmed(true)
    } else {
      setSet5SideServiceModal(null)
    }
  }, [set5SideServiceModal, data?.match, matchId, getNextSeq, getStateSnapshot])

  // Get action description for an event
  const getActionDescription = useCallback((event) => {
    if (!event || !data) return 'Unknown action'

    const teamName = event.payload?.team === 'home'
      ? (data.homeTeam?.name || 'Home')
      : event.payload?.team === 'away'
        ? (data.awayTeam?.name || 'Away')
        : null

    // Determine team labels (A or B)
    const teamALabel = data?.match?.coinTossTeamA === 'home' ? 'A' : 'B'
    const teamBLabel = data?.match?.coinTossTeamB === 'home' ? 'A' : 'B'
    const homeLabel = data?.match?.coinTossTeamA === 'home' ? 'A' : (data?.match?.coinTossTeamB === 'home' ? 'B' : 'A')
    const awayLabel = data?.match?.coinTossTeamA === 'away' ? 'A' : (data?.match?.coinTossTeamB === 'away' ? 'B' : 'B')

    // Calculate score at time of event
    const setIdx = event.setIndex || 1
    const setEvents = data.events?.filter(e => (e.setIndex || 1) === setIdx) || []
    const eventIndex = setEvents.findIndex(e => e.id === event.id)

    let homeScore = 0
    let awayScore = 0
    for (let i = 0; i <= eventIndex; i++) {
      const e = setEvents[i]
      if (e.type === 'point') {
        if (e.payload?.team === 'home') {
          homeScore++
        } else if (e.payload?.team === 'away') {
          awayScore++
        }
      }
    }

    let eventDescription = ''
    if (event.type === 'coin_toss') {
      const teamAName = event.payload?.teamA === 'home'
        ? (data?.homeTeam?.shortName || data?.homeTeam?.name || 'Home')
        : (data?.awayTeam?.shortName || data?.awayTeam?.name || 'Away')
      const teamBName = event.payload?.teamB === 'home'
        ? (data?.homeTeam?.shortName || data?.homeTeam?.name || 'Home')
        : (data?.awayTeam?.shortName || data?.awayTeam?.name || 'Away')
      // Determine if first serve is Team A or Team B
      const firstServeLabel = event.payload?.firstServe === event.payload?.teamA ? 'A' : 'B'
      eventDescription = `Coin toss - A: ${teamAName}, B: ${teamBName}, First serve: ${firstServeLabel}`
    } else if (event.type === 'point') {
      eventDescription = `Point — ${teamName} (${homeLabel} ${homeScore}:${awayScore} ${awayLabel})`
    } else if (event.type === 'timeout') {
      eventDescription = `Timeout — ${teamName}`
    } else if (event.type === 'substitution') {
      const playerOut = event.payload?.playerOut || '?'
      const playerIn = event.payload?.playerIn || '?'
      const isExceptional = event.payload?.isExceptional === true
      const substitutionType = isExceptional ? 'Exceptional substitution' : 'Substitution'
      eventDescription = `${substitutionType} — ${teamName} (OUT: ${playerOut} IN: ${playerIn}) (${homeLabel} ${homeScore}:${awayScore} ${awayLabel})`
    } else if (event.type === 'set_start') {
      // Format the relative time as MM:SS
      const relativeTime = typeof event.ts === 'number' ? event.ts : 0
      const totalSeconds = Math.floor(relativeTime / 1000)
      const minutes = Math.floor(totalSeconds / 60)
      const seconds = totalSeconds % 60
      const minutesStr = String(minutes).padStart(2, '0')
      const secondsStr = String(seconds).padStart(2, '0')
      eventDescription = `Set start — ${minutesStr}:${secondsStr}`
    } else if (event.type === 'rally_start') {
      eventDescription = 'Rally started'
    } else if (event.type === 'replay') {
      // Show detailed replay info with scores
      const { oldHomePoints, oldAwayPoints, newHomePoints, newAwayPoints } = event.payload || {}
      if (oldHomePoints !== undefined && newHomePoints !== undefined) {
        // Get team labels (A/B) based on coin toss
        const teamAKey = data?.match?.coinTossTeamA || 'home'
        const oldLeftScore = teamAKey === 'home' ? oldHomePoints : oldAwayPoints
        const oldRightScore = teamAKey === 'home' ? oldAwayPoints : oldHomePoints
        const newLeftScore = teamAKey === 'home' ? newHomePoints : newAwayPoints
        const newRightScore = teamAKey === 'home' ? newAwayPoints : newHomePoints
        eventDescription = `${oldLeftScore}:${oldRightScore} Rally Replayed, new score ${newLeftScore}:${newRightScore}`
      } else {
        eventDescription = 'Rally replayed'
      }
    } else if (event.type === 'decision_change') {
      const fromTeam = event.payload?.fromTeam === 'home' ? (data?.homeTeam?.name || 'Home') : (data?.awayTeam?.name || 'Away')
      const toTeam = event.payload?.toTeam === 'home' ? (data?.homeTeam?.name || 'Home') : (data?.awayTeam?.name || 'Away')
      eventDescription = `Decision change — Point swapped from ${fromTeam} to ${toTeam}`
    } else if (event.type === 'lineup') {
      // Only show initial lineups, not rotation lineups or libero substitution lineups
      const isInitial = event.payload?.isInitial === true
      const hasSubstitution = event.payload?.fromSubstitution === true
      const hasLiberoSub = event.payload?.liberoSubstitution !== null && event.payload?.liberoSubstitution !== undefined

      // Skip rotation lineups (they're part of the point)
      if (!isInitial && !hasSubstitution && !hasLiberoSub) {
        return null
      }

      // Only show initial lineups as "Line-up setup"
      if (isInitial) {
        eventDescription = `${t('scoreboard.lineupSetup', 'Line-up setup')} — ${teamName}`
      } else if (hasLiberoSub) {
        // Show libero-related lineup changes with the new lineup
        const lineup = event.payload?.lineup || {}
        const positions = ['I', 'II', 'III', 'IV', 'V', 'VI']
        const lineupStr = positions.map(pos => lineup[pos] || '?').join('-')
        eventDescription = `Lineup changed — ${teamName} (${lineupStr})`
      } else {
        return null // Skip rotation lineups (they're part of the point)
      }
    } else if (event.type === 'libero_entry') {
      const liberoNumber = event.payload?.liberoIn || '?'
      const playerOut = event.payload?.playerOut || '?'
      const liberoType = event.payload?.liberoType === 'libero1' ? 'L1' : event.payload?.liberoType === 'redesignated' ? 'LR' : 'L2'
      eventDescription = `Libero entry — ${teamName} (${liberoType} ${liberoNumber} in for ${playerOut})`
    } else if (event.type === 'libero_exit') {
      const liberoNumber = event.payload?.liberoOut || '?'
      const playerIn = event.payload?.playerIn || '?'
      const liberoType = event.payload?.liberoType === 'libero1' ? 'L1' : event.payload?.liberoType === 'redesignated' ? 'LR' : 'L2'
      eventDescription = `Libero exit — ${teamName} (${liberoType} ${liberoNumber} out, ${playerIn} in)`
    } else if (event.type === 'libero_exchange') {
      const liberoOut = event.payload?.liberoOut || '?'
      const liberoIn = event.payload?.liberoIn || '?'
      const liberoOutType = event.payload?.liberoOutType === 'libero1' ? 'L1' : event.payload?.liberoOutType === 'redesignated' ? 'LR' : 'L2'
      const liberoInType = event.payload?.liberoInType === 'libero1' ? 'L1' : event.payload?.liberoInType === 'redesignated' ? 'LR' : 'L2'
      eventDescription = `Libero exchange — ${teamName} (${liberoOutType} ${liberoOut} ↔ ${liberoInType} ${liberoIn})`
    } else if (event.type === 'libero_unable') {
      const liberoNumber = event.payload?.liberoNumber || '?'
      const liberoType = event.payload?.liberoType === 'libero1' ? 'L1' : event.payload?.liberoType === 'redesignated' ? 'LR' : 'L2'
      const reason = event.payload?.reason || 'declared'
      if (reason === 'declared') {
        eventDescription = `Libero declared unable — ${teamName} (${liberoType} ${liberoNumber})`
      } else if (reason === 'injury') {
        eventDescription = `Libero became unable — ${teamName} (${liberoType} ${liberoNumber} - injury)`
      } else if (reason === 'expulsion') {
        eventDescription = `Libero became unable — ${teamName} (${liberoType} ${liberoNumber} - expelled)`
      } else if (reason === 'disqualification') {
        eventDescription = `Libero became unable — ${teamName} (${liberoType} ${liberoNumber} - disqualified)`
      } else {
        eventDescription = `Libero became unable — ${teamName} (${liberoType} ${liberoNumber})`
      }
    } else if (event.type === 'libero_redesignation') {
      const unableLiberoNumber = event.payload?.unableLiberoNumber || '?'
      const newLiberoNumber = event.payload?.newLiberoNumber || '?'
      const unableType = event.payload?.unableLiberoType === 'libero1' ? 'L1' : event.payload?.unableLiberoType === 'libero2' ? 'L2' : 'L'
      eventDescription = `Libero redesignation — ${teamName} (${unableType} ${unableLiberoNumber} → R ${newLiberoNumber})`
    } else if (event.type === 'set_end') {
      const winnerLabel = event.payload?.teamLabel || '?'
      const setIndex = event.payload?.setIndex || event.setIndex || '?'
      const startTime = event.payload?.startTime
      const endTime = event.payload?.endTime

      let timeInfo = ''
      if (startTime && endTime) {
        const start = new Date(startTime)
        const end = new Date(endTime)
        const durationMs = end - start
        const durationMin = Math.floor(durationMs / 60000)
        const durationSec = Math.floor((durationMs % 60000) / 1000)
        const startTimeStr = `${String(start.getUTCHours()).padStart(2, '0')}:${String(start.getUTCMinutes()).padStart(2, '0')}`
        const endTimeStr = `${String(end.getUTCHours()).padStart(2, '0')}:${String(end.getUTCMinutes()).padStart(2, '0')}`
        timeInfo = ` (${startTimeStr} - ${endTimeStr}, ${durationMin} min)`
      }

      eventDescription = `Team ${winnerLabel} won Set ${setIndex}${timeInfo}`
    } else if (event.type === 'set5_coin_toss') {
      const leftTeam = event.payload?.leftTeam || '?'
      const firstServe = event.payload?.firstServe || '?'
      eventDescription = `Set 5 coin toss — Left: Team ${leftTeam}, First serve: Team ${firstServe}`
    } else if (event.type === 'sanction') {
      const sanctionType = event.payload?.type || 'unknown'
      const sanctionLabel = sanctionType === 'improper_request' ? 'Improper Request' :
        sanctionType === 'delay_warning' ? 'Delay Warning' :
          sanctionType === 'delay_penalty' ? 'Delay Penalty' :
            sanctionType === 'warning' ? 'Warning' :
              sanctionType === 'penalty' ? 'Penalty' :
                sanctionType === 'expulsion' ? 'Expulsion' :
                  sanctionType === 'disqualification' ? 'Disqualification' :
                    sanctionType

      // Add player/official info if available
      let target = ''
      if (event.payload?.playerNumber) {
        target = ` ${event.payload.playerNumber}`
      } else if (event.payload?.role) {
        const roleAbbr = event.payload.role === 'Coach' ? 'C' :
          event.payload.role === 'Assistant Coach 1' ? 'AC1' :
            event.payload.role === 'Assistant Coach 2' ? 'AC2' :
              event.payload.role === 'Physiotherapist' ? 'P' :
                event.payload.role === 'Medic' ? 'M' : event.payload.role
        target = ` ${roleAbbr}`
      } else {
        target = ' Team'
      }

      eventDescription = `Sanction — ${teamName}${target} (${sanctionLabel}) (${homeLabel} ${homeScore}:${awayScore} ${awayLabel})`
    } else if (event.type === 'remark') {
      const remarkText = event.payload?.text || ''
      // Show first line or first 50 characters
      const preview = remarkText.split('\n')[0].substring(0, 50)
      eventDescription = `Remark added — ${preview}${remarkText.length > 50 ? '...' : ''}`
    } else if (event.type === 'court_captain_designation') {
      const playerNumber = event.payload?.playerNumber || '?'
      eventDescription = `${t('scoreboard.courtCaptainDesignation', 'Court captain designation')} — ${teamName} (#${playerNumber})`
    } else {
      eventDescription = event.type
      if (teamName) {
        eventDescription += ` — ${teamName}`
      }
    }

    return eventDescription
  }, [data])

  // Show undo confirmation
  const showUndoConfirm = useCallback(() => {
    if (!data?.events || data.events.length === 0 || !data?.set) return

    // IMPORTANT: Only consider events from the CURRENT SET
    // Undo should NEVER affect other sets - use "Reopen set" in manual changes for that
    const currentSetIndex = data.set.index
    const currentSetEvents = data.events.filter(e => e.setIndex === currentSetIndex)

    // Debug: log all events for this set
    console.log('[UNDO] Current set events:', currentSetEvents.map(e => ({
      id: e.id,
      seq: e.seq,
      type: e.type,
      isInitial: e.payload?.isInitial,
      fromSubstitution: e.payload?.fromSubstitution,
      hasLiberoSub: !!e.payload?.liberoSubstitution
    })))

    if (currentSetEvents.length === 0) {
      console.log('[UNDO] No events in current set')
      return
    }

    // Find the last event by sequence number (highest seq)
    const sortedEvents = [...currentSetEvents].sort((a, b) => {
      const aSeq = a.seq || 0
      const bSeq = b.seq || 0
      if (aSeq !== 0 || bSeq !== 0) {
        return bSeq - aSeq // Descending
      }
      // Fallback to timestamp
      const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
      const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
      return bTime - aTime
    })

    console.log('[UNDO] Sorted events (highest seq first):', sortedEvents.slice(0, 5).map(e => ({
      seq: e.seq,
      type: e.type
    })))

    // Find the most recent event (highest sequence)
    // IMPORTANT: Undo should ALWAYS select the event with the highest sequence number
    // Events with decimal sequences (like 7.1) are sub-events that should be undone with their parent

    // Helper to check if an event is a sub-event (decimal sequence like 7.1, 8.1)
    const isSubEvent = (event) => {
      const seq = event.seq || 0
      return seq !== Math.floor(seq) // Has decimal component
    }

    // Helper to check if an event is a rotation lineup (not initial, not from substitution, is a sub-event)
    const isRotationLineup = (event) => {
      if (event.type !== 'lineup') return false
      if (event.payload?.isInitial) return false
      if (event.payload?.fromSubstitution) return false
      // Rotation lineups are sub-events (decimal sequence like 7.1)
      return isSubEvent(event)
    }

    // Find the first undoable event in chronological order (highest sequence)
    let lastUndoableEvent = null
    for (const event of sortedEvents) {
      console.log('[UNDO] Checking event:', {
        seq: event.seq,
        type: event.type,
        isSubEvent: isSubEvent(event),
        isRotationLineup: isRotationLineup(event)
      })

      // Skip sub-events (they'll be undone with their parent)
      if (isSubEvent(event)) {
        // If it's a rotation lineup, find the parent point to undo
        if (isRotationLineup(event)) {
          const baseSeq = Math.floor(event.seq || 0)
          const parentPoint = sortedEvents.find(e => e.type === 'point' && Math.floor(e.seq || 0) === baseSeq)
          if (parentPoint) {
            console.log('[UNDO] Found parent point for rotation lineup:', parentPoint.seq)
            lastUndoableEvent = parentPoint
            break
          }
        }
        console.log('[UNDO] Skipping sub-event')
        continue // Skip other sub-events
      }

      // Skip coin_toss events - they cannot be undone (would break match flow)
      if (event.type === 'coin_toss') {
        console.log('[UNDO] Skipping coin_toss event - cannot be undone')
        continue
      }

      // This is a main event (integer sequence) - it's undoable
      console.log('[UNDO] Selected main event:', event.seq, event.type)
      lastUndoableEvent = event
      break
    }

    if (!lastUndoableEvent) {
      console.log('[UNDO] No undoable event found!')
      debugLogger.log('UNDO_NO_EVENT_FOUND', {
        eventsChecked: sortedEvents.length,
        allEventsInSet: currentSetEvents.map(e => ({ id: e.id, seq: e.seq, type: e.type }))
      })
      return
    }

    const description = getActionDescription(lastUndoableEvent)
    // If we can't get a description, still allow undo but show the event type
    const displayDescription = description && description !== 'Unknown action'
      ? description
      : `${lastUndoableEvent.type} (seq: ${lastUndoableEvent.seq})`

    console.log('[UNDO] Setting undo confirm:', {
      seq: lastUndoableEvent.seq,
      type: lastUndoableEvent.type,
      description: displayDescription
    })

    // Log to debug logger for persistence
    debugLogger.log('UNDO_SELECTED', {
      selectedEvent: {
        id: lastUndoableEvent.id,
        seq: lastUndoableEvent.seq,
        type: lastUndoableEvent.type
      },
      description: displayDescription,
      allEventsInSet: currentSetEvents.map(e => ({ id: e.id, seq: e.seq, type: e.type }))
    })

    setUndoConfirm({ event: lastUndoableEvent, description: displayDescription })
  }, [data?.events, data?.set, getActionDescription])

  // Check if there's anything that can be undone (mirrors showUndoConfirm logic)
  const canUndo = useMemo(() => {
    if (!data?.events || data.events.length === 0 || !data?.set) return false

    // Only consider events from the CURRENT SET
    const currentSetIndex = data.set.index
    const currentSetEvents = data.events.filter(e => e.setIndex === currentSetIndex)

    if (currentSetEvents.length === 0) return false

    // Sort events by sequence number (highest first)
    const sortedEvents = [...currentSetEvents].sort((a, b) => {
      const aSeq = a.seq || 0
      const bSeq = b.seq || 0
      if (aSeq !== 0 || bSeq !== 0) {
        return bSeq - aSeq
      }
      const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
      const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
      return bTime - aTime
    })

    // Helper to check if an event is a sub-event (decimal sequence like 7.1, 8.1)
    const isSubEvent = (event) => {
      const seq = event.seq || 0
      return seq !== Math.floor(seq)
    }

    // Check if there's at least one undoable event
    for (const event of sortedEvents) {
      // Skip sub-events (they get undone with their parent)
      if (isSubEvent(event)) {
        // If it's a rotation lineup sub-event, check if parent point exists
        const baseSeq = Math.floor(event.seq || 0)
        const parentPoint = sortedEvents.find(e => e.type === 'point' && Math.floor(e.seq || 0) === baseSeq)
        if (parentPoint) return true
        continue
      }

      // Skip coin_toss events - they cannot be undone
      if (event.type === 'coin_toss') continue

      // Main events (integer sequence) are undoable
      return true
    }

    return false
  }, [data?.events, data?.set, getActionDescription])

  // NEW SNAPSHOT-BASED UNDO SYSTEM
  // Instead of complex per-event-type logic, we simply:
  // 1. Delete all events with the same base seq
  // 2. Restore state from the previous event's snapshot
  const handleUndo = useCallback(async () => {
    cLogger.logHandler('handleUndo', { hasUndoConfirm: !!undoConfirm, eventType: undoConfirm?.event?.type })
    if (!undoConfirm || !data?.set) {
      setUndoConfirm(null)
      return
    }

    const lastEvent = undoConfirm.event
    const lastEventSeq = lastEvent.seq || 0
    const baseSeq = Math.floor(lastEventSeq)

    console.log('[handleUndo] Starting snapshot-based undo for event:', lastEvent.type, 'seq:', lastEventSeq)

    try {
      // 1. Find and delete ALL events with the same base seq (main + sub-events)
      const allEvents = await db.events.where('matchId').equals(matchId).toArray()
      const eventsToDelete = allEvents.filter(e => Math.floor(e.seq || 0) === baseSeq)

      // For point events, also delete the preceding rally_start
      if (lastEvent.type === 'point') {
        const rallyStartEvent = allEvents
          .filter(e => e.type === 'rally_start' && e.setIndex === data.set.index && (e.seq || 0) < lastEventSeq)
          .sort((a, b) => (b.seq || 0) - (a.seq || 0))[0]
        if (rallyStartEvent && !eventsToDelete.some(e => e.id === rallyStartEvent.id)) {
          eventsToDelete.push(rallyStartEvent)
        }
      }

      console.log('[handleUndo] Deleting', eventsToDelete.length, 'events')
      for (const e of eventsToDelete) {
        await db.events.delete(e.id)
        // Also remove from sync_queue if pending
        const syncItems = await db.sync_queue.where('status').equals('queued').toArray()
        const matchingSyncItem = syncItems.find(s => s.payload?.external_id === String(e.id))
        if (matchingSyncItem) {
          await db.sync_queue.delete(matchingSyncItem.id)
        }
      }

      // 2. Find the previous event's snapshot
      const remainingEvents = allEvents
        .filter(e => Math.floor(e.seq || 0) < baseSeq)
        .sort((a, b) => (b.seq || 0) - (a.seq || 0))

      const previousEvent = remainingEvents[0]

      // 3. Restore state from the previous event's snapshot
      if (previousEvent?.stateSnapshot) {
        console.log('[handleUndo] Restoring from snapshot, points:', previousEvent.stateSnapshot.pointsA, '-', previousEvent.stateSnapshot.pointsB)
        await restoreStateFromSnapshot(previousEvent.stateSnapshot)
      } else {
        // No previous event with snapshot - calculate state from remaining events
        console.log('[handleUndo] No previous snapshot, calculating state from remaining events')

        // Re-query remaining events (after deletion)
        const remainingAllEvents = await db.events.where({ matchId }).toArray()
        const currentSetIndex = data.set.index
        const remainingPointEvents = remainingAllEvents.filter(e =>
          e.type === 'point' && e.setIndex === currentSetIndex
        )

        // Count points for each team from remaining point events
        let homePoints = 0
        let awayPoints = 0
        for (const pe of remainingPointEvents) {
          if (pe.payload?.team === 'home') homePoints++
          else if (pe.payload?.team === 'away') awayPoints++
        }

        console.log('[handleUndo] Calculated score from', remainingPointEvents.length, 'point events:', homePoints, '-', awayPoints)

        // Update set with calculated score
        const currentSet = await db.sets.where({ matchId }).and(s => s.index === currentSetIndex).first()
        if (currentSet) {
          await db.sets.update(currentSet.id, { homePoints, awayPoints, finished: false })
        }

        // Reset match status to live
        await db.matches.update(matchId, { status: 'live' })
      }

      // Handle special cases for set_end undo
      if (lastEvent.type === 'set_end') {
        // Delete the next set if it was created
        const allSets = await db.sets.where({ matchId }).toArray()
        const nextSet = allSets.find(s => s.index === data.set.index + 1)
        if (nextSet) {
          await db.events.where('matchId').equals(matchId).and(e => e.setIndex === nextSet.index).delete()
          await db.sets.delete(nextSet.id)
        }
      }

    } catch (error) {
      console.error('[handleUndo] Error:', error)
    } finally {
      // Always close the modal
      setUndoConfirm(null)
      // Sync to Referee and Supabase after undo
      syncToReferee()
      syncLiveStateToSupabase('undo', null, null)
    }
  }, [undoConfirm, data?.set, matchId, restoreStateFromSnapshot, syncToReferee, syncLiveStateToSupabase])

  // OLD UNDO LOGIC REMOVED - The following complex per-event-type logic has been replaced
  // by the snapshot-based undo system above. Keeping this comment for reference.
  // Previously there were ~600 lines of event-specific undo handlers for:
  // - libero_entry, libero_exit, libero_exchange, libero_redesignation
  // - substitution, timeout, sanction, set_end, rally_start, etc.
  // Now all handled by simply restoring the previous event's stateSnapshot.

  const cancelUndo = useCallback(() => {
    setUndoConfirm(null)
  }, [])

  // Handle replay rally - undo last point (go back to state before the point, no rally restart)
  const handleReplayRally = useCallback(async () => {
    if (!replayRallyConfirm || !data?.set) {
      setReplayRallyConfirm(null)
      return
    }

    const lastEvent = replayRallyConfirm.event
    const lastEventSeq = lastEvent.seq || 0
    const baseSeq = Math.floor(lastEventSeq)

    // Find and delete ALL events with the same base ID (point and any related rotation events)
    const allEvents = await db.events.where('matchId').equals(matchId).toArray()
    const eventsToDelete = allEvents.filter(e => {
      const eSeq = e.seq || 0
      return Math.floor(eSeq) === baseSeq
    })

    try {
      // If it's a point, undo the score change
      if (lastEvent.type === 'point' && lastEvent.payload?.team) {
        const team = lastEvent.payload.team
        const field = team === 'home' ? 'homePoints' : 'awayPoints'
        const currentPoints = data.set[field]

        // Decrement the score
        if (currentPoints > 0) {
          await db.sets.update(data.set.id, {
            [field]: currentPoints - 1,
            finished: false
          })
        }

        // Check if there was a rotation after this point (sideout)
        // Find the lineup event that came right after this point (rotation)
        const pointEvents = data.events.filter(e => e.type === 'point' && e.setIndex === data.set.index)
        const sortedPoints = pointEvents.sort((a, b) => (b.seq || 0) - (a.seq || 0))

        // Get the team that had the point before this one (to determine who had serve)
        // Calculate first serve for current set based on alternation pattern
        const replaySetIndex = data.set.index
        const replaySet1FirstServe = data?.match?.firstServe || 'home'
        let replayCurrentSetFirstServe
        if (replaySetIndex === 5 && data.match?.set5FirstServe) {
          const replayTeamAKey = data.match.coinTossTeamA || 'home'
          const replayTeamBKey = data.match.coinTossTeamB || 'away'
          replayCurrentSetFirstServe = data.match.set5FirstServe === 'A' ? replayTeamAKey : replayTeamBKey
        } else if (replaySetIndex === 5) {
          replayCurrentSetFirstServe = replaySet1FirstServe
        } else {
          // Sets 1-4: odd sets (1, 3) same as set 1, even sets (2, 4) opposite
          replayCurrentSetFirstServe = replaySetIndex % 2 === 1 ? replaySet1FirstServe : (replaySet1FirstServe === 'home' ? 'away' : 'home')
        }
        let previousServeTeam = replayCurrentSetFirstServe
        if (sortedPoints.length > 1) {
          // The second point is the one before the current one
          previousServeTeam = sortedPoints[1].payload?.team || previousServeTeam
        }

        // If the scoring team didn't have serve (sideout), a rotation was logged after the point
        // We need to undo that rotation too
        if (lastEvent.payload.team !== previousServeTeam) {
          // Find the rotation lineup that was created after this point
          const lineupEvents = data.events.filter(e =>
            e.type === 'lineup' &&
            e.setIndex === data.set.index &&
            !e.payload?.isInitial &&
            !e.payload?.fromSubstitution &&
            (e.seq || 0) > lastEventSeq
          ).sort((a, b) => (a.seq || 0) - (b.seq || 0)) // Ascending by seq

          // The first lineup event after the point is the rotation
          if (lineupEvents.length > 0 && lineupEvents[0].payload?.team === lastEvent.payload.team) {
            const rotationEvent = lineupEvents[0]
            await db.events.delete(rotationEvent.id)
          }
        }
      }

      // Capture the old score (before undoing the point)
      const oldHomePoints = data.set.homePoints
      const oldAwayPoints = data.set.awayPoints

      // Delete all events with this base seq
      for (const eventToDelete of eventsToDelete) {
        await db.events.delete(eventToDelete.id)
      }

      // Calculate the new score (after undoing the point)
      const undoneTeam = lastEvent.payload?.team
      const newHomePoints = undoneTeam === 'home' ? oldHomePoints - 1 : oldHomePoints
      const newAwayPoints = undoneTeam === 'away' ? oldAwayPoints - 1 : oldAwayPoints

      // Log the replay event (this is important for match records)
      const nextSeq = await getNextSeq()
      const replayStateBefore = getStateSnapshot()

      await db.events.add({
        matchId,
        setIndex: data.set.index,
        type: 'replay',
        payload: {
          reason: 'point_replay',
          undonePointTeam: undoneTeam,
          oldHomePoints,
          oldAwayPoints,
          newHomePoints,
          newAwayPoints
        },
        ts: new Date().toISOString(),
        seq: nextSeq,
        stateBefore: replayStateBefore
      })

      // Go back to idle state - user can then click "Start rally" or "Undo"
      // No automatic rally start

      // Sync to Supabase with fresh snapshot (data has changed)
      syncLiveStateToSupabase('replay', null, { reason: 'point_replay', undoneTeam }, null)

    } catch (error) {
      // Error during replay - silently handle
    } finally {
      setReplayRallyConfirm(null)
    }
  }, [replayRallyConfirm, data?.events, data?.set, data?.match, matchId, getNextSeq, syncLiveStateToSupabase])

  const cancelReplayRally = useCallback(() => {
    setReplayRallyConfirm(null)
  }, [])

  // Handle decision change - either swap point to other team or replay rally
  const handleDecisionChange = useCallback(async () => {
    if (!replayRallyConfirm || !data?.set) {
      setReplayRallyConfirm(null)
      return
    }

    const { event: lastEvent, selectedOption } = replayRallyConfirm

    if (selectedOption === 'swap') {
      // Swap the point to the other team
      const oldTeam = lastEvent.payload?.team
      const newTeam = oldTeam === 'home' ? 'away' : 'home'
      const oldField = oldTeam === 'home' ? 'homePoints' : 'awayPoints'
      const newField = newTeam === 'home' ? 'homePoints' : 'awayPoints'

      try {
        // Update scores: decrement old team, increment new team
        const oldTeamPoints = data.set[oldField]
        const newTeamPoints = data.set[newField]

        await db.sets.update(data.set.id, {
          [oldField]: Math.max(0, oldTeamPoints - 1),
          [newField]: newTeamPoints + 1,
          finished: false
        })

        // Update the point event's team
        await db.events.update(lastEvent.id, {
          payload: {
            ...lastEvent.payload,
            team: newTeam,
            swappedFrom: oldTeam // Track that this was swapped
          }
        })

        // Log a decision_change event for the record
        const nextSeq = await getNextSeq()
        await db.events.add({
          matchId,
          setIndex: data.set.index,
          type: 'decision_change',
          payload: {
            reason: 'point_swap',
            fromTeam: oldTeam,
            toTeam: newTeam,
            oldHomePoints: data.set.homePoints,
            oldAwayPoints: data.set.awayPoints,
            newHomePoints: oldTeam === 'home' ? data.set.homePoints - 1 : data.set.homePoints + 1,
            newAwayPoints: oldTeam === 'away' ? data.set.awayPoints - 1 : data.set.awayPoints + 1
          },
          ts: new Date().toISOString(),
          seq: nextSeq
        })

        // Handle rotation changes if serve changed
        // If old team was NOT serving (sideout happened), we need to undo their rotation
        // and apply rotation to new team if new team wasn't serving
        const lastEventSeq = lastEvent.seq || 0

        // Find rotation events that happened after the point
        const rotationEvents = data.events.filter(e =>
          e.type === 'lineup' &&
          e.setIndex === data.set.index &&
          !e.payload?.isInitial &&
          !e.payload?.fromSubstitution &&
          !e.payload?.liberoSubstitution &&
          (e.seq || 0) > lastEventSeq
        ).sort((a, b) => (a.seq || 0) - (b.seq || 0))

        // Delete any rotations that were for the old team (sideout that shouldn't have happened)
        for (const rotEvent of rotationEvents) {
          if (rotEvent.payload?.team === oldTeam) {
            await db.events.delete(rotEvent.id)
          }
        }

        // Sync to Supabase with fresh snapshot (data has changed)
        syncLiveStateToSupabase('decision_change', null, { reason: 'point_swap', fromTeam: oldTeam, toTeam: newTeam }, null)

      } catch (error) {
        console.error('[handleDecisionChange] Error swapping point:', error)
      }
    } else {
      // Replay rally - use existing logic
      await handleReplayRally()
      return // handleReplayRally already closes the modal and syncs
    }

    setReplayRallyConfirm(null)
  }, [replayRallyConfirm, data?.set, data?.events, matchId, getNextSeq, handleReplayRally, syncLiveStateToSupabase])



  const handleTimeout = useCallback(
    side => {
      cLogger.logHandler('handleTimeout', { side })
      const teamKey = mapSideToTeamKey(side)
      const used = (timeoutsUsed && timeoutsUsed[teamKey]) || 0
      if (used >= 2) return

      // Check for duplicate timeout (same team, no points scored since last TO)
      if (data?.events && data?.set) {
        const currentSetEvents = data.events.filter(e => e.setIndex === data.set.index)
        const lastTimeoutForTeam = [...currentSetEvents]
          .filter(e => e.type === 'timeout' && e.payload?.team === teamKey)
          .sort((a, b) => (b.seq || 0) - (a.seq || 0))[0]

        if (lastTimeoutForTeam) {
          // Check if any points were scored after the last timeout
          const pointsAfterTimeout = currentSetEvents.filter(
            e => e.type === 'point' && (e.seq || 0) > (lastTimeoutForTeam.seq || 0)
          )
          if (pointsAfterTimeout.length === 0) {
            // No points since last timeout for this team - ask for confirmation
            setDuplicateTimeoutConfirm({ team: teamKey })
            return
          }
        }
      }

      setTimeoutModal({ team: teamKey, countdown: 30, started: false })
    },
    [mapSideToTeamKey, timeoutsUsed, data?.events, data?.set]
  )

  const confirmTimeout = useCallback(async () => {
    if (!timeoutModal) return
    // Prevent double-click: if already started, skip
    if (timeoutModal.started) return
    // Mutex: prevent race condition from rapid double-clicks
    if (confirmingTimeoutRef.current) return
    confirmingTimeoutRef.current = true

    // Debug: Check for stale refs that would cause countdown to fail
    console.log('[TO_DEBUG] confirmTimeout called', {
      team: timeoutModal.team,
      alreadyStarted: timeoutModal.started,
      staleTimestampRef: timeoutStartTimestampRef.current,
      staleInitialRef: timeoutInitialCountdownRef.current
    })
    debugLogger.log('TO_CONFIRM', {
      team: timeoutModal.team,
      staleTimestampRef: timeoutStartTimestampRef.current
    })

    try {
      // Log the timeout event
      await logEvent('timeout', { team: timeoutModal.team })

      // Debug log: timeout
      debugLogger.log('TIMEOUT', {
        team: timeoutModal.team
      }, getStateSnapshot())

      // Start the timeout countdown
      const startTimestamp = Date.now()
      setTimeoutModal({ ...timeoutModal, started: true, startedAt: new Date(startTimestamp).toISOString() })
      console.log('[TO_DEBUG] setTimeoutModal called with started: true')

      // Send timeout action to referee to show modal
      sendActionToReferee('timeout', {
        team: timeoutModal.team,
        countdown: 30,
        startTimestamp: startTimestamp
      })

      // Trigger event backup for Safari/Firefox
      onTriggerEventBackup?.('timeout')
    } finally {
      confirmingTimeoutRef.current = false
    }
  }, [timeoutModal, logEvent, sendActionToReferee, onTriggerEventBackup])

  const cancelTimeout = useCallback(() => {
    // Only cancel if timeout hasn't started yet
    if (!timeoutModal || timeoutModal.started) return
    console.log('[TO_DEBUG] cancelTimeout called - resetting refs')
    debugLogger.log('TO_CANCEL', { team: timeoutModal?.team })
    // Reset refs in case they were set (safety measure)
    timeoutStartTimestampRef.current = null
    timeoutInitialCountdownRef.current = 30
    setTimeoutModal(null)
  }, [timeoutModal])

  const stopTimeout = useCallback(() => {
    // Stop the countdown (close modal) but keep the timeout logged
    // The effect will detect the modal closing and sync timeout_active: false to Supabase/referee
    console.log('[TO_DEBUG] stopTimeout called - resetting refs')
    debugLogger.log('TO_STOP', { wasTimestamp: timeoutStartTimestampRef.current })
    // Reset refs so next timeout starts fresh (fixes intermittent countdown failure)
    timeoutStartTimestampRef.current = null
    timeoutInitialCountdownRef.current = 30
    setTimeoutModal(null)
  }, [])

  // Track previous timeout modal state to detect when countdown ends
  const prevTimeoutModalRef = useRef(null)

  useEffect(() => {
    // Detect when timeout ends (was active, now null) and sync to Supabase
    const wasActive = prevTimeoutModalRef.current?.started
    const isNowNull = !timeoutModal

    if (wasActive && isNowNull) {
      // Timeout countdown ended or was stopped - sync timeout_active: false to Supabase
      sendActionToReferee('end_timeout', {})
      syncLiveStateToSupabase('end_timeout', null, null)
    }

    prevTimeoutModalRef.current = timeoutModal
  }, [timeoutModal, sendActionToReferee, syncLiveStateToSupabase])

  useEffect(() => {
    if (!timeoutModal || !timeoutModal.started) return

    // Use startedAt from state if available, otherwise fallback to ref or Date.now()
    const startTimestamp = timeoutModal.startedAt ? new Date(timeoutModal.startedAt).getTime() : (timeoutStartTimestampRef.current || Date.now())
    const initialCountdown = timeoutInitialCountdownRef.current || 30

    // Sync refs for legacy support/internal tracking
    if (!timeoutStartTimestampRef.current) timeoutStartTimestampRef.current = startTimestamp

    if (timeoutModal.countdown <= 0) {
      return
    }

    // Update every 100ms for smooth visuals
    const timer = setInterval(() => {
      const now = Date.now()
      const elapsed = Math.floor((now - startTimestamp) / 1000)
      const remaining = Math.max(0, initialCountdown - elapsed)

      if (remaining <= 0) {
        setTimeoutModal(null)
        timeoutStartTimestampRef.current = null
      } else {
        setTimeoutModal(prev => {
          if (!prev || !prev.started) return null
          if (prev.countdown === remaining) return prev
          return { ...prev, countdown: remaining }
        })
      }
    }, 100)

    return () => clearInterval(timer)
  }, [timeoutModal?.started, timeoutModal?.startedAt])

  const getTimeoutsUsed = useCallback(
    side => {
      const teamKey = mapSideToTeamKey(side)
      return (timeoutsUsed && timeoutsUsed[teamKey]) || 0
    },
    [mapSideToTeamKey, timeoutsUsed]
  )

  const getSubstitutionsUsed = useCallback(
    side => {
      const teamKey = mapSideToTeamKey(side)
      return (substitutionsUsed && substitutionsUsed[teamKey]) || 0
    },
    [mapSideToTeamKey, substitutionsUsed]
  )

  // Get timeout details with scores
  const getTimeoutDetails = useCallback(
    side => {
      if (!data?.events || !data?.set) return []
      const teamKey = mapSideToTeamKey(side)
      const setIndex = data.set.index

      // Get all timeout events for this team in current set
      const timeoutEvents = data.events.filter(e =>
        e.type === 'timeout' &&
        e.setIndex === setIndex &&
        e.payload?.team === teamKey
      )

      // Calculate scores at the time of each timeout
      const details = timeoutEvents.map((event, index) => {
        // Get all point events before this timeout
        // Sort events by seq if available, otherwise by timestamp
        const eventTime = event.seq || (typeof event.ts === 'number' ? event.ts : new Date(event.ts).getTime())
        const pointsBefore = data.events.filter(e => {
          if (e.type !== 'point' || e.setIndex !== setIndex) return false
          const eTime = e.seq || (typeof e.ts === 'number' ? e.ts : new Date(e.ts).getTime())
          return eTime < eventTime
        })

        let homeScore = 0
        let awayScore = 0
        pointsBefore.forEach(e => {
          if (e.payload?.team === 'home') homeScore++
          else if (e.payload?.team === 'away') awayScore++
        })

        return {
          event,
          score: `${homeScore}:${awayScore}`,
          index: index + 1
        }
      })

      return details
    },
    [data?.events, data?.set, mapSideToTeamKey]
  )

  // Get substitution details with scores
  const getSubstitutionDetails = useCallback(
    side => {
      if (!data?.events || !data?.set) return []
      const teamKey = mapSideToTeamKey(side)
      const setIndex = data.set.index

      // Get all substitution events for this team in current set
      const substitutionEvents = data.events.filter(e =>
        e.type === 'substitution' &&
        e.setIndex === setIndex &&
        e.payload?.team === teamKey &&
        !e.payload?.isExceptional
      )

      // Calculate scores at the time of each substitution
      const details = substitutionEvents.map((event, index) => {
        // Get all point events before this substitution
        // Sort events by seq if available, otherwise by timestamp
        const eventTime = event.seq || (typeof event.ts === 'number' ? event.ts : new Date(event.ts).getTime())
        const pointsBefore = data.events.filter(e => {
          if (e.type !== 'point' || e.setIndex !== setIndex) return false
          const eTime = e.seq || (typeof e.ts === 'number' ? e.ts : new Date(e.ts).getTime())
          return eTime < eventTime
        })

        let homeScore = 0
        let awayScore = 0
        pointsBefore.forEach(e => {
          if (e.payload?.team === 'home') homeScore++
          else if (e.payload?.team === 'away') awayScore++
        })

        return {
          event,
          score: `${homeScore}:${awayScore}`,
          playerOut: event.payload?.playerOut,
          playerIn: event.payload?.playerIn,
          position: event.payload?.position,
          index: index + 1
        }
      })

      return details
    },
    [data?.events, data?.set, mapSideToTeamKey]
  )

  const handlePlaceholder = message => () => {
    showAlert(`${message} — coming soon.`, 'info')
  }

  // Check if there was a point change between two events
  const hasPointChangeBetween = useCallback((event1Index, event2Index, setIndex) => {
    if (!data?.events) return false
    const setEvents = data.events.filter(e => (e.setIndex || 1) === setIndex).sort((a, b) => new Date(a.ts) - new Date(b.ts))

    let pointsBefore = { home: 0, away: 0 }
    let pointsAfter = { home: 0, away: 0 }

    for (let i = 0; i < setEvents.length; i++) {
      const e = setEvents[i]
      if (e.type === 'point') {
        if (e.payload?.team === 'home') pointsAfter.home++
        else if (e.payload?.team === 'away') pointsAfter.away++
      }

      if (i === event1Index) {
        pointsBefore = { ...pointsAfter }
      }
      if (i === event2Index) {
        break
      }
    }

    return pointsBefore.home !== pointsAfter.home || pointsBefore.away !== pointsAfter.away
  }, [data?.events])

  // Get substitution history for a team in the current set
  const getSubstitutionHistory = useCallback((teamKey) => {
    if (!data?.events || !data?.set) return []

    const substitutions = data.events
      .filter(e => e.type === 'substitution' && e.payload?.team === teamKey && e.setIndex === data.set.index)
      .sort((a, b) => new Date(a.ts) - new Date(b.ts))
      .map((e, idx) => ({
        ...e,
        index: idx,
        eventIndex: data.events.findIndex(ev => ev.id === e.id)
      }))

    return substitutions
  }, [data?.events, data?.set])

  const leftTeamSubstitutionHistory = useMemo(() =>
    getSubstitutionHistory(leftIsHome ? 'home' : 'away'),
    [getSubstitutionHistory, leftIsHome]
  )

  const rightTeamSubstitutionHistory = useMemo(() =>
    getSubstitutionHistory(leftIsHome ? 'away' : 'home'),
    [getSubstitutionHistory, leftIsHome]
  )

  const buildActiveReplacementMap = (substitutions = []) => {
    const activeMap = new Map()

    substitutions.forEach(sub => {
      const playerOut = sub.payload?.playerOut
      const playerIn = sub.payload?.playerIn
      if (!playerOut || !playerIn) return

      const playerOutStr = String(playerOut)
      const playerInStr = String(playerIn)
      const previouslyReplaced = activeMap.get(playerOutStr)

      activeMap.delete(playerOutStr)

      if (previouslyReplaced && previouslyReplaced === playerInStr) {
        // Original player returning, do not mark as replacement
        return
      }

      activeMap.set(playerInStr, playerOutStr)
    })

    return activeMap
  }

  const leftTeamActiveReplacements = useMemo(
    () => buildActiveReplacementMap(leftTeamSubstitutionHistory),
    [leftTeamSubstitutionHistory]
  )

  const rightTeamActiveReplacements = useMemo(
    () => buildActiveReplacementMap(rightTeamSubstitutionHistory),
    [rightTeamSubstitutionHistory]
  )

  const resolveReplacementNumber = (player, activeReplacementMap) => {
    if (!player || !player.number || player.number === '' || player.isPlaceholder) {
      return null
    }

    if (player.isLibero && player.substitutedPlayerNumber) {
      return String(player.substitutedPlayerNumber)
    }

    if (!activeReplacementMap) return null

    return activeReplacementMap.get(String(player.number)) || null
  }

  const getReplacementBadgeStyle = (player) => {
    const baseStyle = {
      position: 'absolute',
      top: '-1vmin',
      right: '-1vmin',
      width: '2vmin',
      height: '2vmin',
      borderRadius: '4px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontSize: '1.35vmin',
      fontWeight: 700,
      zIndex: 6
    }

    const isLiberoReplacement = player?.isLibero && player?.substitutedPlayerNumber

    if (isLiberoReplacement) {
      return {
        ...baseStyle,
        background: '#ffffff',
        border: '2px solid rgba(255, 255, 255, 0.8)',
        color: '#0f172a',
        boxShadow: '0 2px 6px rgba(15, 23, 42, 0.35)'
      }
    }

    return {
      ...baseStyle,
      background: '#fde047',
      border: '2px solid rgba(0, 0, 0, 0.25)',
      color: '#0f172a',
      boxShadow: '0 2px 4px rgba(15, 23, 42, 0.25)'
    }
  }

  // Helper functions to check substitution types
  const wasSubstitutedDueToExpulsion = useCallback((teamKey, playerNumber) => {
    if (!data?.events) return false
    return data.events.some(e =>
      e.type === 'substitution' &&
      e.payload?.team === teamKey &&
      String(e.payload?.playerOut) === String(playerNumber) &&
      e.payload?.isExpelled === true
    )
  }, [data?.events])

  const wasSubstitutedDueToDisqualification = useCallback((teamKey, playerNumber) => {
    if (!data?.events) return false
    return data.events.some(e =>
      e.type === 'substitution' &&
      e.payload?.team === teamKey &&
      String(e.payload?.playerOut) === String(playerNumber) &&
      e.payload?.isDisqualified === true
    )
  }, [data?.events])

  const wasExceptionallySubstituted = useCallback((teamKey, playerNumber) => {
    if (!data?.events) return false
    return data.events.some(e =>
      e.type === 'substitution' &&
      e.payload?.team === teamKey &&
      String(e.payload?.playerOut) === String(playerNumber) &&
      e.payload?.isExceptional === true
    )
  }, [data?.events])

  const canPlayerReEnter = useCallback((teamKey, playerNumber, currentSetIndex) => {
    if (!data?.events || !currentSetIndex) return true

    // Check if player was substituted due to disqualification - cannot re-enter for rest of game
    if (wasSubstitutedDueToDisqualification(teamKey, playerNumber)) {
      return false
    }

    // Check if player was exceptionally substituted - cannot re-enter for rest of game
    if (wasExceptionallySubstituted(teamKey, playerNumber)) {
      return false
    }

    // Check if player was substituted due to expulsion - cannot re-enter for rest of set
    if (wasSubstitutedDueToExpulsion(teamKey, playerNumber)) {
      // Check if this is the same set where they were expelled
      const expulsionSub = data.events.find(e =>
        e.type === 'substitution' &&
        e.payload?.team === teamKey &&
        String(e.payload?.playerOut) === String(playerNumber) &&
        e.payload?.isExpelled === true
      )
      if (expulsionSub && expulsionSub.setIndex === currentSetIndex) {
        return false // Cannot re-enter in same set
      }
    }

    return true
  }, [data?.events, wasSubstitutedDueToExpulsion, wasSubstitutedDueToDisqualification, wasExceptionallySubstituted])

  // Check if a player on court can be substituted
  const canPlayerBeSubstituted = useCallback((teamKey, playerNumber) => {
    if (!data?.events || !data?.set) return true

    // Get all substitutions for this team in current set
    const substitutions = getSubstitutionHistory(teamKey)

    // Get all substitutions where this player was involved (either in or out)
    const substitutionsWherePlayerIn = substitutions.filter(s =>
      String(s.payload?.playerIn) === String(playerNumber)
    )
    const substitutionsWherePlayerOut = substitutions.filter(s =>
      String(s.payload?.playerOut) === String(playerNumber)
    )

    // If player was never involved in any substitution, they can be substituted
    if (substitutionsWherePlayerIn.length === 0 && substitutionsWherePlayerOut.length === 0) {
      return true
    }

    // Check if player was substituted out and came back (completed cycle)
    // This means: Player A out -> Player B in -> Player B out -> Player A in
    if (substitutionsWherePlayerOut.length > 0) {
      // Find the most recent substitution where this player went out
      const lastSubOut = substitutionsWherePlayerOut[substitutionsWherePlayerOut.length - 1]
      const playerWhoCameIn = lastSubOut.payload?.playerIn

      // Check if the player who came in has been substituted out with this player coming back
      const hasComeBack = substitutions.some(s =>
        String(s.payload?.playerOut) === String(playerWhoCameIn) &&
        String(s.payload?.playerIn) === String(playerNumber) &&
        new Date(s.ts) > new Date(lastSubOut.ts)
      )

      if (hasComeBack) {
        // Player was out and came back - cycle complete, cannot be substituted
        return false
      }
    }

    // Check if player was substituted in and the original player came back (completed cycle)
    // This means: Player A out -> Player B in -> Player B out -> Player A in
    // But from Player B's perspective: Player B in (for A) -> Player B out (A comes back)
    if (substitutionsWherePlayerIn.length > 0) {
      // Find the most recent substitution where this player came in
      const lastSubIn = substitutionsWherePlayerIn[substitutionsWherePlayerIn.length - 1]
      const originalPlayerOut = lastSubIn.payload?.playerOut

      // Check if there was a point change since this substitution
      const lastSubstitutionIndex = lastSubIn.eventIndex
      const eventsAfterSub = data.events
        .filter((e, idx) => idx > lastSubstitutionIndex && (e.setIndex || 1) === data.set.index)
        .sort((a, b) => new Date(a.ts) - new Date(b.ts))

      const pointAfterSub = eventsAfterSub.find(e => e.type === 'point')

      if (pointAfterSub) {
        // There was a point change, check if the original player came back
        // This means: this player (who came in) was substituted out, and original came back
        const hasComeBack = substitutions.some(s =>
          String(s.payload?.playerOut) === String(playerNumber) &&
          String(s.payload?.playerIn) === String(originalPlayerOut) &&
          new Date(s.ts) > new Date(lastSubIn.ts)
        )

        if (hasComeBack) {
          // Original player came back - cycle complete, cannot be substituted
          return false
        }

        // Original player hasn't come back yet, but there was a point change
        // This player can be substituted out (to let original come back)
        return true
      }

      // No point change yet - cannot substitute yet (must wait for point)
      return false
    }

    // If we get here, the player can be substituted
    return true
  }, [data?.events, data?.set, getSubstitutionHistory])

  // Check if a substitution is legal (not exceptional)
  const isSubstitutionLegal = useCallback((teamKey, playerOutNumber) => {
    if (!data?.events || !data?.set) return true

    // Check substitution limit (6 per set)
    const substitutions = getSubstitutionHistory(teamKey)
    if (substitutions.length >= 0) return false // No substitutions in beach volley

    // Check if player can be substituted
    return canPlayerBeSubstituted(teamKey, playerOutNumber)
  }, [data?.events, data?.set, getSubstitutionHistory, canPlayerBeSubstituted])

  // Get available substitutes for a player being substituted out
  const getAvailableSubstitutes = useCallback((teamKey, playerOutNumber, allowExceptional = false) => {
    if (!data) return []

    const benchPlayers = teamKey === 'home'
      ? (leftIsHome ? leftTeamBench.benchPlayers : rightTeamBench.benchPlayers)
      : (leftIsHome ? rightTeamBench.benchPlayers : leftTeamBench.benchPlayers)

    // Filter out liberos
    let available = benchPlayers.filter(p => !p.libero || p.libero === '')

    // Filter out players currently replaced by a libero (cannot be substituted while libero is in for them)
    const liberoEntries = data.events?.filter(e =>
      e.type === 'libero_entry' &&
      e.payload?.team === teamKey &&
      e.setIndex === data.set.index
    ) || []

    const liberoExits = data.events?.filter(e =>
      e.type === 'libero_exit' &&
      e.payload?.team === teamKey &&
      e.setIndex === data.set.index
    ) || []

    // Find players currently replaced by libero (libero entered for them, libero hasn't exited yet)
    const playersReplacedByLibero = new Set()
    liberoEntries.forEach(entry => {
      const playerOut = entry.payload?.playerOut
      // Check if libero has exited since this entry
      const liberoHasExited = liberoExits.some(exit =>
        exit.payload?.playerIn === playerOut &&
        (exit.seq || 0) > (entry.seq || 0)
      )
      if (!liberoHasExited && playerOut) {
        playersReplacedByLibero.add(Number(playerOut))
      }
    })

    // Filter out players currently replaced by libero
    available = available.filter(p => !playersReplacedByLibero.has(Number(p.number)))

    // Get substitution history
    const substitutions = getSubstitutionHistory(teamKey)

    // Check if playerOut was previously substituted in (meaning someone was substituted out for them)
    const substitutionsWherePlayerIn = substitutions.filter(s =>
      String(s.payload?.playerIn) === String(playerOutNumber)
    )

    if (substitutionsWherePlayerIn.length > 0) {
      // This player was substituted in, so ONLY the player who was substituted out can come back for them
      const lastSubstitution = substitutionsWherePlayerIn[substitutionsWherePlayerIn.length - 1]
      const originalPlayerOut = lastSubstitution.payload?.playerOut

      // Check if there was a point change since this substitution
      const lastSubstitutionIndex = lastSubstitution.eventIndex
      const eventsAfterSub = data.events
        .filter((e, idx) => idx > lastSubstitutionIndex && (e.setIndex || 1) === data.set.index)
        .sort((a, b) => new Date(a.ts) - new Date(b.ts))

      const pointAfterSub = eventsAfterSub.find(e => e.type === 'point')

      if (pointAfterSub) {
        // There was a point change, so the original player can come back
        // But only if they haven't already come back in this set
        const hasComeBack = substitutions.some(s =>
          String(s.payload?.playerOut) === String(playerOutNumber) &&
          String(s.payload?.playerIn) === String(originalPlayerOut) &&
          new Date(s.ts) > new Date(lastSubstitution.ts)
        )

        if (!hasComeBack) {
          // Only the original player can substitute back
          const originalPlayer = benchPlayers.find(p => String(p.number) === String(originalPlayerOut))
          if (originalPlayer && !originalPlayer.libero) {
            return [originalPlayer] // Only this player is available
          }
        }
        // If already came back, check if exceptional substitution is allowed
        if (allowExceptional) {
          // For exceptional substitution, return all bench players (except liberos and those who cannot re-enter)
          return available.filter(p => canPlayerReEnter(teamKey, p.number, data.set.index))
        }
        return []
      } else {
        // No point change yet, check if exceptional substitution is allowed
        if (allowExceptional) {
          // For exceptional substitution, return all bench players (except liberos and those who cannot re-enter)
          return available.filter(p => canPlayerReEnter(teamKey, p.number, data.set.index))
        }
        return []
      }
    }

    // Player was not substituted in, so any bench player can substitute
    // But filter out players who were substituted out but can't come back yet (no point change)
    // And filter out players who already came back (got in and out again)
    // And filter out players who cannot re-enter (expelled/disqualified/exceptionally substituted)
    available = available.filter(player => {
      // Check if player can re-enter using helper function
      if (!canPlayerReEnter(teamKey, player.number, data.set.index)) {
        return false
      }

      // Check if player was substituted out
      const playerSubstitutionsOut = substitutions.filter(s =>
        String(s.payload?.playerOut) === String(player.number)
      )

      // Check if player was substituted in
      const playerSubstitutionsIn = substitutions.filter(s =>
        String(s.payload?.playerIn) === String(player.number)
      )

      // If player was never substituted, they're available
      if (playerSubstitutionsOut.length === 0 && playerSubstitutionsIn.length === 0) {
        return true
      }

      // If player was substituted in, they cannot be substituted again (except exceptional)
      // This means they were on court, got substituted out, and are now on bench
      // They've completed a cycle and cannot re-enter
      if (playerSubstitutionsIn.length > 0) {
        return allowExceptional
      }

      // Player was substituted out (but never substituted in)
      // They can only come back for the SPECIFIC player they were substituted out for
      const lastSubstitutionOut = playerSubstitutionsOut[playerSubstitutionsOut.length - 1]
      const playerTheyWereSubstitutedFor = lastSubstitutionOut.payload?.playerIn

      // Check if they came back for that specific player
      const hasComeBackForSpecificPlayer = substitutions.some(s =>
        String(s.payload?.playerOut) === String(playerTheyWereSubstitutedFor) &&
        String(s.payload?.playerIn) === String(player.number) &&
        new Date(s.ts) > new Date(lastSubstitutionOut.ts)
      )

      // If they came back, they've completed a cycle and cannot be substituted again (except exceptional)
      if (hasComeBackForSpecificPlayer) {
        return allowExceptional
      }

      // Player was substituted out but hasn't come back yet
      // They can only come back for the specific player they were substituted out for
      // Check if the player being substituted out now is that specific player
      if (String(playerTheyWereSubstitutedFor) !== String(playerOutNumber)) {
        // Not the right player - this player cannot substitute for anyone else
        return false
      }

      // This is the right player, check if there was a point change
      const lastSubstitutionIndex = lastSubstitutionOut.eventIndex
      const eventsAfterSub = data.events
        .filter((e, idx) => idx > lastSubstitutionIndex && (e.setIndex || 1) === data.set.index)
        .sort((a, b) => new Date(a.ts) - new Date(b.ts))

      const pointAfterSub = eventsAfterSub.find(e => e.type === 'point')

      if (!pointAfterSub) {
        // No point change yet - cannot come back (except exceptional)
        return allowExceptional
      }

      // Point change occurred, player can come back for this specific player
      return true
    })

    return available.sort((a, b) => (a.number || 0) - (b.number || 0))
  }, [data, leftIsHome, leftTeamBench, rightTeamBench, getSubstitutionHistory, data?.events, canPlayerReEnter])

  // Get available players for exceptional substitution
  // Excludes: liberos, expelled/disqualified players, and the player being replaced
  const getAvailableExceptionalSubstitutes = useCallback((teamKey, playerOutNumber) => {
    if (!data) return []

    const benchPlayers = teamKey === 'home'
      ? (leftIsHome ? leftTeamBench.benchPlayers : rightTeamBench.benchPlayers)
      : (leftIsHome ? rightTeamBench.benchPlayers : leftTeamBench.benchPlayers)

    // Get all liberos (both L1 and L2)
    const teamPlayers = teamKey === 'home' ? data?.homePlayers : data?.awayPlayers
    const liberos = teamPlayers?.filter(p => p.libero && p.libero !== '') || []
    const liberoNumbers = new Set(liberos.map(p => Number(p.number)))

    // Filter available players
    const available = benchPlayers.filter(p => {
      const playerNum = Number(p.number)

      // Exclude liberos
      if (liberoNumbers.has(playerNum)) return false

      // Exclude the player being replaced
      if (String(playerNum) === String(playerOutNumber)) return false

      // Exclude players who cannot re-enter (expelled/disqualified/exceptionally substituted)
      if (!canPlayerReEnter(teamKey, playerNum, data.set.index)) return false

      return true
    })

    return available.sort((a, b) => (a.number || 0) - (b.number || 0))
  }, [data, leftIsHome, leftTeamBench, rightTeamBench, canPlayerReEnter])

  // Check if a bench player can come back (was substituted out, has point change, hasn't come back yet)
  const canPlayerComeBack = useCallback((teamKey, playerNumber) => {
    if (!data?.events || !data?.set) return false

    // Check if player is disqualified - disqualified players cannot re-enter
    const playerSanctions = data.events.filter(e =>
      e.type === 'sanction' &&
      e.payload?.team === teamKey &&
      e.payload?.playerNumber === playerNumber &&
      e.payload?.type === 'disqualification'
    )
    if (playerSanctions.length > 0) return false // Disqualified, cannot re-enter

    const substitutions = getSubstitutionHistory(teamKey)

    // Check if this player was substituted out
    const playerSubstitutions = substitutions.filter(s =>
      String(s.payload?.playerOut) === String(playerNumber)
    )

    if (playerSubstitutions.length === 0) return false // Never substituted out

    const lastSubstitution = playerSubstitutions[playerSubstitutions.length - 1]
    const lastSubstitutionIndex = lastSubstitution.eventIndex

    // Check if player was expelled - expelled players can only re-enter in next set
    // If expelled in current set, cannot re-enter in current set
    const expulsionSanctions = data.events.filter(e =>
      e.type === 'sanction' &&
      e.payload?.team === teamKey &&
      e.payload?.playerNumber === playerNumber &&
      e.payload?.type === 'expulsion' &&
      (e.setIndex || 1) === data.set.index
    )
    if (expulsionSanctions.length > 0) {
      return false // Expelled in this set, can only re-enter next set
    }

    // Check if there was a point change since substitution
    const eventsAfterSub = data.events
      .filter((e, idx) => idx > lastSubstitutionIndex && (e.setIndex || 1) === data.set.index)
      .sort((a, b) => new Date(a.ts) - new Date(b.ts))

    const pointAfterSub = eventsAfterSub.find(e => e.type === 'point')

    if (!pointAfterSub) return false // No point change yet

    // Check if player has already come back
    const hasComeBack = substitutions.some(s =>
      String(s.payload?.playerIn) === String(playerNumber) &&
      new Date(s.ts) > new Date(lastSubstitution.ts)
    )

    if (hasComeBack) return false // Already came back

    return true // Can come back
  }, [data?.events, data?.set, getSubstitutionHistory])

  // Check if a bench player already came back (got in and out again)
  const hasPlayerComeBack = useCallback((teamKey, playerNumber) => {
    if (!data?.events || !data?.set) return false

    const substitutions = getSubstitutionHistory(teamKey)

    // Check if this player was substituted in (meaning they came in)
    const playerSubstitutionsIn = substitutions.filter(s =>
      String(s.payload?.playerIn) === String(playerNumber)
    )

    if (playerSubstitutionsIn.length === 0) return false // Never substituted in

    // Check if after being substituted in, they were substituted out
    const lastSubstitutionIn = playerSubstitutionsIn[playerSubstitutionsIn.length - 1]
    const lastSubstitutionInIndex = lastSubstitutionIn.eventIndex

    // Check if player was substituted out after being substituted in
    const hasBeenSubstitutedOut = substitutions.some(s =>
      String(s.payload?.playerOut) === String(playerNumber) &&
      data.events.findIndex(e => e.id === s.id) > lastSubstitutionInIndex
    )

    return hasBeenSubstitutedOut
  }, [data?.events, data?.set, getSubstitutionHistory])

  // Check if a libero is unable to play (injured, expelled, disqualified, or declared unable)
  // MUST be defined before handlers that use it in dependency arrays
  const isLiberoUnable = useCallback((teamKey, liberoNumber) => {
    // Check if player is marked as 'unable' in database (from libero redesignation)
    const teamPlayers = teamKey === 'home' ? data?.homePlayers : data?.awayPlayers
    const player = teamPlayers?.find(p => Number(p.number) === Number(liberoNumber))
    if (player?.libero === 'unable') return true

    if (!data?.events) return false

    // Check for expulsion or disqualification
    const sanctions = data.events.filter(e =>
      e.type === 'sanction' &&
      e.payload?.team === teamKey &&
      e.payload?.playerNumber === liberoNumber &&
      (e.payload?.type === 'expulsion' || e.payload?.type === 'disqualification')
    )
    if (sanctions.length > 0) return true

    // Check for libero_unable event (declared by coach)
    const unableEvents = data.events.filter(e =>
      e.type === 'libero_unable' &&
      e.payload?.team === teamKey &&
      e.payload?.liberoNumber === liberoNumber
    )
    if (unableEvents.length > 0) return true

    // Check if libero was injured (substituted due to injury)
    const injurySubs = data.events.filter(e =>
      e.type === 'substitution' &&
      e.payload?.team === teamKey &&
      e.payload?.playerOut === liberoNumber &&
      e.payload?.isInjury === true
    )
    if (injurySubs.length > 0) return true

    return false
  }, [data?.events, data?.homePlayers, data?.awayPlayers])

  // Get libero currently on court for a team
  const getLiberoOnCourt = useCallback((teamKey) => {
    const { currentLineup, positionLiberoMap } = getTeamLineupState(teamKey)
    if (!currentLineup || !positionLiberoMap) return null

    for (const [position, info] of Object.entries(positionLiberoMap)) {
      if (!info) continue
      const numberOnCourt = currentLineup[position]
      if (String(numberOnCourt) === String(info.liberoNumber)) {
        return {
          position,
          liberoNumber: info.liberoNumber,
          liberoType: info.liberoType,
          playerNumber: info.playerNumber
        }
      }
    }

    return null
  }, [getTeamLineupState])

  // Debug helper - expose libero status to console
  useEffect(() => {
    window.debugLiberoStatus = () => {
      const result = { home: { liberos: [], redesignation: {} }, away: { liberos: [], redesignation: {} } }
      for (const teamKey of ['home', 'away']) {
        const teamPlayers = teamKey === 'home' ? data?.homePlayers : data?.awayPlayers
        const liberos = teamPlayers?.filter(p => p.libero && p.libero !== '') || []
        const liberoOnCourt = getLiberoOnCourt(teamKey)

        for (const lib of liberos) {
          const unable = isLiberoUnable(teamKey, lib.number)
          result[teamKey].liberos.push({
            number: lib.number,
            type: lib.libero,
            unable,
            onCourt: liberoOnCourt?.liberoNumber === lib.number ? liberoOnCourt.position : null,
            replacedPlayer: liberoOnCourt?.liberoNumber === lib.number ? liberoOnCourt.playerNumber : null
          })
        }

        // Check redesignation conditions
        const allLiberos = liberos
        const activeLiberos = allLiberos.filter(p => !isLiberoUnable(teamKey, p.number))
        const originalLiberoCount = allLiberos.filter(p => p.libero === 'libero1' || p.libero === 'libero2').length
        const unableLiberos = allLiberos.filter(p => isLiberoUnable(teamKey, p.number))
        const alreadyRedesignated = data?.events?.some(e =>
          e.type === 'libero_redesignation' && e.payload?.team === teamKey
        )

        result[teamKey].redesignation = {
          originalLiberoCount,
          activeLiberos: activeLiberos.map(l => l.number),
          unableLiberos: unableLiberos.map(l => l.number),
          alreadyRedesignated,
          shouldShowRedesignation: activeLiberos.length === 0 && unableLiberos.length > 0 && !alreadyRedesignated
        }
      }

      console.log('=== HOME TEAM LIBEROS ===')
      console.table(result.home.liberos)
      console.log('Redesignation:', result.home.redesignation)

      console.log('=== AWAY TEAM LIBEROS ===')
      console.table(result.away.liberos)
      console.log('Redesignation:', result.away.redesignation)

      console.log('=== MODAL STATE ===')
      console.log('liberoRedesignationModal:', liberoRedesignationModal)
      console.log('liberoUnableModal:', liberoUnableModal)

      return result
    }
    console.log('[DEBUG] Run window.debugLiberoStatus() to check libero status')
  }, [data?.homePlayers, data?.awayPlayers, data?.events, isLiberoUnable, getLiberoOnCourt, liberoRedesignationModal, liberoUnableModal])

  // Check if there has been a point since last libero exchange
  const hasPointSinceLastLiberoExchange = useCallback((teamKey) => {
    if (!data?.events || !data?.set) return false

    // Find last libero entry, exit, or exchange event
    const liberoEvents = data.events.filter(e =>
      (e.type === 'libero_entry' || e.type === 'libero_exit' || e.type === 'libero_exchange') &&
      e.payload?.team === teamKey &&
      e.setIndex === data.set.index
    ).sort((a, b) => new Date(b.ts) - new Date(a.ts))

    if (liberoEvents.length === 0) return true // No libero exchange yet, allow

    const lastLiberoEvent = liberoEvents[0]
    const lastLiberoEventIndex = data.events.findIndex(e => e.id === lastLiberoEvent.id)

    // Special case: Allow immediate libero entry in specific scenarios:
    // 1. After libero BECOMES unable (injury/expulsion/disqualification) - immediate entry
    // 2. After redesignation due to becoming unable - immediate entry for FIRST entry only
    // 3. After redesignation due to being declared unable - must wait for point
    const specialEvents = data.events.filter(e =>
      e.setIndex === data.set.index &&
      e.payload?.team === teamKey &&
      (
        // Allow immediate entry after libero BECOMES unable (not declared)
        (e.type === 'libero_unable' &&
          (e.payload?.reason === 'expulsion' ||
            e.payload?.reason === 'disqualification' ||
            e.payload?.reason === 'injury')) ||
        // Allow immediate entry after redesignation ONLY if due to becoming unable
        (e.type === 'libero_redesignation' &&
          e.payload?.reason !== 'declared' &&
          e.payload?.reason !== undefined)
      )
    ).sort((a, b) => new Date(b.ts) - new Date(a.ts))

    if (specialEvents.length > 0) {
      const lastSpecialEvent = specialEvents[0]

      if (new Date(lastSpecialEvent.ts) > new Date(lastLiberoEvent.ts)) {
        // If this is a redesignation, only allow immediate entry for FIRST entry
        if (lastSpecialEvent.type === 'libero_redesignation') {
          const entriesSinceRedesignation = data.events.filter(e =>
            e.setIndex === data.set.index &&
            e.type === 'libero_entry' &&
            e.payload?.team === teamKey &&
            new Date(e.ts) > new Date(lastSpecialEvent.ts)
          )

          // If redesignated libero already entered, require point for subsequent entries
          if (entriesSinceRedesignation.length === 0) {
            return true  // First entry after redesignation, allow immediate
          }
          // Fall through to normal point check
        } else {
          // libero_unable event (injury/expulsion/disqualification), allow immediate entry
          return true
        }
      }
    }

    // Check if there's been a point since then
    const eventsAfter = data.events.slice(lastLiberoEventIndex + 1).filter(e =>
      e.setIndex === data.set.index && e.type === 'point'
    )

    return eventsAfter.length > 0
  }, [data?.events, data?.set])

  // ========== Court Player Name Handlers ==========

  // Get display name for court player (shows last name by default)
  const getCourtPlayerDisplayName = useCallback((teamKey, playerNumber, firstName, lastName) => {
    return lastName || firstName || ''
  }, [])

  // Toggle expanded player name (collapsible menu showing full name and number)
  const toggleExpandedPlayerName = useCallback((teamKey, playerNumber, e) => {
    e.stopPropagation()
    const key = `${teamKey}-${playerNumber}`
    setExpandedPlayerName(prev => prev === key ? null : key)
  }, [])

  // No-op drag handlers (beach volleyball has no substitutions)
  const draggedPlayer = null
  const touchDragState = { isDragging: false }
  const validDropTargets = []
  const handleBenchDragStart = () => {}
  const handleBenchDragEnd = () => {}
  const handleCourtDragStart = () => {}
  const handleCourtDragEnd = () => {}
  const handleCourtDragOver = () => {}
  const handleCourtDragLeave = () => {}
  const handleCourtDrop = () => {}
  const handleBenchDropOver = () => {}
  const handleBenchDropLeave = () => {}
  const handleBenchDrop = () => {}
  const handleTouchDragStart = () => {}
  const handleTouchMove = () => {}
  const handleTouchEnd = () => {}
  const handleTouchCancel = () => {}

  // Handle player click for substitution/libero/sanction/injury (only when rally is not in play and lineup is set)
  const handlePlayerClick = useCallback((teamKey, position, playerNumber, event) => {
    // Only allow when rally is not in play and lineup is set
    if (rallyStatus !== 'idle') return
    if (isRallyReplayed) return // Don't allow actions when rally is replayed
    if (!leftTeamLineupSet && teamKey === (leftIsHome ? 'home' : 'away')) return
    if (!rightTeamLineupSet && teamKey === (leftIsHome ? 'away' : 'home')) return
    if (!playerNumber || playerNumber === '') return // Can't substitute placeholder

    // Check if this player is a libero - liberos cannot be substituted
    const teamPlayers = teamKey === 'home' ? data?.homePlayers : data?.awayPlayers
    const clickedPlayer = teamPlayers?.find(p => String(p.number) === String(playerNumber))
    const isLibero = clickedPlayer?.libero && clickedPlayer.libero !== ''

    // Check if position is back row (I, V, VI) for libero
    const isBackRow = position === 'I' || position === 'V' || position === 'VI'

    // Check if this position is serving
    const currentServe = getCurrentServe()
    const teamServes = currentServe === teamKey
    const isServing = teamServes && position === 'I'

    // Get team players to check for liberos
    const liberos = teamPlayers?.filter(p => p.libero && p.libero !== '') || []

    // Check if a libero is already on court
    const liberoOnCourt = getLiberoOnCourt(teamKey)
    const canEnterLibero = !isLibero && liberos.length > 0 && (liberoOnCourt === null || liberoOnCourt === undefined)

    // Check if there has been a point since last libero exchange
    const hasPointSinceLibero = hasPointSinceLastLiberoExchange(teamKey)

    // Check substitution limit (6 per set)
    const teamSubstitutions = substitutionsUsed?.[teamKey] || 0
    const canSubstitute = !isLibero && !isRallyReplayed && teamSubstitutions < 6 && canPlayerBeSubstituted(teamKey, playerNumber)

    // Get the clicked element position (the circle)
    const element = event.currentTarget
    const rect = element.getBoundingClientRect()

    // Calculate center of the circle
    const centerX = rect.left + rect.width / 2
    const centerY = rect.top + rect.height / 2

    // Calculate radius (half the width/height)
    const radius = rect.width / 2

    // Determine if this is the right side team (menu should open to the left)
    const isRightTeam = teamKey === (leftIsHome ? 'away' : 'home')

    // Offset to move menu from the circle
    // Positive for left team (opens right), negative for right team (opens left)
    const offset = isRightTeam ? -(radius + 30) : (radius + 30)

    // Close menu if it's already open for this player
    if (playerActionMenu?.playerNumber === playerNumber && playerActionMenu?.position === position) {
      setPlayerActionMenu(null)
      return
    }

    // Check if clicked player is a libero currently on court
    const isLiberoOnCourt = isLibero && liberoOnCourt && String(liberoOnCourt.liberoNumber) === String(playerNumber)

    // Show action menu with buttons
    setPlayerActionMenu({
      team: teamKey,
      position,
      playerNumber,
      element,
      x: centerX + offset,
      y: centerY,
      side: isRightTeam ? 'right' : 'left',
      canSubstitute,
      canEnterLibero: isBackRow && !isServing && canEnterLibero && hasPointSinceLibero,
      isLiberoOnCourt,
      liberoOnCourt: isLiberoOnCourt ? liberoOnCourt : null
    })
  }, [rallyStatus, isRallyReplayed, leftTeamLineupSet, rightTeamLineupSet, leftIsHome, playerActionMenu, substitutionsUsed, canPlayerBeSubstituted, getCurrentServe, getLiberoOnCourt, hasPointSinceLastLiberoExchange, data?.homePlayers, data?.awayPlayers])

  // Show substitution confirmation
  const showSubstitutionConfirm = useCallback((substituteNumber) => {
    if (!substitutionDropdown || !substituteNumber) return

    const teamKey = substitutionDropdown.team
    const playerOutNumber = substitutionDropdown.playerNumber

    // Check if substitution is legal or exceptional
    const isExceptional = substitutionDropdown.isExceptional === true
    const isLegal = !isExceptional && isSubstitutionLegal(teamKey, playerOutNumber)

    // Check if player is expelled or disqualified
    const playerSanctions = data?.events?.filter(e =>
      e.type === 'sanction' &&
      e.payload?.team === teamKey &&
      e.payload?.playerNumber === playerOutNumber &&
      (e.payload?.type === 'expulsion' || e.payload?.type === 'disqualification')
    ) || []
    const isExpelled = playerSanctions.some(s => s.payload?.type === 'expulsion')
    const isDisqualified = playerSanctions.some(s => s.payload?.type === 'disqualification')

    setSubstitutionConfirm({
      team: substitutionDropdown.team,
      position: substitutionDropdown.position,
      playerOut: substitutionDropdown.playerNumber,
      playerIn: substituteNumber,
      isInjury: substitutionDropdown.isInjury || false,
      isExceptional: isExceptional,
      isExpelled: isExpelled,
      isDisqualified: isDisqualified
    })
    setSubstitutionDropdown(null)
    setLiberoDropdown(null) // Close libero dropdown when selecting substitution
  }, [substitutionDropdown, isSubstitutionLegal, data?.events])

  // Get available players for libero re-designation (not on court, not already libero, not re-designated)
  const getAvailablePlayersForRedesignation = useCallback((teamKey, unableLiberoNumber) => {
    if (!data) return []

    const teamPlayers = teamKey === 'home' ? data?.homePlayers : data?.awayPlayers
    const { playersOnCourt } = getTeamLineupState(teamKey)
    const playersOnCourtSet = new Set(playersOnCourt.map(num => Number(num)))

    // Get all re-designation events to find already re-designated players
    const redesignationEvents = data?.events?.filter(e =>
      e.type === 'libero_redesignation' &&
      e.payload?.team === teamKey
    ) || []
    const redesignatedPlayerNumbers = new Set(
      redesignationEvents.map(e => e.payload?.newLiberoNumber).filter(n => n !== undefined && n !== null)
    )

    // Filter: not on court, not already a libero, not already re-designated, not the unable libero
    return teamPlayers.filter(p => {
      const playerNumber = Number(p.number)
      if (Number.isNaN(playerNumber)) return false
      if (playersOnCourtSet.has(playerNumber)) return false // On court
      if (p.libero && p.libero !== '') return false // Already a libero
      if (redesignatedPlayerNumbers.has(playerNumber)) return false // Already re-designated
      if (playerNumber === unableLiberoNumber) return false // The unable libero
      return true
    })
  }, [data, getTeamLineupState])

  // Check if libero re-designation is needed and trigger modal
  // Called after a libero is marked as unable - we know they're unable so skip that check
  const checkLiberoRedesignation = useCallback((teamKey, liberoNumber, liberoType, reason = 'declared') => {
    if (!data?.set) return

    // Check if already re-designated
    const alreadyRedesignated = data?.events?.some(e =>
      e.type === 'libero_redesignation' &&
      e.payload?.team === teamKey &&
      e.payload?.unableLiberoNumber === liberoNumber
    )
    if (alreadyRedesignated) return

    // Check team libero rules
    const teamPlayers = teamKey === 'home' ? data?.homePlayers : data?.awayPlayers
    // Get all liberos (including 'unable' ones for counting original liberos)
    const allLiberos = teamPlayers.filter(p => p.libero && p.libero !== '')
    // Get active liberos - use isLiberoUnable() to check both database field AND events
    const activeLiberos = allLiberos.filter(p => !isLiberoUnable(teamKey, p.number))
    // Count original liberos (libero1 or libero2 - not redesignated)
    const originalLiberoCount = allLiberos.filter(p => p.libero === 'libero1' || p.libero === 'libero2').length
    const unableLiberos = allLiberos.filter(p => isLiberoUnable(teamKey, p.number))

    // If team started with 2 liberos, and still has at least 1 active libero that isn't the one becoming unable
    // then no redesignation needed
    if (originalLiberoCount === 2) {
      const otherActiveLiberos = activeLiberos.filter(p => Number(p.number) !== Number(liberoNumber))
      if (otherActiveLiberos.length > 0) {
        // Still have at least one other active libero, no redesignation needed
        return
      }
    }

    // If team started with 1 libero (or all other liberos are unable), allow redesignation
    // Also allow if no active liberos remain after this one becomes unable

    // Get available players
    const availablePlayers = getAvailablePlayersForRedesignation(teamKey, liberoNumber)
    if (availablePlayers.length === 0) {
      showAlert('No available players for libero re-designation. All players are either on court or already liberos.', 'warning')
      return
    }

    // Show re-designation modal
    setLiberoRedesignationModal({
      team: teamKey,
      unableLiberoNumber: liberoNumber,
      unableLiberoType: liberoType,
      reason: reason
    })
  }, [data?.set, data?.events, data?.homePlayers, data?.awayPlayers, isLiberoUnable, getAvailablePlayersForRedesignation])

  // Handle forfait - award all remaining points and sets to opponent
  const handleForfait = useCallback(async (teamKey, reason) => {
    cLogger.logHandler('handleForfait', { teamKey, reason })
    if (!data?.set || !data?.match) return

    const opponentKey = teamKey === 'home' ? 'away' : 'home'
    const allSets = await db.sets.where({ matchId }).sortBy('index')
    const currentSetIndex = data.set.index
    const is5thSet = currentSetIndex === 5
    const pointsToWin = is5thSet ? 15 : 25

    // Award current set to opponent
    const currentSet = allSets.find(s => s.index === currentSetIndex)
    if (currentSet && !currentSet.finished) {
      const teamPoints = currentSet[teamKey === 'home' ? 'homePoints' : 'awayPoints'] || 0
      const currentOpponentPoints = currentSet[opponentKey === 'home' ? 'homePoints' : 'awayPoints'] || 0

      // Calculate target points - must have 2-point lead if in deuce
      // If forfeiting team has >= pointsToWin - 1, we need forfeiting team's score + 2
      let opponentPoints = pointsToWin
      if (teamPoints >= pointsToWin - 1) {
        // Deuce scenario: winner needs forfeiting team's score + 2 to ensure 2-point lead
        opponentPoints = teamPoints + 2
      }

      // Award points until opponent wins
      const pointsNeeded = opponentPoints - currentOpponentPoints
      if (pointsNeeded > 0) {
        for (let i = 0; i < pointsNeeded; i++) {
          await logEvent('point', {
            team: opponentKey
          })
        }
      }

      // End the set
      await db.sets.update(currentSet.id, {
        finished: true,
        [opponentKey === 'home' ? 'homePoints' : 'awayPoints']: opponentPoints,
        [teamKey === 'home' ? 'homePoints' : 'awayPoints']: teamPoints
      })

      // Log set end
      await logEvent('set_end', {
        team: opponentKey,
        setIndex: currentSetIndex,
        homePoints: opponentKey === 'home' ? opponentPoints : teamPoints,
        awayPoints: opponentKey === 'away' ? opponentPoints : teamPoints,
        reason: 'forfait'
      })
    }

    // Award all remaining sets to opponent
    const remainingSets = allSets.filter(s => s.index > currentSetIndex && !s.finished)
    for (const set of remainingSets) {
      const setPointsToWin = set.index === 5 ? 15 : 25
      await db.sets.update(set.id, {
        finished: true,
        [opponentKey === 'home' ? 'homePoints' : 'awayPoints']: setPointsToWin,
        [teamKey === 'home' ? 'homePoints' : 'awayPoints']: 0
      })

      await logEvent('set_end', {
        team: opponentKey,
        setIndex: set.index,
        homePoints: opponentKey === 'home' ? setPointsToWin : 0,
        awayPoints: opponentKey === 'away' ? setPointsToWin : 0,
        reason: 'forfait'
      })
    }

    // Log forfait event
    await logEvent('forfait', {
      team: teamKey,
      reason: reason,
      setIndex: currentSetIndex
    })
  }, [data?.set, data?.match, matchId, logEvent])

  // Handle manual forfeit from "Stop the match" menu
  const handleManualForfeit = useCallback(async (teamKey) => {
    if (!data?.set || !data?.match) return

    // Use existing handleForfait logic
    await handleForfait(teamKey, 'forfeit')

    // Update match status to 'ended'
    await db.matches.update(matchId, { status: 'ended' })

    // Trigger backup
    onTriggerEventBackup?.('match_end')

    // Navigate to match end
    if (onFinishSet) onFinishSet(data.set)
  }, [data?.set, data?.match, matchId, handleForfait, onTriggerEventBackup, onFinishSet])

  // Handle "Impossibility to resume" - end match as-is without a winner
  const handleImpossibilityToResume = useCallback(async () => {
    if (!data?.set || !data?.match) return

    // Log match stopped event
    await logEvent('match_stopped', {
      reason: 'impossibility_to_resume',
      setIndex: data.set.index,
      homePoints: data.set.homePoints,
      awayPoints: data.set.awayPoints
    })

    // Update match status to 'ended' without declaring a winner
    await db.matches.update(matchId, {
      status: 'ended',
      stoppedReason: 'impossibility_to_resume'
    })

    // Trigger backup
    onTriggerEventBackup?.('match_end')

    // Download game data (same logic as menu export)
    try {
      const allMatches = await db.matches.toArray()
      const allTeams = await db.teams.toArray()
      const allPlayers = await db.players.toArray()
      const allSets = await db.sets.toArray()
      const allEvents = await db.events.toArray()
      const allReferees = await db.referees.toArray()
      const allScorers = await db.scorers.toArray()

      const exportData = {
        exportDate: new Date().toISOString(),
        matchId: matchId,
        matches: allMatches,
        teams: allTeams,
        players: allPlayers,
        sets: allSets,
        events: allEvents,
        referees: allReferees,
        scorers: allScorers
      }

      const jsonString = JSON.stringify(exportData, null, 2)
      const blob = new Blob([jsonString], { type: 'application/json' })
      const url = URL.createObjectURL(blob)
      const link = document.createElement('a')
      link.href = url
      link.download = `match_stopped_${matchId}_${new Date().toISOString().split('T')[0]}.json`
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
      URL.revokeObjectURL(url)
    } catch (error) {
      console.error('Error exporting match data:', error)
    }

    // Navigate to match end
    if (onFinishSet) onFinishSet(data.set)
  }, [data?.set, data?.match, matchId, logEvent, onTriggerEventBackup, onFinishSet])

  // Complete the stop match flow after remarks are recorded
  const completeStopMatchFlow = useCallback(async () => {
    if (!stopMatchRemarksStep) return

    const { type, team } = stopMatchRemarksStep

    if (type === 'forfeit' && team) {
      await handleManualForfeit(team)
    } else if (type === 'impossibility') {
      await handleImpossibilityToResume()
    }

    // Clear all stop match states
    setStopMatchModal(null)
    setStopMatchTeamSelect(null)
    setStopMatchConfirm(null)
    setStopMatchRemarksStep(null)
  }, [stopMatchRemarksStep, handleManualForfeit, handleImpossibilityToResume])

  // Handle exceptional substitution choice
  const handleExceptionalSubstitutionChoice = useCallback(async (choice) => {
    if (!exceptionalSubstitutionModal) return

    const { team, position, playerOut, reason } = exceptionalSubstitutionModal

    if (choice === 'exceptional') {
      // Show substitution dropdown with exceptional substitutes
      const exceptionalSubstitutes = getAvailableExceptionalSubstitutes(team, playerOut)
      if (exceptionalSubstitutes.length > 0) {
        // Find the court player element
        const courtPlayers = document.querySelectorAll('.court-player')
        let playerElement = null
        for (const el of courtPlayers) {
          const pos = el.querySelector('.court-player-position')?.textContent
          const num = el.textContent?.match(/\d+/)?.[0]
          if (pos === position && num === String(playerOut)) {
            playerElement = el
            break
          }
        }

        if (playerElement) {
          const rect = playerElement.getBoundingClientRect()
          setSubstitutionDropdown({
            team,
            position,
            playerNumber: playerOut,
            element: playerElement,
            x: rect.left + rect.width / 2,
            y: rect.bottom + 8,
            isExceptional: true,
            reason: reason
          })
        } else {
          setSubstitutionDropdown({
            team,
            position,
            playerNumber: playerOut,
            element: null,
            x: window.innerWidth / 2,
            y: window.innerHeight / 2,
            isExceptional: true,
            reason: reason
          })
        }
      }
      setExceptionalSubstitutionModal(null)
    } else if (choice === 'forfait') {
      // Handle forfait
      await handleForfait(team, reason)
      setExceptionalSubstitutionModal(null)
    }
  }, [exceptionalSubstitutionModal, getAvailableExceptionalSubstitutes, handleForfait])

  // Confirm substitution
  const confirmSubstitution = useCallback(async () => {
    if (!substitutionConfirm || !data?.set) return

    // MUTEX: Acquire lock before creating any events to prevent race conditions
    const maxWaitTime = 5000
    const startWait = Date.now()
    while (eventInProgressRef.current && (Date.now() - startWait) < maxWaitTime) {
      await new Promise(resolve => setTimeout(resolve, 10))
    }
    eventInProgressRef.current = true

    try {
      const { team, position, playerOut, playerIn, isInjury, isExceptional, isExpelled, isDisqualified } = substitutionConfirm

      // Get current lineup for this team in the current set
      // IMPORTANT: Sort by sequence number to get the most recent lineup event
      const lineupEvents = (data.events?.filter(e =>
        e.type === 'lineup' &&
        e.payload?.team === team &&
        e.setIndex === data.set.index
      ) || []).sort((a, b) => {
        // Sort by sequence number (same logic as getTeamLineupState)
        const aSeq = a.seq || 0
        const bSeq = b.seq || 0
        if (aSeq !== 0 || bSeq !== 0) {
          return aSeq - bSeq // Ascending
        }
        return new Date(a.ts) - new Date(b.ts)
      })

      const lineupEvent = lineupEvents.length > 0 ? lineupEvents[lineupEvents.length - 1] : null
      const currentLineup = lineupEvent?.payload?.lineup || {}

      // Create new lineup with substitution
      // First, clean currentLineup to ensure only valid positions
      const validPositions = ['I', 'II', 'III', 'IV', 'V', 'VI']
      const cleanedCurrentLineup = {}
      for (const pos of validPositions) {
        if (currentLineup[pos] !== undefined) {
          cleanedCurrentLineup[pos] = currentLineup[pos]
        }
      }

      const newLineup = { ...cleanedCurrentLineup }
      newLineup[position] = String(playerIn)

      // Ensure we only have exactly 6 positions (defensive check)
      const finalLineup = {}
      for (const pos of validPositions) {
        if (newLineup[pos] !== undefined) {
          finalLineup[pos] = newLineup[pos]
        }
      }

      // Preserve liberoSubstitution from the previous lineup event (if libero is on court)
      const existingLiberoSub = lineupEvent?.payload?.liberoSubstitution || null

      // Log the substitution event FIRST to get the main sequence number
      // (skipMutex: true because we already hold the mutex)
      const subSeq = await logEvent('substitution', {
        team,
        position,
        playerOut,
        playerIn,
        isExceptional: isExceptional || false,
        isExpelled: isExpelled || false,
        isDisqualified: isDisqualified || false
      }, { skipMutex: true })

      // Save the updated lineup as a SUB-EVENT (decimal sequence)
      // This ensures undo deletes both the substitution AND lineup together
      const subStateBefore = getStateSnapshot()
      const lineupPayload = { team, lineup: finalLineup, fromSubstitution: true }
      if (existingLiberoSub) {
        lineupPayload.liberoSubstitution = existingLiberoSub
      }
      const lineupSubEventSeq = subSeq + 0.1
      await db.events.add({
        matchId,
        setIndex: data.set.index,
        type: 'lineup',
        payload: lineupPayload,
        ts: new Date().toISOString(),
        seq: lineupSubEventSeq,
        stateBefore: subStateBefore
      })

      // Debug log: substitution
      debugLogger.log('SUBSTITUTION', {
        team,
        position,
        playerOut,
        playerIn,
        isExceptional,
        isExpelled,
        isDisqualified,
        newLineup: finalLineup
      }, getStateSnapshot())

      // If injury or exceptional substitution, add automatic remarks
      if ((isInjury || isExceptional) && data?.set) {
        const setIndex = data.set.index
        const teamLabel = team === teamAKey ? 'A' : 'B'

        // Current time (HHhMMm format) - use UTC for consistency
        const now = new Date()
        const timeStr = `${String(now.getUTCHours()).padStart(2, '0')}h${String(now.getUTCMinutes()).padStart(2, '0')}m`

        // Get current score - always put the interested team's score first
        const teamScore = team === 'home' ? data.set.homePoints : data.set.awayPoints
        const opponentScore = team === 'home' ? data.set.awayPoints : data.set.homePoints
        const scoreStr = `${teamScore}:${opponentScore}`

        let remark = ''
        if (isInjury) {
          remark = `Set ${setIndex}, Team ${teamLabel}, Time ${timeStr}, Score ${scoreStr}, Player #${playerOut} substituted due to injury`
        } else if (isExceptional) {
          remark = `Set ${setIndex}, Team ${teamLabel}, Time ${timeStr}, Score ${scoreStr}, Player #${playerOut} exceptionally substituted by Player #${playerIn}`
        }

        if (remark) {
          const currentRemarks = data?.match?.remarks || ''
          const newRemarks = currentRemarks ? `${currentRemarks}\n${remark}` : remark
          await db.matches.update(matchId, { remarks: newRemarks })
        }
      }

      setSubstitutionConfirm(null)
      setLiberoDropdown(null) // Close libero dropdown when confirming substitution

      // Add player to recently substituted list for flashing effect
      setRecentlySubstitutedPlayers(prev => [...prev, { team, playerNumber: playerIn, timestamp: Date.now() }])

      // Clear the flash after 3 seconds (unless start rally is clicked first)
      if (recentSubFlashTimeoutRef.current) {
        clearTimeout(recentSubFlashTimeoutRef.current)
      }
      recentSubFlashTimeoutRef.current = setTimeout(() => {
        setRecentlySubstitutedPlayers([])
      }, 3000)

      // Send substitution action to referee to show modal
      const teamName = team === 'home' ? data?.homeTeam?.shortName || data?.homeTeam?.name || 'Home' : data?.awayTeam?.shortName || data?.awayTeam?.name || 'Away'
      sendActionToReferee('substitution', {
        team,
        teamName,
        position,
        playerOut,
        playerIn,
        isExceptional: isExceptional || false
      })

      // Check if captain is on court after substitution
      // Check if the player leaving is the captain or court captain
      const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
      const leavingPlayer = teamPlayers?.find(p => String(p.number) === String(playerOut))
      const incomingPlayer = teamPlayers?.find(p => String(p.number) === String(playerIn))
      const isLeavingCaptain = leavingPlayer && (leavingPlayer.isCaptain || leavingPlayer.captain)
      const isIncomingCaptain = incomingPlayer && (incomingPlayer.isCaptain || incomingPlayer.captain)
      const captainOnCourtField = team === 'home' ? 'homeCourtCaptain' : 'awayCourtCaptain'
      const currentCourtCaptain = data?.match?.[captainOnCourtField]
      const isLeavingCourtCaptain = String(currentCourtCaptain) === String(playerOut)

      // Trigger captain check if:
      // - Captain is leaving (need to designate new game captain)
      // - Court captain is leaving (need to designate new game captain)
      // - Team captain is coming back in (need to clear game captain badge)
      if (isLeavingCaptain || isLeavingCourtCaptain || isIncomingCaptain) {
        setTimeout(() => {
          checkAndRequestCaptainOnCourtRef.current?.(team)
        }, 300)
      }

      // Check if this is an injury substitution for a libero - if so, log libero_unable and prompt for re-designation
      if (isInjury && playerOut) {
        const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
        const outPlayer = teamPlayers?.find(p => String(p.number) === String(playerOut))
        if (outPlayer && outPlayer.libero) {
          // Log libero_unable event with reason='injury' (skipMutex: we already hold it)
          await logEvent('libero_unable', {
            team,
            liberoNumber: playerOut,
            liberoType: outPlayer.libero,
            reason: 'injury'
          }, { skipMutex: true })
          // Check if redesignation is needed and prompt user
          // Use isLiberoUnable to properly check events, not just database field
          const activeLiberos = teamPlayers?.filter(p =>
            p.libero && p.libero !== '' && !isLiberoUnable(team, p.number) && Number(p.number) !== Number(playerOut)
          ) || []
          if (activeLiberos.length === 0) {
            // Use setTimeout to allow state to update first
            setTimeout(() => {
              setLiberoUnableModal({
                team,
                liberoNumber: playerOut,
                liberoType: outPlayer.libero,
                step: 'redesignate'
              })
            }, 100)
          }
        }
      }
    } finally {
      // MUTEX: Always release the lock, even if an error occurred
      eventInProgressRef.current = false
    }
  }, [substitutionConfirm, data?.set, data?.events, data?.match, data?.homePlayers, data?.awayPlayers, data?.homeTeam, data?.awayTeam, matchId, logEvent, teamAKey, checkLiberoRedesignation, sendActionToReferee])

  // Common modal position - all modals use the same position
  // For left side teams, menu opens to the right
  // For right side teams, menu opens to the left
  const getCommonModalPosition = useCallback((element, menuX, menuY, side) => {
    const rect = element?.getBoundingClientRect?.()
    const isRightSide = side === 'right'
    if (rect) {
      return {
        x: isRightSide ? rect.left - 30 : rect.right + 30,
        y: rect.top + rect.height / 2,
        side
      }
    }
    return {
      x: isRightSide ? menuX - 30 : menuX + 30,
      y: menuY,
      side
    }
  }, [])

  // Open substitution modal from action menu
  const openSubstitutionFromMenu = useCallback(() => {
    if (!playerActionMenu) return
    const { team, position, playerNumber } = playerActionMenu

    // Defensive check: ensure player can still be substituted
    if (!canPlayerBeSubstituted(team, playerNumber)) {
      showAlert('This player cannot be substituted (already completed a substitution cycle)', 'warning')
      setPlayerActionMenu(null)
      return
    }

    const { element, side } = playerActionMenu
    const pos = getCommonModalPosition(element, playerActionMenu.x, playerActionMenu.y, side)
    setSubstitutionDropdown({
      team,
      position,
      playerNumber,
      element,
      x: pos.x,
      y: pos.y,
      side: pos.side
    })
    setPlayerActionMenu(null)
  }, [playerActionMenu, getCommonModalPosition, canPlayerBeSubstituted])

  // Open libero modal from action menu
  const openLiberoFromMenu = useCallback(() => {
    if (!playerActionMenu) return
    const { team, position, playerNumber, element, side } = playerActionMenu
    const pos = getCommonModalPosition(element, playerActionMenu.x, playerActionMenu.y, side)
    setLiberoDropdown({
      team,
      position,
      playerNumber,
      element,
      x: pos.x,
      y: pos.y,
      side: pos.side
    })
    setPlayerActionMenu(null)
  }, [playerActionMenu, getCommonModalPosition])

  // Open sanction modal from action menu
  const openSanctionFromMenu = useCallback(() => {
    if (!playerActionMenu) return
    const { team, position, playerNumber, element, side } = playerActionMenu
    const pos = getCommonModalPosition(element, playerActionMenu.x, playerActionMenu.y, side)
    setSanctionDropdown({
      team,
      type: 'player',
      playerNumber,
      position,
      element,
      x: pos.x,
      y: pos.y,
      side: pos.side
    })
    setPlayerActionMenu(null)
  }, [playerActionMenu, getCommonModalPosition])

  // Open injury - same logic as expulsion/disqualification
  const openInjuryFromMenu = useCallback(async () => {
    if (!playerActionMenu || !data?.set) return
    const { team, position, playerNumber, element, side } = playerActionMenu

    // First, check if a legal substitution is possible (not exceptional)
    const legalSubstitutes = getAvailableSubstitutes(team, playerNumber, false)
    if (legalSubstitutes.length > 0) {
      // Legal substitution is possible - show substitution dropdown
      const pos = getCommonModalPosition(element, playerActionMenu.x, playerActionMenu.y, side)
      setSubstitutionDropdown({
        team,
        position,
        playerNumber,
        element,
        x: pos.x,
        y: pos.y,
        side: pos.side,
        isInjury: true
      })
      setPlayerActionMenu(null)
    } else {
      // No legal substitution possible - check for exceptional substitution
      const exceptionalSubstitutes = getAvailableExceptionalSubstitutes(team, playerNumber)
      if (exceptionalSubstitutes.length > 0) {
        // Show modal to choose between exceptional substitution or forfait
        setPlayerActionMenu(null)
        setExceptionalSubstitutionModal({
          team,
          position,
          playerOut: playerNumber,
          reason: 'injury'
        })
      } else {
        // No exceptional substitution possible - automatic forfait
        setPlayerActionMenu(null)
        await handleForfait(team, 'injury')
      }
    }
  }, [playerActionMenu, data?.set, getAvailableSubstitutes, getAvailableExceptionalSubstitutes, handleForfait, getCommonModalPosition])

  const cancelSubstitution = useCallback(() => {
    setSubstitutionDropdown(null)
    setLiberoDropdown(null) // Close both together
  }, [])

  const cancelSubstitutionConfirm = useCallback(() => {
    setSubstitutionConfirm(null)
    setLiberoDropdown(null) // Close libero dropdown when canceling substitution
  }, [])

  // Handle injury - same logic as expulsion/disqualification
  const handleInjury = useCallback(async () => {
    cLogger.logHandler('handleInjury', { team: injuryDropdown?.team, player: injuryDropdown?.playerNumber })
    if (!injuryDropdown || !data?.set) return

    const { team, position, playerNumber } = injuryDropdown

    // First, check if a legal substitution is possible (not exceptional)
    const legalSubstitutes = getAvailableSubstitutes(team, playerNumber, false)
    if (legalSubstitutes.length > 0) {
      // Legal substitution is possible - show substitution dropdown
      setInjuryDropdown(null)
      const rect = injuryDropdown.element?.getBoundingClientRect?.()
      if (rect) {
        setSubstitutionDropdown({
          team,
          position,
          playerNumber,
          element: injuryDropdown.element,
          x: rect.right - 8,
          y: rect.bottom + 8
        })
      }
    } else {
      // No legal substitution possible - check for exceptional substitution
      const exceptionalSubstitutes = getAvailableExceptionalSubstitutes(team, playerNumber)
      if (exceptionalSubstitutes.length > 0) {
        // Show modal to choose between exceptional substitution or forfait
        setInjuryDropdown(null)
        setExceptionalSubstitutionModal({
          team,
          position,
          playerOut: playerNumber,
          reason: 'injury'
        })
      } else {
        // No exceptional substitution possible - automatic forfait
        setInjuryDropdown(null)
        await handleForfait(team, 'injury')
      }
    }
  }, [injuryDropdown, data?.set, getAvailableSubstitutes, getAvailableExceptionalSubstitutes, handleForfait])

  // Cancel injury dropdown
  const cancelInjury = useCallback(() => {
    setInjuryDropdown(null)
  }, [])

  // Show sanction confirmation modal
  const showSanctionConfirm = useCallback((sanctionType) => {
    if (!sanctionDropdown) return
    setSanctionConfirmModal({
      team: sanctionDropdown.team,
      type: sanctionDropdown.type,
      playerNumber: sanctionDropdown.playerNumber,
      position: sanctionDropdown.position,
      role: sanctionDropdown.role,
      sanctionType
    })
    setSanctionDropdown(null)
  }, [sanctionDropdown])

  // Cancel sanction dropdown
  const cancelSanction = useCallback(() => {
    setSanctionDropdown(null)
  }, [])

  // Cancel sanction confirmation
  const cancelSanctionConfirm = useCallback(() => {
    setSanctionConfirmModal(null)
  }, [])

  // Check if a player has a specific sanction type
  const playerHasSanctionType = useCallback((teamKey, playerNumber, sanctionType) => {
    if (!data?.events) return false

    const hasSanction = data.events.some(e => {
      const isSanction = e.type === 'sanction'
      const teamMatch = e.payload?.team === teamKey
      const playerMatch = e.payload?.playerNumber === playerNumber ||
        String(e.payload?.playerNumber) === String(playerNumber) ||
        Number(e.payload?.playerNumber) === Number(playerNumber)
      const typeMatch = e.payload?.type === sanctionType

      return isSanction && teamMatch && playerMatch && typeMatch
    })

    return hasSanction
  }, [data?.events])

  // Get player's current highest sanction
  const getPlayerSanctionLevel = useCallback((teamKey, playerNumber) => {
    if (!data?.events) return null

    // Get all FORMAL sanctions for this player in this match
    // NOTE: delay_warning and delay_penalty are SEPARATE from the formal escalation path
    // A player can have delay warnings AND formal warnings independently
    // Convert playerNumber to both string and number for comparison (in case of type mismatch)
    const playerSanctions = data.events.filter(e => {
      const isSanction = e.type === 'sanction'
      const teamMatch = e.payload?.team === teamKey
      const playerMatch = e.payload?.playerNumber === playerNumber ||
        String(e.payload?.playerNumber) === String(playerNumber) ||
        Number(e.payload?.playerNumber) === Number(playerNumber)
      const isFormalSanction = ['warning', 'penalty', 'expulsion', 'disqualification'].includes(e.payload?.type)

      return isSanction && teamMatch && playerMatch && isFormalSanction
    })

    if (playerSanctions.length === 0) return null

    // Return the highest sanction level
    const levels = { warning: 1, penalty: 2, expulsion: 3, disqualification: 4 }
    const highest = playerSanctions.reduce((max, s) => {
      const level = levels[s.payload?.type] || 0
      return level > max ? level : max
    }, 0)

    const result = Object.keys(levels).find(key => levels[key] === highest)
    return result
  }, [data?.events])

  // Check if team has received a formal warning (only one per team per game)
  const teamHasFormalWarning = useCallback((teamKey) => {
    if (!data?.events) return false

    // Check all sets for this match for FORMAL warnings only
    // NOTE: delay_warning is separate and doesn't count as a formal warning
    const teamSanctions = data.events.filter(e =>
      e.type === 'sanction' &&
      e.payload?.team === teamKey &&
      e.payload?.type === 'warning' // This is formal warning, NOT delay_warning
    )

    return teamSanctions.length > 0
  }, [data?.events])

  // Get sanctions for a player or official
  const getPlayerSanctions = useCallback((teamKey, playerNumber, role = null) => {
    if (!data?.events) return []

    const sanctions = data.events.filter(e => {
      if (e.type !== 'sanction') return false
      if (e.payload?.team !== teamKey) return false

      // For player sanctions
      if (playerNumber !== null && playerNumber !== undefined) {
        // Convert both to strings for comparison to handle number/string mismatches
        const eventPlayerNumber = e.payload?.playerNumber
        const matchesPlayer = String(eventPlayerNumber) === String(playerNumber)
        const isFormalSanction = ['warning', 'penalty', 'expulsion', 'disqualification'].includes(e.payload?.type)
        return matchesPlayer && isFormalSanction
      }

      // For official sanctions
      if (role) {
        return e.payload?.role === role &&
          ['warning', 'penalty', 'expulsion', 'disqualification'].includes(e.payload?.type)
      }

      return false
    })

    return sanctions
  }, [data?.events])

  // Confirm player sanction
  const confirmPlayerSanction = useCallback(async () => {
    if (!sanctionConfirmModal || !data?.set) return

    const { team, type, playerNumber, position, role, sanctionType } = sanctionConfirmModal

    // Validate that we're not giving the same sanction type again
    if (playerNumber) {
      const hasThisSanction = playerHasSanctionType(team, playerNumber, sanctionType)
      const teamWarning = teamHasFormalWarning(team)

      // Prevent giving the same sanction type again
      if (hasThisSanction) {
        showAlert(`Player ${playerNumber} already has a ${sanctionType}. A player cannot receive the same sanction type twice.`, 'warning')
        setSanctionConfirmModal(null)
        return
      }

      // Special rule for warning: can only be given if team hasn't been warned (player can have other sanctions)
      if (sanctionType === 'warning' && teamWarning) {
        showAlert(`Warning cannot be given because the team has already been warned.`, 'warning')
        setSanctionConfirmModal(null)
        return
      }
    }

    // If expulsion or disqualification for a court player, need to handle substitution
    if ((sanctionType === 'expulsion' || sanctionType === 'disqualification') && type === 'player' && playerNumber && position) {
      // Log the sanction event first
      await logEvent('sanction', {
        team,
        type: sanctionType,
        playerType: type,
        playerNumber,
        position,
        role
      })

      // Check if this is a libero on court - if so, handle specially
      const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
      const player = teamPlayers?.find(p => String(p.number) === String(playerNumber))
      const isLiberoOnCourt = player && player.libero

      if (isLiberoOnCourt) {
        // Libero on court expelled/disqualified - return replaced player to court
        await logEvent('libero_unable', {
          team,
          liberoNumber: playerNumber,
          liberoType: player.libero,
          reason: sanctionType === 'expulsion' ? 'expulsion' : 'disqualification'
        })

        // Get current lineup and find the original player who was replaced by libero
        const lineupEvents = (data.events || [])
          .filter(e => e.type === 'lineup' && e.payload?.team === team && e.setIndex === data.set.index)
          .sort((a, b) => (a.seq || 0) - (b.seq || 0))

        if (lineupEvents.length > 0) {
          const currentLineup = { ...lineupEvents[lineupEvents.length - 1].payload?.lineup }

          // Get the original player who was replaced by libero
          const liberoEntryEvents = (data.events || [])
            .filter(e => e.type === 'libero_entry' && e.payload?.team === team && e.setIndex === data.set.index)
            .sort((a, b) => (b.seq || 0) - (a.seq || 0))

          const lastEntry = liberoEntryEvents.find(e => e.payload?.position === position)
          const originalPlayerNumber = lastEntry?.payload?.playerNumber

          if (originalPlayerNumber) {
            // Put original player back in
            currentLineup[position] = String(originalPlayerNumber)

            // Log the libero exit FIRST to get the main sequence number
            const libExitSeq = await logEvent('libero_exit', {
              team,
              position,
              liberoOut: playerNumber,
              playerIn: originalPlayerNumber,
              liberoType: player.libero,
              reason: sanctionType === 'expulsion' ? 'expulsion' : 'disqualification'
            })

            // Update lineup as a SUB-EVENT (decimal sequence) so undo deletes both together
            const lineupSubEventSeq = libExitSeq + 0.1
            await db.events.add({
              matchId,
              setIndex: data.set.index,
              type: 'lineup',
              payload: {
                team,
                lineup: currentLineup,
                fromSubstitution: true,
                liberoSubstitution: null
              },
              ts: new Date().toISOString(),
              seq: lineupSubEventSeq
            })
          }
        }

        // Close modal
        setSanctionConfirmModal(null)

        // Check if redesignation is needed and prompt user
        // Use isLiberoUnable to properly check events, not just database field
        const activeLiberos = teamPlayers?.filter(p =>
          p.libero && p.libero !== '' && !isLiberoUnable(team, p.number) && Number(p.number) !== Number(playerNumber)
        ) || []
        if (activeLiberos.length === 0) {
          setTimeout(() => {
            setLiberoUnableModal({
              team,
              liberoNumber: playerNumber,
              liberoType: player.libero,
              step: 'redesignate'
            })
          }, 100)
        }

        return // Exit early, don't do the regular substitution flow
      }

      // Regular player (not libero) on court - continue with normal flow

      // Close the confirmation modal
      setSanctionConfirmModal(null)

      // Check if the player being expelled/disqualified is the captain or court captain
      const sanctionedPlayer = teamPlayers?.find(p => String(p.number) === String(playerNumber))
      const isSanctionedCaptain = sanctionedPlayer && (sanctionedPlayer.isCaptain || sanctionedPlayer.captain)
      const captainOnCourtField = team === 'home' ? 'homeCourtCaptain' : 'awayCourtCaptain'
      const currentCourtCaptain = data?.match?.[captainOnCourtField]
      const isSanctionedCourtCaptain = String(currentCourtCaptain) === String(playerNumber)

      // First, check if a legal substitution is possible (not exceptional)
      const legalSubstitutes = getAvailableSubstitutes(team, playerNumber, false)
      if (legalSubstitutes.length === 1) {
        // Only one legal substitute - auto-select and show confirmation modal
        setSubstitutionConfirm({
          team,
          position,
          playerOut: playerNumber,
          playerIn: legalSubstitutes[0].number,
          isExpelled: sanctionType === 'expulsion',
          isDisqualified: sanctionType === 'disqualification'
        })
      } else if (legalSubstitutes.length > 1) {
        // Multiple legal substitutes - show substitution dropdown
        const courtPlayers = document.querySelectorAll('.court-player')
        let playerElement = null
        for (const el of courtPlayers) {
          const pos = el.querySelector('.court-player-position')?.textContent
          const num = el.textContent?.match(/\d+/)?.[0]
          if (pos === position && num === String(playerNumber)) {
            playerElement = el
            break
          }
        }

        if (playerElement) {
          const rect = playerElement.getBoundingClientRect()
          setSubstitutionDropdown({
            team,
            position,
            playerNumber,
            element: playerElement,
            x: rect.left + rect.width / 2,
            y: rect.bottom + 8,
            isExpelled: sanctionType === 'expulsion',
            isDisqualified: sanctionType === 'disqualification'
          })
        } else {
          setSubstitutionDropdown({
            team,
            position,
            playerNumber,
            element: null,
            x: window.innerWidth / 2,
            y: window.innerHeight / 2,
            isExpelled: sanctionType === 'expulsion',
            isDisqualified: sanctionType === 'disqualification'
          })
        }
      } else {
        // No legal substitution possible - check for exceptional substitution
        const exceptionalSubstitutes = getAvailableExceptionalSubstitutes(team, playerNumber)
        if (exceptionalSubstitutes.length > 0) {
          // Show modal to choose between exceptional substitution or forfait
          setExceptionalSubstitutionModal({
            team,
            position,
            playerOut: playerNumber,
            reason: sanctionType === 'expulsion' ? 'expulsion' : 'disqualification'
          })
        } else {
          // No exceptional substitution possible - automatic forfait
          await handleForfait(team, sanctionType === 'expulsion' ? 'expulsion' : 'disqualification')
        }
      }

      // Check if captain is on court after substitution (if substitution happened) or forfait
      if (isSanctionedCaptain || isSanctionedCourtCaptain) {
        setTimeout(() => {
          checkAndRequestCaptainOnCourtRef.current?.(team)
        }, 300)
      }
    } else if (sanctionType === 'expulsion' || sanctionType === 'disqualification') {
      // Check if this bench player is currently being replaced by a libero on court
      // Per FIVB Casebook: libero stays on court, substitute the bench player
      const liberoOnCourt = getLiberoOnCourt(team)
      if (type === 'bench' && liberoOnCourt && String(liberoOnCourt.playerNumber) === String(playerNumber)) {
        // This bench player is the one replaced by the libero
        // Log the sanction first
        await logEvent('sanction', {
          team,
          type: sanctionType,
          playerType: type,
          playerNumber,
          position,
          role
        })

        // Get legal substitutes for this player (based on their original position before libero replaced them)
        const legalSubs = getAvailableSubstitutes(team, playerNumber, false)

        if (legalSubs.length === 1) {
          // Auto-confirm with the single legal substitute
          setSanctionSubstitutionModal({
            team,
            expelledPlayer: playerNumber,
            liberoOnCourt,
            availableSubs: legalSubs,
            reason: sanctionType,
            isExceptional: false,
            position: liberoOnCourt.position
          })
        } else if (legalSubs.length > 1) {
          // Show modal to select from legal substitutes
          setSanctionSubstitutionModal({
            team,
            expelledPlayer: playerNumber,
            liberoOnCourt,
            availableSubs: legalSubs,
            reason: sanctionType,
            isExceptional: false,
            position: liberoOnCourt.position
          })
        } else {
          // No legal substitutes - check for exceptional substitutes
          const exceptionalSubs = getAvailableExceptionalSubstitutes(team, playerNumber)
          if (exceptionalSubs.length === 1) {
            // Auto-confirm with single exceptional substitute
            setSanctionSubstitutionModal({
              team,
              expelledPlayer: playerNumber,
              liberoOnCourt,
              availableSubs: exceptionalSubs,
              reason: sanctionType,
              isExceptional: true,
              position: liberoOnCourt.position
            })
          } else if (exceptionalSubs.length > 1) {
            // Show modal for exceptional substitute selection
            setSanctionSubstitutionModal({
              team,
              expelledPlayer: playerNumber,
              liberoOnCourt,
              availableSubs: exceptionalSubs,
              reason: sanctionType,
              isExceptional: true,
              position: liberoOnCourt.position
            })
          } else {
            // No substitutes at all - forfeit
            await handleForfait(team, sanctionType === 'expulsion' ? 'expulsion' : 'disqualification')
          }
        }

        setSanctionConfirmModal(null)
        return
      }

      // Expulsion/disqualification for bench players or officials - just log the sanction
      await logEvent('sanction', {
        team,
        type: sanctionType,
        playerType: type,
        playerNumber,
        position,
        role
      })

      setSanctionConfirmModal(null)

      // Check if this is a libero - if so, log libero_unable and prompt for re-designation
      if (type === 'libero' && playerNumber) {
        const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
        const liberoPlayer = teamPlayers?.find(p => String(p.number) === String(playerNumber))
        if (liberoPlayer && liberoPlayer.libero) {
          // Log libero_unable event with reason based on sanction type
          await logEvent('libero_unable', {
            team,
            liberoNumber: playerNumber,
            liberoType: liberoPlayer.libero,
            reason: sanctionType === 'expulsion' ? 'expulsion' : 'disqualification'
          })
          // Check if redesignation is needed and prompt user
          // Use isLiberoUnable to properly check events, not just database field
          const activeLiberos = teamPlayers?.filter(p =>
            p.libero && p.libero !== '' && !isLiberoUnable(team, p.number) && Number(p.number) !== Number(playerNumber)
          ) || []
          if (activeLiberos.length === 0) {
            setTimeout(() => {
              setLiberoUnableModal({
                team,
                liberoNumber: playerNumber,
                liberoType: liberoPlayer.libero,
                step: 'redesignate'
              })
            }, 100)
          }
        }
      }
    } else {
      // Regular sanction (warning or penalty)
      await logEvent('sanction', {
        team,
        type: sanctionType,
        playerType: type,
        playerNumber,
        position,
        role
      })

      // If penalty, award point to the other team (but only if lineups are set)
      if (sanctionType === 'penalty') {
        // Check if both lineups are set before awarding point
        const homeTeamKey = leftIsHome ? 'home' : 'away'
        const awayTeamKey = leftIsHome ? 'away' : 'home'

        const homeLineupSet = data.events?.some(e =>
          e.type === 'lineup' &&
          e.payload?.team === homeTeamKey &&
          e.setIndex === data.set.index &&
          e.payload?.isInitial
        )
        const awayLineupSet = data.events?.some(e =>
          e.type === 'lineup' &&
          e.payload?.team === awayTeamKey &&
          e.setIndex === data.set.index &&
          e.payload?.isInitial
        )

        setSanctionConfirmModal(null)

        if (homeLineupSet && awayLineupSet) {
          // Both lineups are set - award point immediately
          const otherTeam = team === 'home' ? 'away' : 'home'
          const otherSide = mapTeamKeyToSide(otherTeam)
          await handlePoint(otherSide)
        } else {
          // Lineups not set - show message
          showAlert('Penalty recorded. Point will be awarded after both teams set their lineups.', 'info')
        }
      } else {
        setSanctionConfirmModal(null)
      }
    }
  }, [sanctionConfirmModal, data?.set, data?.events, data?.homePlayers, data?.awayPlayers, logEvent, getAvailableSubstitutes, getAvailableExceptionalSubstitutes, mapTeamKeyToSide, handlePoint, leftIsHome, getPlayerSanctionLevel, playerHasSanctionType, teamHasFormalWarning, checkLiberoRedesignation, handleForfait, getLiberoOnCourt])

  // Handle sanction substitution when bench player (libero replacement) is expelled/disqualified
  // Per FIVB Casebook: libero stays on court, the expelled bench player is replaced by a substitute
  const handleSanctionSubstitution = useCallback(async (substituteNumber) => {
    if (!sanctionSubstitutionModal) return

    const { team, expelledPlayer, liberoOnCourt, reason, isExceptional, position } = sanctionSubstitutionModal

    // Log substitution event - this is recorded on scoresheet
    // The position is where the libero currently is (the expelled player's original position)
    const parentSeq = await logEvent('substitution', {
      team,
      position: position || liberoOnCourt?.position,
      playerOut: expelledPlayer,
      playerIn: substituteNumber,
      isExpelled: reason === 'expulsion',
      isDisqualified: reason === 'disqualification',
      isExceptional,
      isLiberoReplacementSub: true  // Flag to indicate this special case - libero stays on court
    })

    // Update the lineup's liberoSubstitution to point to new replacement player
    // This ensures when the libero exits, the new substitute comes to court instead of expelled player
    const currentSetIndex = data?.set?.index
    const lineupEvents = data?.events
      ?.filter(e => e.type === 'lineup' && e.payload?.team === team && e.setIndex === currentSetIndex)
      .sort((a, b) => (a.seq || 0) - (b.seq || 0))

    if (lineupEvents?.length > 0 && liberoOnCourt) {
      const lastLineup = lineupEvents[lineupEvents.length - 1]
      const currentLineup = { ...lastLineup.payload.lineup }

      // Update liberoSubstitution to point to new player
      const updatedLiberoSub = lastLineup.payload.liberoSubstitution ? {
        ...lastLineup.payload.liberoSubstitution,
        playerNumber: substituteNumber  // New replacement player
      } : {
        position: liberoOnCourt.position,
        liberoNumber: liberoOnCourt.liberoNumber,
        liberoType: liberoOnCourt.liberoType,
        playerNumber: substituteNumber
      }

      await logEvent('lineup', {
        team,
        lineup: currentLineup,
        liberoSubstitution: updatedLiberoSub
      }, { parentSeq })
    }

    // Add remarks if exceptional substitution
    if (isExceptional) {
      const remarkKey = `exceptionalSubstitution${team === 'home' ? 'Home' : 'Away'}`
      const existingRemarks = data?.match?.[remarkKey] || ''
      const newRemark = `Exp Sub: #${expelledPlayer}→#${substituteNumber} (${reason === 'expulsion' ? 'EXP' : 'DQ'}, libero on court)`
      await db.matches.update(matchId, {
        [remarkKey]: existingRemarks ? `${existingRemarks}; ${newRemark}` : newRemark
      })
    }

    setSanctionSubstitutionModal(null)
  }, [sanctionSubstitutionModal, data?.set, data?.events, data?.match, logEvent, matchId])

  // Execute libero substitution directly (no confirmation modal needed)
  const showLiberoConfirm = useCallback(async (liberoType) => {
    if (!liberoDropdown || !liberoType || !data?.set) return

    // MUTEX: Acquire lock before creating any events to prevent race conditions
    const maxWaitTime = 5000
    const startWait = Date.now()
    while (eventInProgressRef.current && (Date.now() - startWait) < maxWaitTime) {
      await new Promise(resolve => setTimeout(resolve, 10))
    }
    eventInProgressRef.current = true

    try {
      const team = liberoDropdown.team
      const position = liberoDropdown.position
      const playerOut = liberoDropdown.playerNumber

      // Validate that liberos can only enter back-row positions (I, V, VI)
      const isBackRow = position === 'I' || position === 'V' || position === 'VI'
      if (!isBackRow) {
        showAlert('Liberos can only enter back-row positions (I, V, VI)', 'warning')
        setLiberoDropdown(null)
        return
      }

      // Get libero player number
      const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
      const liberoPlayer = teamPlayers?.find(p => p.libero === liberoType)
      if (!liberoPlayer) {
        setLiberoDropdown(null)
        return
      }

      // Check if libero is unable to play
      if (isLiberoUnable(team, liberoPlayer.number)) {
        showAlert('This libero is unable to play (injured, expelled, disqualified, or declared unable)', 'warning')
        setLiberoDropdown(null)
        return
      }

      // Get current lineup for this team in the current set
      const lineupEvents = data.events?.filter(e =>
        e.type === 'lineup' &&
        e.payload?.team === team &&
        e.setIndex === data.set.index
      ) || []
      const lineupEvent = lineupEvents.length > 0 ? lineupEvents[lineupEvents.length - 1] : null
      const currentLineup = lineupEvent?.payload?.lineup || {}

      // Create new lineup with libero entry
      const validPositions = ['I', 'II', 'III', 'IV', 'V', 'VI']
      const cleanedCurrentLineup = {}
      for (const pos of validPositions) {
        if (currentLineup[pos] !== undefined) {
          cleanedCurrentLineup[pos] = currentLineup[pos]
        }
      }

      const newLineup = { ...cleanedCurrentLineup }
      newLineup[position] = String(liberoPlayer.number)

      const finalLineup = {}
      for (const pos of validPositions) {
        if (newLineup[pos] !== undefined) {
          finalLineup[pos] = newLineup[pos]
        }
      }

      // Log the libero entry event FIRST (main event) - skipMutex: we already hold it
      await logEvent('libero_entry', {
        team,
        position,
        playerOut,
        liberoIn: liberoPlayer.number,
        liberoType: liberoType
      }, { skipMutex: true })

      // Save the updated lineup as a SUB-EVENT (seq N.1) so it's deleted together with libero_entry on undo
      const allEvents = await db.events.where({ matchId }).toArray()
      const maxSeq = allEvents.length > 0 ? Math.max(...allEvents.map(e => e.seq || 0)) : 0
      const subEventSeq = Math.floor(maxSeq) + 0.1 // Sub-event of the libero_entry

      await db.events.add({
        matchId,
        setIndex: data.set.index,
        type: 'lineup',
        payload: {
          team,
          lineup: finalLineup,
          liberoSubstitution: {
            position,
            liberoNumber: liberoPlayer.number,
            playerNumber: playerOut,
            liberoType: liberoType
          }
        },
        ts: new Date().toISOString(),
        seq: subEventSeq
      })

      // Check if captain is on court after libero entry
      const leavingPlayer = teamPlayers?.find(p => String(p.number) === String(playerOut))
      const isLeavingCaptain = leavingPlayer && (leavingPlayer.isCaptain || leavingPlayer.captain)
      const captainOnCourtField = team === 'home' ? 'homeCourtCaptain' : 'awayCourtCaptain'
      const currentCourtCaptain = data?.match?.[captainOnCourtField]
      const isLeavingCourtCaptain = String(currentCourtCaptain) === String(playerOut)

      if (isLeavingCaptain || isLeavingCourtCaptain) {
        setTimeout(() => {
          checkAndRequestCaptainOnCourtRef.current?.(team)
        }, 300)
      }

      setLiberoDropdown(null)
      setSubstitutionDropdown(null)
    } finally {
      // MUTEX: Always release the lock, even if an error occurred
      eventInProgressRef.current = false
    }
  }, [liberoDropdown, data?.set, data?.events, data?.homePlayers, data?.awayPlayers, data?.match, matchId, logEvent, getNextSeq, isLiberoUnable])

  // Handle libero in player selection - directly execute substitution
  const handleLiberoInPlayerSelect = useCallback(async (position, playerNumber) => {
    if (!liberoInDropdown || !data?.set) return

    // MUTEX: Acquire lock before creating any events to prevent race conditions
    const maxWaitTime = 5000
    const startWait = Date.now()
    while (eventInProgressRef.current && (Date.now() - startWait) < maxWaitTime) {
      await new Promise(resolve => setTimeout(resolve, 10))
    }
    eventInProgressRef.current = true

    try {
      const { team } = liberoInDropdown

      // Get available liberos
      const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
      const liberos = teamPlayers?.filter(p => p.libero && p.libero !== '') || []
      const availableLiberos = liberos.filter(libero => !isLiberoUnable(team, libero.number))

      if (availableLiberos.length === 0) {
        showAlert('No available liberos', 'warning')
        setLiberoInDropdown(null)
        return
      }

      // If only one libero, use it; otherwise use the first available
      const liberoToUse = availableLiberos[0]

      // Liberos can only enter back row positions (I, V, VI)
      const liberoEntryPosition = 'I'

      // Get current lineup for this team in the current set
      const lineupEvents = data.events?.filter(e =>
        e.type === 'lineup' &&
        e.payload?.team === team &&
        e.setIndex === data.set.index
      ) || []
      const lineupEvent = lineupEvents.length > 0 ? lineupEvents[lineupEvents.length - 1] : null
      const currentLineup = lineupEvent?.payload?.lineup || {}

      // Create new lineup with libero entry
      const validPositions = ['I', 'II', 'III', 'IV', 'V', 'VI']
      const cleanedCurrentLineup = {}
      for (const pos of validPositions) {
        if (currentLineup[pos] !== undefined) {
          cleanedCurrentLineup[pos] = currentLineup[pos]
        }
      }

      const newLineup = { ...cleanedCurrentLineup }
      newLineup[liberoEntryPosition] = String(liberoToUse.number)

      const finalLineup = {}
      for (const pos of validPositions) {
        if (newLineup[pos] !== undefined) {
          finalLineup[pos] = newLineup[pos]
        }
      }

      // Log the libero entry event FIRST (main event) - skipMutex: we already hold it
      await logEvent('libero_entry', {
        team,
        position: liberoEntryPosition,
        playerOut: playerNumber,
        liberoIn: liberoToUse.number,
        liberoType: liberoToUse.libero
      }, { skipMutex: true })

      // Save the updated lineup as a SUB-EVENT (seq N.1) so it's deleted together with libero_entry on undo
      const allEventsForSeq = await db.events.where({ matchId }).toArray()
      const maxSeqForLibero = allEventsForSeq.length > 0 ? Math.max(...allEventsForSeq.map(e => e.seq || 0)) : 0
      const subEventSeqLibero = Math.floor(maxSeqForLibero) + 0.1

      await db.events.add({
        matchId,
        setIndex: data.set.index,
        type: 'lineup',
        payload: {
          team,
          lineup: finalLineup,
          liberoSubstitution: {
            position: liberoEntryPosition,
            liberoNumber: liberoToUse.number,
            playerNumber,
            liberoType: liberoToUse.libero
          }
        },
        ts: new Date().toISOString(),
        seq: subEventSeqLibero
      })

      // Check if captain is on court after libero entry
      const leavingPlayer = teamPlayers?.find(p => String(p.number) === String(playerNumber))
      const isLeavingCaptain = leavingPlayer && (leavingPlayer.isCaptain || leavingPlayer.captain)
      const captainOnCourtField = team === 'home' ? 'homeCourtCaptain' : 'awayCourtCaptain'
      const currentCourtCaptain = data?.match?.[captainOnCourtField]
      const isLeavingCourtCaptain = String(currentCourtCaptain) === String(playerNumber)

      if (isLeavingCaptain || isLeavingCourtCaptain) {
        setTimeout(() => {
          checkAndRequestCaptainOnCourtRef.current?.(team)
        }, 300)
      }

      setLiberoInDropdown(null)
    } finally {
      // MUTEX: Always release the lock, even if an error occurred
      eventInProgressRef.current = false
    }
  }, [liberoInDropdown, data?.set, data?.events, data?.homePlayers, data?.awayPlayers, data?.match, matchId, logEvent, getNextSeq, isLiberoUnable])

  // Confirm libero entry
  const confirmLibero = useCallback(async () => {
    if (!liberoConfirm || !data?.set) return

    // MUTEX: Acquire lock before creating any events to prevent race conditions
    const maxWaitTime = 5000
    const startWait = Date.now()
    while (eventInProgressRef.current && (Date.now() - startWait) < maxWaitTime) {
      await new Promise(resolve => setTimeout(resolve, 10))
    }
    eventInProgressRef.current = true

    try {
      const { team, position, playerOut, liberoIn, isExit, replacedPlayer } = liberoConfirm

      // Handle libero EXIT (libero out, original player returns)
      if (isExit) {
        // Check if there has been a point since last libero exchange
        if (!hasPointSinceLastLiberoExchange(team)) {
          showAlert('A point must be awarded before removing the libero', 'warning')
          setLiberoConfirm(null)
          return
        }

        // Get current lineup
        const lineupEvents = data.events?.filter(e =>
          e.type === 'lineup' &&
          e.payload?.team === team &&
          e.setIndex === data.set.index
        ) || []
        const currentLineup = lineupEvents[lineupEvents.length - 1]?.payload?.lineup || {}

        // Validate that libero is actually on court at the specified position
        const playerAtPosition = currentLineup[position]
        if (String(playerAtPosition) !== String(playerOut)) {
          console.error('[Libero Exit] VALIDATION FAILED: libero', playerOut,
            'is not at position', position, '- found', playerAtPosition, 'instead')
          showAlert(`Libero #${playerOut} is not at position ${position}. Cannot proceed with libero exit.`, 'error')
          setLiberoConfirm(null)
          return
        }

        // Get the libero type
        const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
        const liberoPlayer = teamPlayers?.find(p => String(p.number) === String(playerOut))
        const liberoType = liberoPlayer?.libero || 'libero1'

        // Use the replacedPlayer from liberoConfirm
        const originalPlayerNumber = replacedPlayer

        if (!originalPlayerNumber) {
          showAlert('Original player not found for this libero. Please update lineup manually.', 'error')
          setLiberoConfirm(null)
          return
        }

        // First, clean currentLineup to ensure only valid positions
        const validPositions = ['I', 'II', 'III', 'IV', 'V', 'VI']
        const cleanedCurrentLineup = {}
        for (const pos of validPositions) {
          if (currentLineup[pos] !== undefined) {
            cleanedCurrentLineup[pos] = currentLineup[pos]
          }
        }

        // Restore the original player
        const newLineup = { ...cleanedCurrentLineup }

        // Check if the original player is already on court in another position
        // If so, remove them from that position first to avoid duplicates
        for (const [pos, playerNum] of Object.entries(newLineup)) {
          if (String(playerNum) === String(originalPlayerNumber) && pos !== position) {
            // The original player is already in another position - remove them from there
            delete newLineup[pos]
            break
          }
        }

        // Now set the original player in the libero's position
        newLineup[position] = String(originalPlayerNumber)

        // Ensure we only have exactly 6 positions (defensive check)
        const finalLineup = {}
        for (const pos of validPositions) {
          if (newLineup[pos] !== undefined) {
            finalLineup[pos] = newLineup[pos]
          }
        }

        // Log the libero exit event FIRST (main event) - skipMutex: we already hold it
        await logEvent('libero_exit', {
          team,
          position,
          liberoOut: playerOut,
          playerIn: originalPlayerNumber,
          liberoType
        }, { skipMutex: true })

        // Save the updated lineup as a SUB-EVENT (seq N.1) so it's deleted together with libero_exit on undo
        const allEvents = await db.events.where({ matchId }).toArray()
        const maxSeq = allEvents.length > 0 ? Math.max(...allEvents.map(e => e.seq || 0)) : 0
        const subEventSeq = Math.floor(maxSeq) + 0.1 // Sub-event of the libero_exit

        await db.events.add({
          matchId,
          setIndex: data.set.index,
          type: 'lineup',
          payload: {
            team,
            lineup: finalLineup,
            fromSubstitution: true, // Mark as substitution so it's not treated as rotation lineup
            liberoSubstitution: null // Explicitly clear libero substitution
          },
          ts: new Date().toISOString(),
          seq: subEventSeq
        })

        // Check if the libero leaving is the court captain OR if the returning player is the team captain
        const returningPlayer = teamPlayers?.find(p => String(p.number) === String(originalPlayerNumber))
        const isReturningCaptain = returningPlayer && (returningPlayer.isCaptain || returningPlayer.captain)
        const captainOnCourtField = team === 'home' ? 'homeCourtCaptain' : 'awayCourtCaptain'
        const currentCourtCaptain = data?.match?.[captainOnCourtField]
        const isLiberoCourtCaptain = String(currentCourtCaptain) === String(playerOut)

        // Trigger captain check if:
        // - Libero leaving is the court captain
        // - Team captain is returning to court (need to clear game captain badge)
        if (isLiberoCourtCaptain || isReturningCaptain) {
          setTimeout(() => {
            checkAndRequestCaptainOnCourtRef.current?.(team)
          }, 300)
        }

        setLiberoConfirm(null)
        setLiberoDropdown(null)
        return
      }

      // Handle libero ENTRY (original code below)
      // Validate that liberos can only enter back-row positions (I, V, VI)
      const isBackRow = position === 'I' || position === 'V' || position === 'VI'
      if (!isBackRow) {
        showAlert('Liberos can only enter back-row positions (I, V, VI)', 'warning')
        setLiberoConfirm(null)
        setLiberoDropdown(null)
        return
      }

      // Get current lineup for this team in the current set
      const lineupEvents = data.events?.filter(e =>
        e.type === 'lineup' &&
        e.payload?.team === team &&
        e.setIndex === data.set.index
      ) || []
      const lineupEvent = lineupEvents.length > 0 ? lineupEvents[lineupEvents.length - 1] : null
      const currentLineup = lineupEvent?.payload?.lineup || {}

      // Get libero player number
      const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
      const liberoPlayer = teamPlayers?.find(p => p.libero === liberoIn)
      if (!liberoPlayer) {
        return
      }

      // Check if libero is unable to play
      if (isLiberoUnable(team, liberoPlayer.number)) {
        showAlert('This libero is unable to play (injured, expelled, disqualified, or declared unable)', 'warning')
        setLiberoConfirm(null)
        setLiberoDropdown(null)
        return
      }

      // VALIDATION: Ensure playerOut is actually at the specified position
      const playerAtPosition = currentLineup[position]
      if (String(playerAtPosition) !== String(playerOut)) {
        console.error('[Libero Entry] VALIDATION FAILED: playerOut', playerOut,
          'is not at position', position, '- found', playerAtPosition, 'instead')
        showAlert(`Player #${playerOut} is not at position ${position}. Cannot proceed with libero entry.`, 'error')
        setLiberoConfirm(null)
        setLiberoDropdown(null)
        return
      }

      // VALIDATION: Ensure playerOut is not already a libero
      const playerOutInfo = teamPlayers?.find(p => String(p.number) === String(playerOut))
      if (playerOutInfo?.libero && playerOutInfo.libero !== '') {
        console.error('[Libero Entry] VALIDATION FAILED: playerOut', playerOut, 'is a libero')
        showAlert(`Player #${playerOut} is a libero. Liberos cannot be replaced by other liberos.`, 'warning')
        setLiberoConfirm(null)
        setLiberoDropdown(null)
        return
      }

      // VALIDATION: Check if there's already a libero substitution for this team
      // and if so, ensure we're not creating conflicting tracking
      const existingLiberoSub = lineupEvent?.payload?.liberoSubstitution
      if (existingLiberoSub) {
        // There's already a libero on court - this libero entry should be a libero exchange
        // or the existing libero should have exited first
        console.warn('[Libero Entry] Another libero is already on court:',
          existingLiberoSub, '- this may cause tracking issues')
      }

      console.log('[Libero Entry] Validation passed:', {
        position,
        playerOut,
        liberoIn: liberoPlayer.number,
        currentLineup,
        existingLiberoSub
      })

      // Create new lineup with libero entry
      // First, clean currentLineup to ensure only valid positions
      const validPositions = ['I', 'II', 'III', 'IV', 'V', 'VI']
      const cleanedCurrentLineup = {}
      for (const pos of validPositions) {
        if (currentLineup[pos] !== undefined) {
          cleanedCurrentLineup[pos] = currentLineup[pos]
        }
      }

      const newLineup = { ...cleanedCurrentLineup }
      newLineup[position] = String(liberoPlayer.number)

      // Ensure we only have exactly 6 positions (defensive check)
      const finalLineup = {}
      for (const pos of validPositions) {
        if (newLineup[pos] !== undefined) {
          finalLineup[pos] = newLineup[pos]
        }
      }

      // Log the libero entry event FIRST (main event) - skipMutex: we already hold it
      await logEvent('libero_entry', {
        team,
        position,
        playerOut,
        liberoIn: liberoPlayer.number,
        liberoType: liberoIn
      }, { skipMutex: true })

      // Save the updated lineup as a SUB-EVENT (seq N.1) so it's deleted together with libero_entry on undo
      const allEventsEntry = await db.events.where({ matchId }).toArray()
      const maxSeqEntry = allEventsEntry.length > 0 ? Math.max(...allEventsEntry.map(e => e.seq || 0)) : 0
      const subEventSeqEntry = Math.floor(maxSeqEntry) + 0.1

      await db.events.add({
        matchId,
        setIndex: data.set.index,
        type: 'lineup',
        payload: {
          team,
          lineup: finalLineup,
          liberoSubstitution: {
            position,
            liberoNumber: liberoPlayer.number,
            playerNumber: playerOut,
            liberoType: liberoIn
          }
        },
        ts: new Date().toISOString(),
        seq: subEventSeqEntry
      })

      // Debug log: libero entry
      debugLogger.log('LIBERO_ENTRY', {
        team,
        position,
        playerOut,
        liberoIn: liberoPlayer.number,
        liberoType: liberoIn,
        newLineup: finalLineup
      }, getStateSnapshot())

      setLiberoConfirm(null)

      // Check if captain is on court after libero entry
      // The playerOut is leaving, check if they're captain
      // Reuse teamPlayers variable already declared above
      const leavingPlayer = teamPlayers?.find(p => String(p.number) === String(playerOut))
      const isLeavingCaptain = leavingPlayer && (leavingPlayer.isCaptain || leavingPlayer.captain)
      const captainOnCourtField = team === 'home' ? 'homeCourtCaptain' : 'awayCourtCaptain'
      const currentCourtCaptain = data?.match?.[captainOnCourtField]
      const isLeavingCourtCaptain = String(currentCourtCaptain) === String(playerOut)

      if (isLeavingCaptain || isLeavingCourtCaptain) {
        setTimeout(() => {
          checkAndRequestCaptainOnCourtRef.current?.(team)
        }, 300)
      }
      setSubstitutionDropdown(null) // Close substitution dropdown if open
      setLiberoDropdown(null) // Close libero dropdown if open
    } finally {
      // MUTEX: Always release the lock, even if an error occurred
      eventInProgressRef.current = false
    }
  }, [liberoConfirm, data?.set, data?.events, data?.homePlayers, data?.awayPlayers, matchId, logEvent, getNextSeq, isLiberoUnable])

  const cancelLibero = useCallback(() => {
    setLiberoDropdown(null)
    setSubstitutionDropdown(null) // Close both together
  }, [])

  const cancelLiberoConfirm = useCallback(() => {
    setLiberoConfirm(null)
    setSubstitutionDropdown(null) // Close substitution dropdown if open
    setLiberoDropdown(null) // Close libero dropdown if open
  }, [])

  // Handle libero reentry (when opposite player is in position I and not serving)
  const confirmLiberoReentry = useCallback(async () => {
    if (!liberoReentryModal || !data?.set) return

    // MUTEX: Acquire lock before creating any events to prevent race conditions
    const maxWaitTime = 5000
    const startWait = Date.now()
    while (eventInProgressRef.current && (Date.now() - startWait) < maxWaitTime) {
      await new Promise(resolve => setTimeout(resolve, 10))
    }
    eventInProgressRef.current = true

    try {
      // Use the selected libero from availableLiberos if present, otherwise use the original values
      const { team, position, playerNumber, availableLiberos, selectedLiberoIndex } = liberoReentryModal
      const selectedLibero = availableLiberos && availableLiberos[selectedLiberoIndex]
      const liberoNumber = selectedLibero ? selectedLibero.number : liberoReentryModal.liberoNumber
      const liberoType = selectedLibero ? selectedLibero.type : liberoReentryModal.liberoType

      // Check if libero is unable to play
      if (isLiberoUnable(team, liberoNumber)) {
        showAlert('This libero is unable to play (injured, expelled, disqualified, or declared unable)', 'warning')
        setLiberoReentryModal(null)
        return
      }

      const playerOut = playerNumber // For consistency with other libero entry logic

      // Get current lineup for this team in the current set
      const lineupEvents = data.events?.filter(e =>
        e.type === 'lineup' &&
        e.payload?.team === team &&
        e.setIndex === data.set.index
      ) || []
      const lineupEvent = lineupEvents.length > 0 ? lineupEvents[lineupEvents.length - 1] : null
      const currentLineup = lineupEvent?.payload?.lineup || {}

      // Create new lineup with libero re-entry
      // First, clean currentLineup to ensure only valid positions
      const validPositions = ['I', 'II', 'III', 'IV', 'V', 'VI']
      const cleanedCurrentLineup = {}
      for (const pos of validPositions) {
        if (currentLineup[pos] !== undefined) {
          cleanedCurrentLineup[pos] = currentLineup[pos]
        }
      }

      const newLineup = { ...cleanedCurrentLineup }
      newLineup[position] = String(liberoNumber)

      // Ensure we only have exactly 6 positions (defensive check)
      const finalLineup = {}
      for (const pos of validPositions) {
        if (newLineup[pos] !== undefined) {
          finalLineup[pos] = newLineup[pos]
        }
      }

      // Log the libero entry event FIRST (main event) - skipMutex: we already hold it
      await logEvent('libero_entry', {
        team,
        position,
        playerOut,
        liberoIn: liberoNumber,
        liberoType: liberoType
      }, { skipMutex: true })

      // Save the updated lineup as a SUB-EVENT (seq N.1) so it's deleted together with libero_entry on undo
      const allEvents = await db.events.where({ matchId }).toArray()
      const maxSeq = allEvents.length > 0 ? Math.max(...allEvents.map(e => e.seq || 0)) : 0
      const subEventSeq = Math.floor(maxSeq) + 0.1 // Sub-event of the libero_entry

      await db.events.add({
        matchId,
        setIndex: data.set.index,
        type: 'lineup',
        payload: {
          team,
          lineup: finalLineup,
          liberoSubstitution: {
            position,
            liberoNumber: liberoNumber,
            playerNumber: playerOut,
            liberoType: liberoType
          }
        },
        ts: new Date().toISOString(),
        seq: subEventSeq
      })

      // Debug log: libero reentry
      debugLogger.log('LIBERO_REENTRY', {
        team,
        position,
        playerOut,
        liberoIn: liberoNumber,
        liberoType,
        newLineup: finalLineup
      }, getStateSnapshot())

      // Clear dismissed state since libero is entering - allow suggestion again if they exit
      setLiberoSuggestionDismissedForExit(prev => ({
        ...prev,
        [team]: null
      }))

      setLiberoReentryModal(null)

      // Check if captain is on court after libero reentry (playerOut is leaving)
      const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
      const leavingPlayer = teamPlayers?.find(p => String(p.number) === String(playerOut))
      const isLeavingCaptain = leavingPlayer && (leavingPlayer.isCaptain || leavingPlayer.captain)
      const captainOnCourtField = team === 'home' ? 'homeCourtCaptain' : 'awayCourtCaptain'
      const currentCourtCaptain = data?.match?.[captainOnCourtField]
      const isLeavingCourtCaptain = String(currentCourtCaptain) === String(playerOut)

      if (isLeavingCaptain || isLeavingCourtCaptain) {
        setTimeout(() => {
          checkAndRequestCaptainOnCourtRef.current?.(team)
        }, 300)
      }
    } finally {
      // MUTEX: Always release the lock, even if an error occurred
      eventInProgressRef.current = false
    }
  }, [liberoReentryModal, data?.set, data?.events, data?.homePlayers, data?.awayPlayers, data?.match, matchId, logEvent, isLiberoUnable])

  const cancelLiberoReentry = useCallback(() => {
    // Track that we dismissed the suggestion for this specific libero exit
    // so we don't show it again until a new libero exit happens
    if (liberoReentryModal) {
      const team = liberoReentryModal.team
      const exitEvent = data.events.filter(e =>
        e.type === 'libero_exit' &&
        e.payload?.team === team &&
        e.setIndex === data.set.index &&
        e.payload?.reason === 'rotation_to_front_row'
      ).sort((a, b) => new Date(b.ts) - new Date(a.ts))[0]

      if (exitEvent) {
        setLiberoSuggestionDismissedForExit(prev => ({
          ...prev,
          [team]: exitEvent.ts
        }))
      }
    }
    setLiberoReentryModal(null)
  }, [liberoReentryModal, data?.events, data?.set?.index])

  // Handle libero out
  const handleLiberoOut = useCallback(async (side) => {
    if (rallyStatus !== 'idle') return

    // MUTEX: Acquire lock before creating any events to prevent race conditions
    const maxWaitTime = 5000
    const startWait = Date.now()
    while (eventInProgressRef.current && (Date.now() - startWait) < maxWaitTime) {
      await new Promise(resolve => setTimeout(resolve, 10))
    }
    eventInProgressRef.current = true

    try {
      const teamKey = mapSideToTeamKey(side)
      const liberoOnCourt = getLiberoOnCourt(teamKey)

      if (!liberoOnCourt) {
        showAlert('No libero is currently on court', 'warning')
        return
      }

      // Check if there has been a point since last libero exchange
      if (!hasPointSinceLastLiberoExchange(teamKey)) {
        showAlert('A point must be awarded before removing the libero', 'warning')
        return
      }

      // Get current lineup
      const lineupEvents = data.events.filter(e =>
        e.type === 'lineup' &&
        e.payload?.team === teamKey &&
        e.setIndex === data.set.index
      )
      const currentLineup = lineupEvents[lineupEvents.length - 1]?.payload?.lineup || {}

      // Determine the original player that should replace the libero
      let originalPlayerNumber = liberoOnCourt.playerNumber
      if (!originalPlayerNumber && lineupEvents.length > 0) {
        // Look through previous lineup events to find the most recent non-libero player at this position
        const sortedLineupEvents = [...lineupEvents].sort((a, b) => new Date(b.ts) - new Date(a.ts)) // Most recent first
        const teamPlayers = teamKey === 'home' ? data.homePlayers : data.awayPlayers
        for (const event of sortedLineupEvents) {
          const lineup = event.payload?.lineup
          if (!lineup) continue
          const playerNumberAtPosition = lineup[liberoOnCourt.position]
          if (!playerNumberAtPosition) continue
          if (String(playerNumberAtPosition) !== String(liberoOnCourt.liberoNumber)) {
            originalPlayerNumber = Number(playerNumberAtPosition)
            break
          }
          // If this event has libero substitution info, use the stored original player
          if (event.payload?.liberoSubstitution &&
            String(event.payload.liberoSubstitution.liberoNumber) === String(liberoOnCourt.liberoNumber) &&
            event.payload.liberoSubstitution.position === liberoOnCourt.position) {
            originalPlayerNumber = event.payload.liberoSubstitution.playerNumber
            break
          }
        }
      }

      if (!originalPlayerNumber) {
        showAlert('Original player not found for this libero. Please update lineup manually.', 'error')
        return
      }

      // First, clean currentLineup to ensure only valid positions
      const validPositions = ['I', 'II', 'III', 'IV', 'V', 'VI']
      const cleanedCurrentLineup = {}
      for (const pos of validPositions) {
        if (currentLineup[pos] !== undefined) {
          cleanedCurrentLineup[pos] = currentLineup[pos]
        }
      }

      // Restore the original player
      const newLineup = { ...cleanedCurrentLineup }

      // Check if the original player is already on court in another position
      // If so, remove them from that position first to avoid duplicates
      for (const [pos, playerNum] of Object.entries(newLineup)) {
        if (String(playerNum) === String(originalPlayerNumber) && pos !== liberoOnCourt.position) {
          // The original player is already in another position - remove them from there
          // This can happen if the team rotated while the libero was in
          delete newLineup[pos]
          break
        }
      }

      // Now set the original player in the libero's position
      newLineup[liberoOnCourt.position] = String(originalPlayerNumber)

      // Ensure we only have exactly 6 positions (defensive check)
      const finalLineup = {}
      for (const pos of validPositions) {
        if (newLineup[pos] !== undefined) {
          finalLineup[pos] = newLineup[pos]
        }
      }

      // Log the libero exit event FIRST (main event) - skipMutex: we already hold it
      await logEvent('libero_exit', {
        team: teamKey,
        position: liberoOnCourt.position,
        liberoOut: liberoOnCourt.liberoNumber,
        playerIn: originalPlayerNumber,
        liberoType: liberoOnCourt.liberoType
      }, { skipMutex: true })

      // Save the updated lineup as a SUB-EVENT (seq N.1) so it's deleted together with libero_exit on undo
      const allEvents = await db.events.where({ matchId }).toArray()
      const maxSeq = allEvents.length > 0 ? Math.max(...allEvents.map(e => e.seq || 0)) : 0
      const subEventSeq = Math.floor(maxSeq) + 0.1 // Sub-event of the libero_exit

      await db.events.add({
        matchId,
        setIndex: data.set.index,
        type: 'lineup',
        payload: {
          team: teamKey,
          lineup: finalLineup,
          fromSubstitution: true, // Mark as substitution so it's not treated as rotation lineup
          liberoSubstitution: null // Explicitly clear libero substitution
        },
        ts: new Date().toISOString(),
        seq: subEventSeq
      })

      // Check if the libero leaving is the court captain OR if the returning player is the team captain
      const teamPlayers = teamKey === 'home' ? data?.homePlayers : data?.awayPlayers
      const returningPlayer = teamPlayers?.find(p => String(p.number) === String(originalPlayerNumber))
      const isReturningCaptain = returningPlayer && (returningPlayer.isCaptain || returningPlayer.captain)
      const captainOnCourtField = teamKey === 'home' ? 'homeCourtCaptain' : 'awayCourtCaptain'
      const currentCourtCaptain = data?.match?.[captainOnCourtField]
      const isLiberoCourtCaptain = String(currentCourtCaptain) === String(liberoOnCourt.liberoNumber)

      // Trigger captain check if:
      // - Libero leaving is the court captain
      // - Team captain is returning to court (need to clear game captain badge)
      if (isLiberoCourtCaptain || isReturningCaptain) {
        setTimeout(() => {
          checkAndRequestCaptainOnCourtRef.current?.(teamKey)
        }, 300)
      }
    } finally {
      // MUTEX: Always release the lock, even if an error occurred
      eventInProgressRef.current = false
    }
  }, [rallyStatus, mapSideToTeamKey, getLiberoOnCourt, hasPointSinceLastLiberoExchange, data?.events, data?.set, data?.match, matchId, logEvent, data?.homePlayers, data?.awayPlayers])

  // Handle libero re-designation
  const confirmLiberoRedesignation = useCallback(async (newLiberoNumber) => {
    if (!liberoRedesignationModal || !data?.set) return

    const { team, unableLiberoNumber, unableLiberoType, reason = 'declared' } = liberoRedesignationModal

    // Log the libero_unable event if not already logged (with reason='declared' if not specified)
    const hasUnableEvent = data?.events?.some(e =>
      e.type === 'libero_unable' &&
      e.payload?.team === team &&
      e.payload?.liberoNumber === unableLiberoNumber
    )

    if (!hasUnableEvent) {
      await logEvent('libero_unable', {
        team,
        liberoNumber: unableLiberoNumber,
        liberoType: unableLiberoType,
        reason: 'declared' // Default to declared if not specified
      })
    }

    // Log the re-designation event
    await logEvent('libero_redesignation', {
      team,
      unableLiberoNumber,
      unableLiberoType,
      newLiberoNumber,
      reason
    })

    // Update the player records: remove libero status from old player, add to new player
    const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
    const teamId = team === 'home' ? data?.match?.homeTeamId : data?.match?.awayTeamId

    if (teamId) {
      // Find the old libero and new player
      const oldLiberoPlayer = teamPlayers?.find(p => Number(p.number) === Number(unableLiberoNumber))
      const newLiberoPlayer = teamPlayers?.find(p => Number(p.number) === Number(newLiberoNumber))

      // Update old libero - mark as unable (out for rest of game)
      if (oldLiberoPlayer?.id) {
        await db.players.update(oldLiberoPlayer.id, { libero: 'unable' })
      }

      // Update new player - mark as redesignated libero (only one allowed per team)
      if (newLiberoPlayer?.id) {
        await db.players.update(newLiberoPlayer.id, { libero: 'redesignated' })
      }
    }

    // Record in remarks
    const teamLabel = team === teamAKey ? 'A' : 'B'
    const setIndex = data.set.index

    // Get current score: left = team involved, right = other team
    const teamPoints = team === 'home' ? data.set.homePoints : data.set.awayPoints
    const otherPoints = team === 'home' ? data.set.awayPoints : data.set.homePoints
    const scoreStr = `${teamPoints}:${otherPoints}`

    // Get actual time of day (HHhMMm format, no seconds) - use UTC for consistency
    const currentTime = new Date()
    const hours = String(currentTime.getUTCHours()).padStart(2, '0')
    const minutes = String(currentTime.getUTCMinutes()).padStart(2, '0')
    const timeStr = `${hours}h${minutes}m`

    const remark = `Set ${setIndex}, Team ${teamLabel}, Time ${timeStr}, Score ${scoreStr}, Player #${newLiberoNumber} re-designated as Libero (replacing ${unableLiberoNumber})`
    const currentRemarks = data?.match?.remarks || ''
    const newRemarks = currentRemarks ? `${currentRemarks}\n${remark}` : remark
    await db.matches.update(matchId, { remarks: newRemarks })

    setLiberoRedesignationModal(null)
  }, [liberoRedesignationModal, data?.set, data?.events, data?.match, data?.homePlayers, data?.awayPlayers, logEvent, teamAKey, matchId])

  // Confirm marking libero as unable
  const confirmLiberoUnable = useCallback(async () => {
    if (!liberoUnableModal || !data?.set) return

    const { team, liberoNumber, liberoType, reason = 'declared', isOnCourt } = liberoUnableModal

    try {
      // If libero is on court, force them out first
      if (isOnCourt) {
        const liberoOnCourt = getLiberoOnCourt(team)
        if (liberoOnCourt) {
          // Get current lineup
          const lineupEvents = (data.events || [])
            .filter(e => e.type === 'lineup' && e.payload?.team === team && e.setIndex === data.set.index)
            .sort((a, b) => (a.seq || 0) - (b.seq || 0))

          if (lineupEvents.length > 0) {
            const currentLineup = { ...lineupEvents[lineupEvents.length - 1].payload?.lineup }
            const position = liberoOnCourt.position
            const originalPlayerNumber = liberoOnCourt.playerNumber

            if (originalPlayerNumber) {
              // Put original player back in
              currentLineup[position] = String(originalPlayerNumber)

              // Log the libero exit FIRST to get the main sequence number
              const libExitSeq = await logEvent('libero_exit', {
                team,
                position,
                liberoOut: liberoNumber,
                playerIn: originalPlayerNumber,
                liberoType,
                reason: 'unable'
              })

              // Update lineup as a SUB-EVENT (decimal sequence) so undo deletes both together
              const lineupSubEventSeq = libExitSeq + 0.1
              await db.events.add({
                matchId,
                setIndex: data.set.index,
                type: 'lineup',
                payload: {
                  team,
                  lineup: currentLineup,
                  fromSubstitution: true,
                  liberoSubstitution: null
                },
                ts: new Date().toISOString(),
                seq: lineupSubEventSeq
              })
            }
          }
        }
      }

      // Mark libero as unable (declared by coach or injury)
      await logEvent('libero_unable', {
        team,
        liberoNumber,
        liberoType,
        reason
      })

      // Add automatic remark for libero unable
      if (data?.set) {
        const setIndex = data.set.index
        const teamLabel = team === teamAKey ? 'A' : 'B'

        // Current time (HHhMMm format) - use UTC for consistency
        const now = new Date()
        const timeStr = `${String(now.getUTCHours()).padStart(2, '0')}h${String(now.getUTCMinutes()).padStart(2, '0')}m`

        // Get current score - always put the interested team's score first
        const teamScore = team === 'home' ? data.set.homePoints : data.set.awayPoints
        const opponentScore = team === 'home' ? data.set.awayPoints : data.set.homePoints
        const scoreStr = `${teamScore}:${opponentScore}`

        const reasonText = reason === 'injury' ? 'becomes unable to play (injury)' : 'declared unable to play'
        const remark = `Set ${setIndex}, Team ${teamLabel}, Time ${timeStr}, Score ${scoreStr}, Libero #${liberoNumber} ${reasonText}`

        const currentRemarks = data?.match?.remarks || ''
        const newRemarks = currentRemarks ? `${currentRemarks}\n${remark}` : remark
        await db.matches.update(matchId, { remarks: newRemarks })
      }

      // Check if redesignation is needed - if so, show prompt in same modal
      const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
      const activeLiberos = teamPlayers?.filter(p =>
        p.libero && p.libero !== 'unable' && p.number !== liberoNumber
      ) || []

      if (activeLiberos.length === 0) {
        // Show redesignation prompt in same modal
        setLiberoUnableModal({
          ...liberoUnableModal,
          step: 'redesignate'
        })
      } else {
        setLiberoUnableModal(null)
      }
    } catch (error) {
      // Silently handle error
    }
  }, [liberoUnableModal, data?.set, data?.events, data?.match?.remarks, logEvent, checkLiberoRedesignation, getLiberoOnCourt, teamAKey, teamBKey, matchId])

  // Handle libero in button click
  const handleLiberoIn = useCallback((side, event) => {
    if (rallyStatus !== 'idle') return

    const teamKey = mapSideToTeamKey(side)
    const teamPlayers = teamKey === 'home' ? data?.homePlayers : data?.awayPlayers
    const liberos = teamPlayers?.filter(p => p.libero && p.libero !== '') || []

    // Check if a libero is already on court
    const liberoOnCourt = getLiberoOnCourt(teamKey)
    if (liberoOnCourt) {
      showAlert('A libero is already on court', 'warning')
      return
    }

    // Check if team has any liberos
    if (liberos.length === 0) {
      showAlert('No liberos available', 'warning')
      return
    }

    // Check if any libero is available (not unable)
    const availableLiberos = liberos.filter(libero => !isLiberoUnable(teamKey, libero.number))
    if (availableLiberos.length === 0) {
      showAlert('No available liberos (all are unable to play)', 'warning')
      return
    }

    // Get button position for dropdown
    const rect = event.currentTarget.getBoundingClientRect()
    setLiberoInDropdown({
      team: teamKey,
      side: side,
      element: event.currentTarget,
      x: rect.left + rect.width / 2,
      y: rect.bottom + 8
    })
  }, [rallyStatus, data?.homePlayers, data?.awayPlayers, getLiberoOnCourt, isLiberoUnable, mapSideToTeamKey, getCurrentServe, getTeamLineupState])

  // Handle exchange libero (L1 <-> L2)
  const handleExchangeLibero = useCallback(async (side) => {
    if (rallyStatus !== 'idle') return

    // MUTEX: Acquire lock before creating any events to prevent race conditions
    const maxWaitTime = 5000
    const startWait = Date.now()
    while (eventInProgressRef.current && (Date.now() - startWait) < maxWaitTime) {
      await new Promise(resolve => setTimeout(resolve, 10))
    }
    eventInProgressRef.current = true

    try {
      const teamKey = mapSideToTeamKey(side)
      const liberoOnCourt = getLiberoOnCourt(teamKey)

      if (!liberoOnCourt) {
        showAlert('No libero is currently on court', 'warning')
        return
      }

      // Check if there has been a point since last libero exchange
      if (!hasPointSinceLastLiberoExchange(teamKey)) {
        showAlert('A point must be awarded before exchanging liberos', 'warning')
        return
      }

      // Get the other libero
      const teamPlayers = teamKey === 'home' ? data.homePlayers : data.awayPlayers
      const otherLibero = teamPlayers?.find(p =>
        p.libero &&
        p.libero !== '' &&
        p.libero !== 'unable' &&
        String(p.number) !== String(liberoOnCourt.liberoNumber) &&
        // Find the other active libero (L1, L2, or redesignated) that's not the one currently on court
        (p.libero === 'libero1' || p.libero === 'libero2' || p.libero === 'redesignated')
      )

      if (!otherLibero) {
        showAlert('Other libero not found', 'warning')
        return
      }

      // Check if either libero is unable to play
      if (isLiberoUnable(teamKey, liberoOnCourt.liberoNumber)) {
        showAlert('The libero currently on court is unable to play (injured, expelled, disqualified, or declared unable)', 'warning')
        return
      }

      if (isLiberoUnable(teamKey, otherLibero.number)) {
        showAlert('The other libero is unable to play (injured, expelled, disqualified, or declared unable)', 'warning')
        return
      }

      // Get current lineup
      const lineupEvents = data.events.filter(e =>
        e.type === 'lineup' &&
        e.payload?.team === teamKey &&
        e.setIndex === data.set.index
      )
      const currentLineup = lineupEvents[lineupEvents.length - 1].payload?.lineup

      // Replace current libero with other libero
      const newLineup = { ...currentLineup }
      newLineup[liberoOnCourt.position] = String(otherLibero.number)

      // Log the libero exchange event FIRST (main event) - skipMutex: we already hold it
      await logEvent('libero_exchange', {
        team: teamKey,
        position: liberoOnCourt.position,
        liberoOut: liberoOnCourt.liberoNumber,
        liberoIn: otherLibero.number,
        liberoOutType: liberoOnCourt.liberoType,
        liberoInType: otherLibero.libero,
        playerNumber: liberoOnCourt.playerNumber
      }, { skipMutex: true })

      // Save the updated lineup as a SUB-EVENT (seq N.1) so it's deleted together with libero_exchange on undo
      const allEvents = await db.events.where({ matchId }).toArray()
      const maxSeq = allEvents.length > 0 ? Math.max(...allEvents.map(e => e.seq || 0)) : 0
      const subEventSeq = Math.floor(maxSeq) + 0.1 // Sub-event of the libero_exchange

      await db.events.add({
        matchId,
        setIndex: data.set.index,
        type: 'lineup',
        payload: {
          team: teamKey,
          lineup: newLineup,
          liberoSubstitution: {
            position: liberoOnCourt.position,
            liberoNumber: otherLibero.number,
            playerNumber: liberoOnCourt.playerNumber,
            liberoType: otherLibero.libero
          }
        },
        ts: new Date().toISOString(),
        seq: subEventSeq
      })
    } finally {
      // MUTEX: Always release the lock, even if an error occurred
      eventInProgressRef.current = false
    }
  }, [rallyStatus, mapSideToTeamKey, getLiberoOnCourt, hasPointSinceLastLiberoExchange, data?.events, data?.set, data?.homePlayers, data?.awayPlayers, matchId, logEvent, isLiberoUnable])

  // Keyboard shortcuts handler
  useEffect(() => {
    if (!keybindingsEnabled) return

    const handleKeyDown = (e) => {
      // Don't handle if editing key bindings
      if (editingKey) return
      // Don't handle if typing in an input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return
      // Don't handle if options modal is open
      if (showOptionsInMenu || keybindingsModalOpen) return

      const key = e.key

      // Check for modal confirmations first (Enter/Escape)
      // These modals need a decision - don't allow Escape to close them
      const hasDecisionModal = substitutionConfirm || liberoConfirm || sanctionConfirmModal ||
        accidentalRallyConfirmModal || accidentalPointConfirmModal || undoConfirm ||
        replayRallyConfirm || liberoRotationModal || liberoReentryModal || sanctionSubstitutionModal

      // Confirm key (Enter)
      if (key === keyBindings.confirm) {
        // Start rally if idle and no modals
        if (!hasDecisionModal && rallyStatus === 'idle') {
          e.preventDefault()
          handleStartRally()
          return
        }
        // Confirm modals
        if (accidentalRallyConfirmModal) {
          e.preventDefault()
          accidentalRallyConfirmModal.onConfirm()
          return
        }
        if (accidentalPointConfirmModal) {
          e.preventDefault()
          accidentalPointConfirmModal.onConfirm()
          return
        }
        if (substitutionConfirm) {
          e.preventDefault()
          confirmSubstitution()
          return
        }
        if (liberoConfirm) {
          e.preventDefault()
          confirmLibero()
          return
        }
        if (undoConfirm) {
          e.preventDefault()
          handleUndo()
          return
        }
        if (replayRallyConfirm) {
          e.preventDefault()
          handleDecisionChange()
          return
        }
      }

      // Cancel key (Escape) - only close non-decision modals
      if (key === keyBindings.cancel) {
        // Close dropdowns and menus
        if (playerActionMenu) {
          e.preventDefault()
          setPlayerActionMenu(null)
          return
        }
        if (benchPlayerActionMenu) {
          e.preventDefault()
          setBenchPlayerActionMenu(null)
          return
        }
        if (liberoDropdown) {
          e.preventDefault()
          setLiberoDropdown(null)
          return
        }
        if (liberoInDropdown) {
          e.preventDefault()
          setLiberoInDropdown(null)
          return
        }
        if (sanctionDropdown) {
          e.preventDefault()
          setSanctionDropdown(null)
          return
        }
        if (timeoutModal) {
          e.preventDefault()
          setTimeoutModal(null)
          return
        }
        // Don't close decision modals with Escape
        return
      }

      // Don't process other keys if a modal is open
      if (hasDecisionModal || timeoutModal || lineupModal || menuModal) return

      // Point keys
      if (key === keyBindings.pointLeft && rallyStatus === 'in_play') {
        e.preventDefault()
        handlePoint('left')
        return
      }
      if (key === keyBindings.pointRight && rallyStatus === 'in_play') {
        e.preventDefault()
        handlePoint('right')
        return
      }

      // Timeout keys (only when idle)
      if (key === keyBindings.timeoutLeft && rallyStatus === 'idle') {
        e.preventDefault()
        handleTimeout('left')
        return
      }
      if (key === keyBindings.timeoutRight && rallyStatus === 'idle') {
        e.preventDefault()
        handleTimeout('right')
        return
      }

      // Exchange libero keys (only when idle)
      if (key === keyBindings.exchangeLiberoLeft && rallyStatus === 'idle') {
        e.preventDefault()
        handleExchangeLibero('left')
        return
      }
      if (key === keyBindings.exchangeLiberoRight && rallyStatus === 'idle') {
        e.preventDefault()
        handleExchangeLibero('right')
        return
      }

      // Undo key
      if (key === keyBindings.undo && rallyStatus === 'idle') {
        e.preventDefault()
        handleUndo()
        return
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [
    keybindingsEnabled, keyBindings, editingKey, showOptionsInMenu, keybindingsModalOpen,
    rallyStatus, handleStartRally, handlePoint, handleTimeout, handleExchangeLibero, handleUndo,
    playerActionMenu, benchPlayerActionMenu, liberoDropdown, liberoInDropdown, sanctionDropdown,
    timeoutModal, lineupModal, menuModal,
    substitutionConfirm, liberoConfirm, sanctionConfirmModal, accidentalRallyConfirmModal,
    accidentalPointConfirmModal, undoConfirm, replayRallyConfirm, liberoRotationModal, liberoReentryModal,
    confirmSubstitution, confirmLibero, handleReplayRally, handleDecisionChange
  ])

  const sanctionButtonStyles = useMemo(() => ({
    improper: {
      flex: 1,
      fontSize: '10px',
      padding: '8px 4px',
      background: 'rgba(156, 163, 175, 0.25)',
      border: '1px solid rgba(156, 163, 175, 0.5)',
      color: '#d1d5db',
      fontWeight: 600,
      boxShadow: '0 0 0 1px rgba(255,255,255,0.05)'
    },
    delayWarning: {
      flex: 1,
      fontSize: '10px',
      padding: '8px 4px',
      background: 'rgba(234, 179, 8, 0.2)',
      border: '1px solid rgba(234, 179, 8, 0.4)',
      color: '#facc15',
      fontWeight: 600,
      boxShadow: '0 0 0 1px rgba(250, 204, 21, 0.15)'
    },
    delayPenalty: {
      flex: 1,
      fontSize: '10px',
      padding: '8px 4px',
      background: 'rgba(239, 68, 68, 0.2)',
      border: '1px solid rgba(239, 68, 68, 0.4)',
      color: '#f87171',
      fontWeight: 600,
      boxShadow: '0 0 0 1px rgba(248, 113, 113, 0.2)'
    }
  }), [])

  // Check if referees are connected (heartbeat within last 15 seconds)
  // Must be before any early returns to comply with Rules of Hooks
  const isReferee1Connected = useMemo(() => {
    if (!data?.match?.lastReferee1Heartbeat) return false
    const lastHeartbeat = new Date(data.match.lastReferee1Heartbeat).getTime()
    const currentTime = new Date().getTime()
    return (currentTime - lastHeartbeat) < 15000 // 15 seconds threshold
  }, [data?.match?.lastReferee1Heartbeat, now])

  const isReferee2Connected = useMemo(() => {
    if (!data?.match?.lastReferee2Heartbeat) return false
    const lastHeartbeat = new Date(data.match.lastReferee2Heartbeat).getTime()
    const currentTime = new Date().getTime()
    return (currentTime - lastHeartbeat) < 15000 // 15 seconds threshold
  }, [data?.match?.lastReferee2Heartbeat, now])

  const isAnyRefereeConnected = isReferee1Connected || isReferee2Connected
  const refereeConnectionEnabled = data?.match?.refereeConnectionEnabled === true
  const homeTeamConnectionEnabled = data?.match?.homeTeamConnectionEnabled === true
  const awayTeamConnectionEnabled = data?.match?.awayTeamConnectionEnabled === true

  // Team labels (A or B) based on coin toss assignment
  const homeLabel = data?.match?.coinTossTeamA === 'home' ? 'A' : (data?.match?.coinTossTeamB === 'home' ? 'B' : 'A')
  const awayLabel = data?.match?.coinTossTeamA === 'away' ? 'A' : (data?.match?.coinTossTeamB === 'away' ? 'B' : 'B')

  // Handle captain on court selection
  const handleSelectCaptainOnCourt = useCallback(async (playerNumber) => {
    if (!captainOnCourtModal || !matchId) return

    const { team } = captainOnCourtModal
    const courtCaptainField = team === 'home' ? 'homeCourtCaptain' : 'awayCourtCaptain'
    const rememberedField = team === 'home' ? 'homeRememberedCourtCaptain' : 'awayRememberedCourtCaptain'

    // Get previous court captain for undo
    const match = await db.matches.get(matchId)
    const previousCourtCaptain = match?.[courtCaptainField] || null

    // Save the selected captain on court AND remember for auto-redesignation
    await db.matches.update(matchId, {
      [courtCaptainField]: playerNumber,
      [rememberedField]: playerNumber  // Remember for when captain leaves again
    })

    // Log the event (this triggers snapshot capture and sync to Supabase/Referee)
    await logEvent('court_captain_designation', {
      team,
      playerNumber,
      previousCourtCaptain
    })

    setCaptainOnCourtModal(null)
  }, [captainOnCourtModal, matchId, logEvent])

  // Handle cancel (no captain selected)
  const handleCancelCaptainOnCourt = useCallback(() => {
    setCaptainOnCourtModal(null)
  }, [])

  // Check if bench teams are connected (heartbeat within last 15 seconds)
  const isHomeTeamConnected = useMemo(() => {
    if (!data?.match?.lastHomeTeamHeartbeat) return false
    const lastHeartbeat = new Date(data.match.lastHomeTeamHeartbeat).getTime()
    const currentTime = new Date().getTime()
    return (currentTime - lastHeartbeat) < 15000 // 15 seconds threshold
  }, [data?.match?.lastHomeTeamHeartbeat, now])

  const isAwayTeamConnected = useMemo(() => {
    if (!data?.match?.lastAwayTeamHeartbeat) return false
    const lastHeartbeat = new Date(data.match.lastAwayTeamHeartbeat).getTime()
    const currentTime = new Date().getTime()
    return (currentTime - lastHeartbeat) < 15000 // 15 seconds threshold
  }, [data?.match?.lastAwayTeamHeartbeat, now])

  // Helper function to get connection status and color
  const getConnectionStatus = useCallback((type) => {
    if (type === 'referee') {
      if (!refereeConnectionEnabled) {
        return { status: 'disabled', color: '#6b7280' } // grey
      }
      if (isReferee1Connected || isReferee2Connected) {
        return { status: 'connected', color: '#22c55e' } // green
      }
      // Enabled but not connected
      return { status: 'not_connected', color: '#eab308' } // yellow
    } else if (type === 'teamA') {
      if (!homeTeamConnectionEnabled) {
        return { status: 'disabled', color: '#6b7280' } // grey
      }
      const hasPin = !!data?.match?.homeTeamPin
      if (!hasPin) {
        return { status: 'error', color: '#ef4444' } // red - no PIN configured
      }
      if (isHomeTeamConnected) {
        return { status: 'connected', color: '#22c55e' } // green
      }
      // Enabled, has PIN, but not connected
      return { status: 'not_connected', color: '#eab308' } // yellow
    } else if (type === 'teamB') {
      if (!awayTeamConnectionEnabled) {
        return { status: 'disabled', color: '#6b7280' } // grey
      }
      const hasPin = !!data?.match?.awayTeamPin
      if (!hasPin) {
        return { status: 'error', color: '#ef4444' } // red - no PIN configured
      }
      if (isAwayTeamConnected) {
        return { status: 'connected', color: '#22c55e' } // green
      }
      // Enabled, has PIN, but not connected
      return { status: 'not_connected', color: '#eab308' } // yellow
    }
    return { status: 'error', color: '#ef4444' } // red - unknown
  }, [refereeConnectionEnabled, isReferee1Connected, isReferee2Connected, homeTeamConnectionEnabled, awayTeamConnectionEnabled, isHomeTeamConnected, isAwayTeamConnected, data?.match])

  const handleRefereeConnectionToggle = useCallback(async (enabled) => {
    if (!matchId) return
    try {
      await db.matches.update(matchId, { refereeConnectionEnabled: enabled })
      // Sync to Supabase (use seed_key as external_id)
      const match = await db.matches.get(matchId)
      if (match?.seed_key) {
        await db.sync_queue.add({
          resource: 'match',
          action: 'update',
          payload: {
            id: match.seed_key,
            connections: {
              referee_enabled: enabled
            },
            connection_pins: {
              referee: match?.refereePin || ''
            }
          },
          ts: new Date().toISOString(),
          status: 'queued'
        })
      }
    } catch (error) {
      console.error('[Scoreboard] Failed to sync referee connection:', error)
    }
  }, [matchId])

  const handleHomeTeamConnectionToggle = useCallback(async (enabled) => {
    if (!matchId) return
    try {
      await db.matches.update(matchId, { homeTeamConnectionEnabled: enabled })
      // Sync to Supabase (use seed_key as external_id)
      const match = await db.matches.get(matchId)
      if (match?.seed_key) {
        await db.sync_queue.add({
          resource: 'match',
          action: 'update',
          payload: {
            id: match.seed_key,
            connections: {
              home_bench_enabled: enabled
            },
            connection_pins: {
              bench_home: match?.homeTeamPin || ''
            }
          },
          ts: new Date().toISOString(),
          status: 'queued'
        })
      }
    } catch (error) {
      console.error('[Scoreboard] Failed to sync home team connection:', error)
    }
  }, [matchId])

  const handleAwayTeamConnectionToggle = useCallback(async (enabled) => {
    if (!matchId) return
    try {
      await db.matches.update(matchId, { awayTeamConnectionEnabled: enabled })
      // Sync to Supabase (use seed_key as external_id)
      const match = await db.matches.get(matchId)
      if (match?.seed_key) {
        await db.sync_queue.add({
          resource: 'match',
          action: 'update',
          payload: {
            id: match.seed_key,
            connections: {
              away_bench_enabled: enabled
            },
            connection_pins: {
              bench_away: match?.awayTeamPin || ''
            }
          },
          ts: new Date().toISOString(),
          status: 'queued'
        })
      }
    } catch (error) {
      console.error('[Scoreboard] Failed to sync away team connection:', error)
    }
  }, [matchId])

  const handleEditPin = useCallback((type = 'referee') => {
    let currentPin = ''
    if (type === 'referee') {
      currentPin = data?.match?.refereePin || ''
    } else if (type === 'teamA') {
      currentPin = data?.match?.homeTeamPin || ''
    } else if (type === 'teamB') {
      currentPin = data?.match?.awayTeamPin || ''
    }
    setNewPin(currentPin)
    setPinError('')
    setEditPinType(type)
    setEditPinModal(true)
  }, [data?.match?.refereePin, data?.match?.homeTeamPin, data?.match?.awayTeamPin])

  const handleSavePin = useCallback(async () => {
    if (!matchId) return

    // Validate PIN
    if (!newPin || newPin.length !== 6) {
      setPinError('PIN must be exactly 6 digits')
      return
    }
    if (!/^\d{6}$/.test(newPin)) {
      setPinError('PIN must contain only numbers')
      return
    }

    try {
      let updateField = {}
      if (editPinType === 'referee') {
        updateField = { refereePin: newPin }
      } else if (editPinType === 'teamA') {
        updateField = { homeTeamPin: newPin }
      } else if (editPinType === 'teamB') {
        updateField = { awayTeamPin: newPin }
      }
      await db.matches.update(matchId, updateField)
      setEditPinModal(false)
      setPinError('')
      setEditPinType(null)
    } catch (error) {
      setPinError('Failed to save PIN')
    }
  }, [matchId, newPin, editPinType])

  const confirmCourtSwitch = useCallback(async () => {
    if (!courtSwitchModal) return

    // Mark that courts have been switched for set 5
    await db.matches.update(matchId, { set5CourtSwitched: true })

    // Close the modal
    setCourtSwitchModal(null)

    // Sync to Supabase with fresh snapshot to update side_a and serving_team after court switch
    syncLiveStateToSupabase('court_switch', null, { reason: 'set5_8points' }, null)
  }, [courtSwitchModal, matchId, syncLiveStateToSupabase])

  const cancelCourtSwitch = useCallback(async () => {
    if (!courtSwitchModal || !data?.events) return

    // Undo the last point that caused the 8-point threshold
    // Find the last event by sequence number
    const sortedEvents = [...data.events].sort((a, b) => {
      const aSeq = a.seq || 0
      const bSeq = b.seq || 0
      if (aSeq !== 0 || bSeq !== 0) {
        return bSeq - aSeq // Descending
      }
      const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
      const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
      return bTime - aTime
    })

    const lastEvent = sortedEvents[0]
    if (lastEvent) {
      // Delete the last event (point or sanction)
      await db.events.delete(lastEvent.id)

      // Update set points
      const newHomePoints = courtSwitchModal.teamThatScored === 'home'
        ? courtSwitchModal.homePoints - 1
        : courtSwitchModal.homePoints
      const newAwayPoints = courtSwitchModal.teamThatScored === 'away'
        ? courtSwitchModal.awayPoints - 1
        : courtSwitchModal.awayPoints

      await db.sets.update(courtSwitchModal.set.id, {
        homePoints: newHomePoints,
        awayPoints: newAwayPoints
      })
    }

    setCourtSwitchModal(null)
  }, [courtSwitchModal, data?.events])

  // Check if match is already finished (loaded a completed match)
  // If so, trigger onFinishSet to navigate to MatchEnd screen
  useEffect(() => {
    if (data && !data.set && data.sets && data.sets.length > 0 && !setTransitionLoading) {
      // No active set but we have sets - check if match is finished
      const finishedSets = data.sets.filter(s => s.finished)
      const homeSetsWon = finishedSets.filter(s => s.homePoints > s.awayPoints).length
      const awaySetsWon = finishedSets.filter(s => s.awayPoints > s.homePoints).length
      const isMatchFinished = homeSetsWon >= 3 || awaySetsWon >= 3

      if (isMatchFinished && onFinishSet) {
        console.log('[Scoreboard] Match is already finished, navigating to MatchEnd')
        // Pass the last finished set to trigger match end navigation
        const lastSet = finishedSets.sort((a, b) => b.index - a.index)[0]
        onFinishSet(lastSet)
      }
    }
  }, [data, setTransitionLoading, onFinishSet])

  if (!data?.set || setTransitionLoading) {
    const loadingStep = setTransitionLoading?.step || 'Loading...'
    return (
      <div style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: 'rgba(0, 0, 0, 0.85)',
        zIndex: 9999,
        gap: '24px'
      }}>
        {/* Spinner */}
        <div style={{
          width: '64px',
          height: '64px',
          border: '4px solid rgba(255, 255, 255, 0.1)',
          borderTopColor: '#3498db',
          borderRadius: '50%',
          animation: 'spin 1s linear infinite'
        }} />

        {/* Loading text */}
        <div style={{
          color: '#fff',
          fontSize: '24px',
          fontWeight: 600,
          textAlign: 'center'
        }}>
          {loadingStep}
        </div>

        {/* CSS for spinner animation */}
        <style>{`
          @keyframes spin {
            to { transform: rotate(360deg); }
          }
        `}</style>
      </div>
    )
  }

  const teamALabel = leftTeam.isTeamA ? 'A' : 'B'
  const teamBLabel = rightTeam.isTeamA ? 'A' : 'B'
  const teamAShortName = leftIsHome
    ? (data?.match?.homeShortName || leftTeam.name?.substring(0, 3).toUpperCase() || 'A')
    : (data?.match?.awayShortName || leftTeam.name?.substring(0, 3).toUpperCase() || 'A')
  const teamBShortName = leftIsHome
    ? (data?.match?.awayShortName || rightTeam.name?.substring(0, 3).toUpperCase() || 'B')
    : (data?.match?.homeShortName || rightTeam.name?.substring(0, 3).toUpperCase() || 'B')

  // Help content function
  const getHelpContent = (topicId) => {
    switch (topicId) {
      case 'recording-points':
        return (
          <div>
            <h3 style={{ fontSize: '24px', fontWeight: 700, marginBottom: '16px' }}>Recording Points</h3>
            <div style={{ background: 'rgba(255, 255, 255, 0.05)', padding: '20px', borderRadius: '8px' }}>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginBottom: '12px' }}>What happens when you record a point:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>The score updates automatically for the team that scored</li>
                <li>The point is logged in the event history</li>
                <li>The serving team indicator updates</li>
                <li>If a team reaches 25 points (or 15 in set 5) with a 2-point lead, you'll be prompted to end the set</li>
                <li>All actions are saved automatically to the database</li>
              </ul>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginTop: '20px', marginBottom: '12px' }}>Keyboard Shortcuts:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li><strong>Space</strong>: Award point to home team</li>
                <li><strong>Enter</strong>: Award point to away team</li>
              </ul>
            </div>
          </div>
        )

      case 'timeouts':
        return (
          <div>
            <h3 style={{ fontSize: '24px', fontWeight: 700, marginBottom: '16px' }}>Timeouts</h3>
            <div style={{ background: 'rgba(255, 255, 255, 0.05)', padding: '20px', borderRadius: '8px' }}>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginBottom: '12px' }}>What happens when you request a timeout:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>A 30-second countdown timer starts automatically</li>
                <li>The timeout is recorded in the event log</li>
                <li>Each team is limited to 2 timeouts per set</li>
                <li>The timeout countdown is displayed on screen</li>
                <li>You can see timeout history in the timeout details panel</li>
              </ul>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginTop: '20px', marginBottom: '12px' }}>Important Notes:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>Timeouts cannot be requested if the team has already used both timeouts in the set</li>
                <li>The timer continues even if you navigate away from the scoreboard</li>
                <li>Timeouts are automatically saved to the database</li>
              </ul>
            </div>
          </div>
        )

      case 'substitutions':
        return (
          <div>
            <h3 style={{ fontSize: '24px', fontWeight: 700, marginBottom: '16px' }}>Substitutions</h3>
            <div style={{ background: 'rgba(255, 255, 255, 0.05)', padding: '20px', borderRadius: '8px' }}>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginBottom: '12px' }}>What happens when you make a substitution:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>Click on the player position on the court to open substitution options</li>
                <li>Select the player going out and the player coming in</li>
                <li>The substitution is recorded with the current score</li>
                <li>The lineup updates immediately on the scoreboard</li>
                <li>Substitution history is tracked and can be viewed</li>
                <li>Each team has unlimited substitutions per set</li>
              </ul>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginTop: '20px', marginBottom: '12px' }}>Special Cases:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li><strong>Injury Substitution</strong>: Mark as injury if a player is injured</li>
                <li><strong>Exceptional Substitution</strong>: For expelled/disqualified players</li>
                <li><strong>Libero Substitution</strong>: Special rules apply for libero exchanges</li>
              </ul>
            </div>
          </div>
        )

      case 'libero':
        return (
          <div>
            <h3 style={{ fontSize: '24px', fontWeight: 700, marginBottom: '16px' }}>Libero Substitutions</h3>
            <div style={{ background: 'rgba(255, 255, 255, 0.05)', padding: '20px', borderRadius: '8px' }}>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginBottom: '12px' }}>What happens with libero substitutions:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>Liberos can only replace back-row players</li>
                <li>Libero exchanges don't count as regular substitutions</li>
                <li>Each team can have up to 2 liberos (Libero 1 and Libero 2)</li>
                <li>Libero exchanges are unlimited but must follow rotation rules</li>
                <li>The libero must exit before the next serve</li>
              </ul>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginTop: '20px', marginBottom: '12px' }}>Libero Rules:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>Libero cannot serve (except in specific situations)</li>
                <li>Libero cannot attack from front row</li>
                <li>Libero redesignation is possible if a libero becomes unable to play</li>
                <li>All libero actions are automatically tracked</li>
              </ul>
            </div>
          </div>
        )

      case 'sanctions':
        return (
          <div>
            <h3 style={{ fontSize: '24px', fontWeight: 700, marginBottom: '16px' }}>Sanctions</h3>
            <div style={{ background: 'rgba(255, 255, 255, 0.05)', padding: '20px', borderRadius: '8px' }}>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginBottom: '12px' }}>What happens when you record a sanction:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li><strong>Warning (Yellow Card)</strong>: First offense, no point penalty</li>
                <li><strong>Penalty (Red Card)</strong>: Second offense, point awarded to opponent</li>
                <li><strong>Expulsion</strong>: Player must leave the set, can return next set</li>
                <li><strong>Disqualification</strong>: Player must leave the match entirely</li>
                <li>Sanctions are recorded with the score at the time of the sanction</li>
                <li>All sanctions appear in the sanctions table on the match end screen</li>
              </ul>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginTop: '20px', marginBottom: '12px' }}>Who Can Receive Sanctions:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>Players on the court</li>
                <li>Bench players</li>
                <li>Coaches and bench officials</li>
                <li>Team (delay warnings/penalties)</li>
              </ul>
            </div>
          </div>
        )

      case 'ending-set':
        return (
          <div>
            <h3 style={{ fontSize: '24px', fontWeight: 700, marginBottom: '16px' }}>Ending a Set</h3>
            <div style={{ background: 'rgba(255, 255, 255, 0.05)', padding: '20px', borderRadius: '8px' }}>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginBottom: '12px' }}>What happens when you end a set:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>You'll be prompted to confirm the set end time</li>
                <li>The set is marked as finished in the database</li>
                <li>Set statistics are calculated (timeouts, substitutions, duration)</li>
                <li>If it's set 4, you'll be asked to choose sides and first serve for set 5</li>
                <li>If it's set 5, the match ends automatically</li>
                <li>If a team wins 3 sets, the match ends and you go to the Match End screen</li>
                <li>Otherwise, the next set begins automatically</li>
              </ul>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginTop: '20px', marginBottom: '12px' }}>Set End Conditions:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li><strong>Sets 1-4</strong>: First team to 25 points with 2-point lead</li>
                <li><strong>Set 5</strong>: First team to 15 points with 2-point lead</li>
                <li>No cap - sets continue until a team wins by 2 points</li>
              </ul>
            </div>
          </div>
        )

      case 'match-end':
        return (
          <div>
            <h3 style={{ fontSize: '24px', fontWeight: 700, marginBottom: '16px' }}>Match End</h3>
            <div style={{ background: 'rgba(255, 255, 255, 0.05)', padding: '20px', borderRadius: '8px' }}>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginBottom: '12px' }}>What happens when the match ends:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>The match status is automatically set to "final"</li>
                <li>You're taken to the Match End screen</li>
                <li>All match data is preserved (sets, events, players, teams)</li>
                <li>For official matches, the match is queued for sync to Supabase</li>
                <li>The session lock is released</li>
                <li>You can review results, sanctions, and match statistics</li>
              </ul>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginTop: '20px', marginBottom: '12px' }}>Match End Screen:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>View final score and set-by-set breakdown</li>
                <li>Review all sanctions issued</li>
                <li>Collect signatures from captains and officials</li>
                <li>Approve and export match data (PDF, JPG, JSON)</li>
                <li>Return to home screen when done</li>
              </ul>
            </div>
          </div>
        )

      case 'undo':
        return (
          <div>
            <h3 style={{ fontSize: '24px', fontWeight: 700, marginBottom: '16px' }}>Undo Actions</h3>
            <div style={{ background: 'rgba(255, 255, 255, 0.05)', padding: '20px', borderRadius: '8px' }}>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginBottom: '12px' }}>What happens when you undo an action:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>The last action is reversed (point, substitution, timeout, etc.)</li>
                <li>The score or state returns to what it was before</li>
                <li>The undo event is logged in the action history</li>
                <li>You can undo multiple actions in sequence</li>
                <li>Undo works for most actions except set/match end</li>
              </ul>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginTop: '20px', marginBottom: '12px' }}>How to Undo:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>Click the <strong>Undo</strong> button in the rally controls</li>
                <li>Or use the keyboard shortcut (if available)</li>
                <li>Confirm the undo action when prompted</li>
                <li>Check the action log to see undo history</li>
              </ul>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginTop: '20px', marginBottom: '12px' }}>Limitations:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>Cannot undo set end or match end</li>
                <li>Cannot undo actions from previous sets</li>
                <li>Undo only affects the current set</li>
              </ul>
            </div>
          </div>
        )

      case 'lineup':
        return (
          <div>
            <h3 style={{ fontSize: '24px', fontWeight: 700, marginBottom: '16px' }}>Setting Lineup</h3>
            <div style={{ background: 'rgba(255, 255, 255, 0.05)', padding: '20px', borderRadius: '8px' }}>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginBottom: '12px' }}>What happens when you set the lineup:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>You assign 6 players to court positions (I, II, III, IV, V, VI)</li>
                <li>The lineup determines the serving order</li>
                <li>Players rotate positions when they win the serve back</li>
                <li>The lineup is saved and used throughout the set</li>
                <li>You can set lineup manually or use automatic lineup</li>
              </ul>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginTop: '20px', marginBottom: '12px' }}>Lineup Rules:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>Must have exactly 6 players on court</li>
                <li>Liberos cannot be in the initial lineup</li>
                <li>Lineup must be set before the set starts</li>
                <li>Lineup can be adjusted manually if needed</li>
              </ul>
            </div>
          </div>
        )

      case 'set-5':
        return (
          <div>
            <h3 style={{ fontSize: '24px', fontWeight: 700, marginBottom: '16px' }}>Set 5 (Tie-break)</h3>
            <div style={{ background: 'rgba(255, 255, 255, 0.05)', padding: '20px', borderRadius: '8px' }}>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginBottom: '12px' }}>What happens in Set 5:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>First team to 15 points wins (instead of 25)</li>
                <li>Must win by 2 points (no cap)</li>
                <li>Teams switch sides when one team reaches 8 points</li>
                <li>You'll be prompted to choose which team is on which side</li>
                <li>First serve is determined by coin toss result or set 4 outcome</li>
                <li>All other rules remain the same (timeouts, substitutions, etc.)</li>
              </ul>
              <h4 style={{ fontSize: '18px', fontWeight: 600, marginTop: '20px', marginBottom: '12px' }}>Court Switch at 8 Points:</h4>
              <ul style={{ paddingLeft: '20px', lineHeight: '1.8' }}>
                <li>When a team reaches 8 points, the app will prompt for court switch</li>
                <li>You'll confirm which team is now on which side</li>
                <li>The scoreboard updates to reflect the new positions</li>
                <li>Play continues without interruption</li>
              </ul>
            </div>
          </div>
        )

      default:
        return <div>Topic not found</div>
    }
  }

  // Show duplicate tab error if scoresheet is already open in another tab
  if (duplicateTabError) {
    return (
      <div style={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100vh',
        background: 'var(--bg)',
        color: 'var(--text)',
        padding: '20px',
        textAlign: 'center'
      }}>
        <div style={{
          fontSize: '48px',
          marginBottom: '20px'
        }}>⚠️</div>
        <h1 style={{
          fontSize: '24px',
          fontWeight: 600,
          marginBottom: '12px',
          color: '#f59e0b'
        }}>Scoresheet Already Open</h1>
        <p style={{
          fontSize: '16px',
          color: 'rgba(255,255,255,0.7)',
          marginBottom: '24px',
          maxWidth: '400px'
        }}>
          This match scoresheet is already open in another tab or browser window.
          Please close this tab and use the existing one to avoid data conflicts.
        </p>
        <button
          onClick={() => window.close()}
          style={{
            padding: '12px 24px',
            fontSize: '16px',
            fontWeight: 600,
            background: '#3b82f6',
            color: '#fff',
            border: 'none',
            borderRadius: '8px',
            cursor: 'pointer'
          }}
        >
          Close This Tab
        </button>
      </div>
    )
  }

  return (
    <div className="match-record">
      {/* Portrait mode warning overlay for devices that don't support orientation lock (iOS) */}
      {!isLandscape && (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: 'rgba(0, 0, 0, 0.95)',
          zIndex: 99999,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          padding: '24px',
          textAlign: 'center'
        }}>
          <div style={{
            fontSize: '64px',
            marginBottom: '24px',
            animation: 'rotate90 1.5s ease-in-out infinite'
          }}>
            📱
          </div>
          <style>{`
            @keyframes rotate90 {
              0%, 100% { transform: rotate(0deg); }
              50% { transform: rotate(-90deg); }
            }
          `}</style>
          <h2 style={{
            fontSize: '24px',
            fontWeight: 700,
            color: '#ffffff',
            marginBottom: '16px'
          }}>
            Please Rotate Your Device
          </h2>
          <p style={{
            fontSize: '16px',
            color: '#9ca3af',
            maxWidth: '300px',
            lineHeight: 1.5,
            marginBottom: '24px'
          }}>
            The Scoreboard works best in landscape mode. Please rotate your device horizontally to continue.
          </p>
          <div style={{
            padding: '12px 16px',
            background: 'rgba(59, 130, 246, 0.15)',
            border: '1px solid rgba(59, 130, 246, 0.3)',
            borderRadius: '8px',
            maxWidth: '320px'
          }}>
            <p style={{
              fontSize: '13px',
              color: '#93c5fd',
              lineHeight: 1.4,
              margin: 0
            }}>
              <strong>Tip:</strong> For auto-backup features, use Chrome or Edge on a desktop/laptop computer.
            </p>
          </div>
          <button
            onClick={() => {
              if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(err => {
                  // Fullscreen not supported
                })
              }
            }}
            style={{
              marginTop: '24px',
              padding: '12px 24px',
              fontSize: '16px',
              fontWeight: 600,
              background: 'var(--accent)',
              color: '#000',
              border: 'none',
              borderRadius: '8px',
              cursor: 'pointer',
              display: 'flex',
              alignItems: 'center',
              gap: '8px'
            }}
          >
            <span>⛶</span>
            <span>Enter Fullscreen</span>
          </button>
          <p style={{
            fontSize: '12px',
            color: '#6b7280',
            marginTop: '12px'
          }}>
            Fullscreen removes browser headers to maximize screen space.
          </p>
        </div>
      )}
      <ScoreboardToolbar collapsed={headerCollapsed} onToggle={() => setHeaderCollapsed(!headerCollapsed)}>
        {/* Column 1: Date/Time */}
        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-start' }}>
          <span className="toolbar-clock" style={{ fontSize: isCompactMode ? '11px' : '14px' }}>{formatTimestamp(now)}</span>
        </div>

        {/* Column 2: Left team OR Rally status (compact/laptop) */}
        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
          {(isCompactMode || isLaptopMode) ? (
            <div
              onClick={() => setRallyStatusExpanded(!rallyStatusExpanded)}
              style={{
                fontSize: isCompactMode ? '10px' : '11px',
                color: rallyStatus === 'in_play' ? '#4ade80' : '#fb923c',
                cursor: 'pointer',
                textAlign: 'center',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap',
                fontWeight: 600
              }}
            >
              Rally: {rallyStatus === 'in_play' ? 'In play' : 'Not in play'}
            </div>
          ) : (
            <div style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              gap: '8px',
              overflow: 'hidden'
            }}>
              <span style={{
                fontSize: '13px',
                fontWeight: 600,
                color: 'var(--text)',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap'
              }}>
                {leftTeam.name || (leftIsHome ? 'Home' : 'Away')}
              </span>
              <div style={{
                padding: '2px 6px',
                borderRadius: '4px',
                fontSize: '11px',
                fontWeight: 700,
                background: leftTeam.color || '#ef4444',
                color: isBrightColor(leftTeam.color || '#ef4444') ? '#000' : '#fff',
                flexShrink: 0
              }}>
                {teamALabel}
              </div>
            </div>
          )}
        </div>

        {/* Column 3: Set Counter (centered) */}
        <div style={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: isCompactMode ? '6px' : '12px'
        }}>
          <span style={{
            padding: isCompactMode ? '2px 6px' : '4px 10px',
            borderRadius: '4px',
            fontSize: isCompactMode ? '12px' : '16px',
            fontWeight: 700,
            background: leftTeam?.color || '#ef4444',
            color: isBrightColor(leftTeam?.color || '#ef4444') ? '#000' : '#fff'
          }}>
            {setsWon?.left || 0}
          </span>
          <div style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            fontSize: isCompactMode ? '10px' : '14px'
          }}>
            <span style={{ color: 'var(--muted)', fontWeight: 600 }}>SET</span>
            <span style={{ fontWeight: 700 }}>{data?.set?.index || 1}</span>
          </div>
          <span style={{
            padding: isCompactMode ? '2px 6px' : '4px 10px',
            borderRadius: '4px',
            fontSize: isCompactMode ? '12px' : '16px',
            fontWeight: 700,
            background: rightTeam?.color || '#3b82f6',
            color: isBrightColor(rightTeam?.color || '#3b82f6') ? '#000' : '#fff'
          }}>
            {setsWon?.right || 0}
          </span>
        </div>

        {/* Column 4: Right team OR Last action (compact/laptop) */}
        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
          {(isCompactMode || isLaptopMode) ? (() => {
            if (!data?.events || data.events.length === 0 || !data?.set) {
              return null
            }
            // IMPORTANT: Only show events from the CURRENT SET
            const currentSetIndex = data.set.index
            const currentSetEvents = data.events.filter(e => e.setIndex === currentSetIndex)
            if (currentSetEvents.length === 0) return null

            const sortedEvents = [...currentSetEvents].sort((a, b) => {
              const aSeq = a.seq || 0
              const bSeq = b.seq || 0
              if (aSeq !== 0 || bSeq !== 0) return bSeq - aSeq
              const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
              const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
              return bTime - aTime
            })

            // Helper to check if an event is a sub-event (decimal sequence)
            const isSubEvent = (event) => {
              const seq = event.seq || 0
              return seq !== Math.floor(seq)
            }

            let lastEvent = null
            for (const e of sortedEvents) {
              // Skip sub-events (they're part of their parent)
              if (isSubEvent(e)) continue
              if (e.type === 'rally_start' || e.type === 'replay') continue
              if (e.type === 'lineup') {
                const hasInitial = e.payload?.isInitial === true
                const hasSubstitution = e.payload?.fromSubstitution === true
                if (!hasInitial && !hasSubstitution) continue
              }
              const desc = getActionDescription(e)
              if (desc && desc !== 'Unknown action') {
                lastEvent = e
                break
              }
            }
            if (!lastEvent) return null
            const fullDescription = getActionDescription(lastEvent)
            const getSimpleActionType = (event) => {
              switch (event.type) {
                case 'point': return 'Point'
                case 'timeout': return 'Timeout'
                case 'substitution': return event.payload?.isExceptional ? 'Exc. substitution' : 'Substitution'
                case 'libero_entry': return 'Libero entry'
                case 'libero_exit': return 'Libero exit'
                case 'libero_exchange': return 'Libero exchange'
                case 'libero_unable': return 'Libero unable'
                case 'libero_redesignation': return 'Libero redesignation'
                case 'decision_change': return 'Decision change'
                case 'sanction': {
                  const sanctionType = event.payload?.sanctionType
                  if (sanctionType === 'warning') return 'Warning'
                  if (sanctionType === 'penalty') return 'Penalty'
                  if (sanctionType === 'expulsion') return 'Expulsion'
                  if (sanctionType === 'disqualification') return 'Disqualification'
                  return 'Sanction'
                }
                case 'delay_sanction': {
                  const delayType = event.payload?.sanctionType
                  if (delayType === 'warning') return 'Delay warning'
                  if (delayType === 'penalty') return 'Delay penalty'
                  return 'Delay sanction'
                }
                case 'coin_toss': return 'Coin toss'
                case 'set_start': return 'Set start'
                case 'set_end': return 'Set end'
                case 'lineup': return 'Line-up'
                case 'forfait': return 'Forfait'
                case 'injury': return 'Injury'
                default: return event.type
              }
            }
            const simpleAction = getSimpleActionType(lastEvent)
            return (
              <div style={{ position: 'relative', textAlign: 'center' }}>
                <div
                  onClick={() => setRallyStatusExpanded(!rallyStatusExpanded)}
                  style={{
                    fontSize: isCompactMode ? '10px' : '11px',
                    color: 'var(--muted)',
                    cursor: 'pointer',
                    textAlign: 'center',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap'
                  }}
                >
                  <span style={{ opacity: 0.7 }}>{t('scoreboard.labels.last')}: </span>
                  <span>{simpleAction}</span>
                </div>
                {rallyStatusExpanded && (
                  <div
                    onClick={() => setRallyStatusExpanded(false)}
                    style={{
                      position: 'absolute',
                      top: '100%',
                      left: '50%',
                      transform: 'translateX(-50%)',
                      marginTop: '4px',
                      padding: '8px 12px',
                      background: 'rgba(0, 0, 0, 0.95)',
                      border: '1px solid rgba(255, 255, 255, 0.2)',
                      borderRadius: '6px',
                      fontSize: '12px',
                      color: '#fff',
                      whiteSpace: 'nowrap',
                      zIndex: 1001,
                      boxShadow: '0 4px 12px rgba(0, 0, 0, 0.3)'
                    }}
                  >
                    {fullDescription}
                  </div>
                )}
              </div>
            )
          })() : (
            <div style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              gap: '8px',
              overflow: 'hidden'
            }}>
              <div style={{
                padding: '2px 6px',
                borderRadius: '4px',
                fontSize: '11px',
                fontWeight: 700,
                background: rightTeam.color || '#3b82f6',
                color: isBrightColor(rightTeam.color || '#3b82f6') ? '#000' : '#fff',
                flexShrink: 0
              }}>
                {teamBLabel}
              </div>
              <span style={{
                fontSize: '13px',
                fontWeight: 600,
                color: 'var(--text)',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                whiteSpace: 'nowrap'
              }}>
                {rightTeam.name || (leftIsHome ? 'Away' : 'Home')}
              </span>
            </div>
          )}
        </div>

        {/* Right: Scoresheet, Menu (Home button moved to MainHeader) */}
        <div className="toolbar-actions" style={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-end', gap: isCompactMode ? '4px' : '12px' }}>
          {/* Scoresheet dropdown menu */}
          <MenuList
            buttonLabel="📄"
            buttonTitle={t('header.scoresheet')}
            menuTitle={t('header.scoresheet')}
            buttonClassName="secondary"
            buttonStyle={{
              background: '#22c55e',
              color: '#000',
              fontWeight: 600,
              padding: '6px 10px',
              fontSize: '16px'
            }}
            showArrow={true}
            position="right"
            items={[
              {
                key: 'scoresheet-preview',
                label: `🔍 ${t('header.preview')}`,
                onClick: async () => {
                  try {
                    const match = data?.match
                    if (!match) {
                      showAlert('No match data available', 'error')
                      return
                    }

                    const scoresheetData = {
                      match,
                      homeTeam: data?.homeTeam,
                      awayTeam: data?.awayTeam,
                      homePlayers: data?.homePlayers || [],
                      awayPlayers: data?.awayPlayers || [],
                      sets: data?.sets || [],
                      events: data?.events || [],
                      sanctions: []
                    }

                    sessionStorage.setItem('scoresheetData', JSON.stringify(scoresheetData))
                    const scoresheetWindow = window.open('/scoresheet', '_blank', 'width=1200,height=900')

                    if (!scoresheetWindow) {
                      showAlert(t('header.allowPopups'), 'warning')
                      return
                    }

                    const errorListener = (event) => {
                      if (event.data && event.data.type === 'SCORESHEET_ERROR') {
                        setScoresheetErrorModal({
                          error: event.data.error || 'Unknown error',
                          details: event.data.details || event.data.stack || ''
                        })
                        window.removeEventListener('message', errorListener)
                      }
                    }
                    window.addEventListener('message', errorListener)
                    setTimeout(() => window.removeEventListener('message', errorListener), 30000)
                  } catch (error) {
                    console.error('Error opening scoresheet:', error)
                    setScoresheetErrorModal({ error: 'Failed to open scoresheet', details: error.message || '' })
                  }
                }
              },
              {
                key: 'scoresheet-print',
                label: `🖨️ ${t('header.print')}`,
                onClick: async () => {
                  try {
                    const match = data?.match
                    if (!match) {
                      showAlert('No match data available', 'error')
                      return
                    }

                    const scoresheetData = {
                      match,
                      homeTeam: data?.homeTeam,
                      awayTeam: data?.awayTeam,
                      homePlayers: data?.homePlayers || [],
                      awayPlayers: data?.awayPlayers || [],
                      sets: data?.sets || [],
                      events: data?.events || [],
                      sanctions: []
                    }

                    sessionStorage.setItem('scoresheetData', JSON.stringify(scoresheetData))
                    const scoresheetWindow = window.open('/scoresheet?action=print', '_blank', 'width=1200,height=900')

                    if (!scoresheetWindow) {
                      showAlert(t('header.allowPopups'), 'warning')
                      return
                    }

                    const errorListener = (event) => {
                      if (event.data && event.data.type === 'SCORESHEET_ERROR') {
                        setScoresheetErrorModal({
                          error: event.data.error || 'Unknown error',
                          details: event.data.details || event.data.stack || ''
                        })
                        window.removeEventListener('message', errorListener)
                      }
                    }
                    window.addEventListener('message', errorListener)
                    setTimeout(() => window.removeEventListener('message', errorListener), 30000)
                  } catch (error) {
                    console.error('Error printing scoresheet:', error)
                    setScoresheetErrorModal({ error: 'Failed to print scoresheet', details: error.message || '' })
                  }
                }
              },
              {
                key: 'scoresheet-save',
                label: `💾 ${t('header.savePdf')}`,
                onClick: async () => {
                  try {
                    const match = data?.match
                    if (!match) {
                      showAlert('No match data available', 'error')
                      return
                    }

                    const scoresheetData = {
                      match,
                      homeTeam: data?.homeTeam,
                      awayTeam: data?.awayTeam,
                      homePlayers: data?.homePlayers || [],
                      awayPlayers: data?.awayPlayers || [],
                      sets: data?.sets || [],
                      events: data?.events || [],
                      sanctions: []
                    }

                    sessionStorage.setItem('scoresheetData', JSON.stringify(scoresheetData))
                    const scoresheetWindow = window.open('/scoresheet?action=save', '_blank', 'width=1200,height=900')

                    if (!scoresheetWindow) {
                      showAlert(t('header.allowPopups'), 'warning')
                      return
                    }

                    const errorListener = (event) => {
                      if (event.data && event.data.type === 'SCORESHEET_ERROR') {
                        setScoresheetErrorModal({
                          error: event.data.error || 'Unknown error',
                          details: event.data.details || event.data.stack || ''
                        })
                        window.removeEventListener('message', errorListener)
                      }
                    }
                    window.addEventListener('message', errorListener)
                    setTimeout(() => window.removeEventListener('message', errorListener), 30000)
                  } catch (error) {
                    console.error('Error saving scoresheet:', error)
                    setScoresheetErrorModal({ error: 'Failed to save scoresheet', details: error.message || '' })
                  }
                }
              }
            ]}
          />
          <MenuList
            buttonLabel="☰"
            buttonTitle="Menu"
            menuTitle="Menu"
            buttonClassName="secondary"
            buttonStyle={{
              background: '#22c55e',
              color: '#000',
              fontWeight: 600,
              width: isCompactMode ? 'auto' : 'auto',
              padding: isCompactMode ? '4px 8px' : (isNarrowMode ? '4px 8px' : '8px 16px'),
              fontSize: isCompactMode ? '14px' : (isNarrowMode ? '12px' : '14px'),
              textAlign: 'center'
            }}
            showArrow={false}
            position="right"
            items={[
              {
                key: 'action-log',
                label: 'Show Action Log',
                onClick: () => {
                  setShowLogs(true)
                }
              },
              {
                key: 'sanctions',
                label: 'Show Sanctions and Results',
                onClick: () => {
                  setShowSanctions(true)
                }
              },
              {
                key: 'manual',
                label: 'Manual Changes',
                onClick: () => {
                  setShowManualPanel(true)
                }
              },
              {
                key: 'remarks',
                label: 'Open Remarks Recording',
                onClick: () => {
                  setShowRemarks(true)
                }
              },
              {
                key: 'stop-match',
                label: t('scoreboard.menu.stopMatch', 'Stop the Match'),
                icon: '⛔',
                onClick: () => {
                  setStopMatchModal('select')
                },
                style: { color: '#ef4444' }
              },
              {
                key: 'rosters',
                label: 'Show Rosters',
                onClick: () => {
                  setShowRosters(true)
                }
              },
              {
                key: 'pins',
                label: 'Show PINs',
                onClick: () => {
                  setShowPinsModal(true)
                }
              },
              ...(onOpenMatchSetup ? [{
                key: 'match-setup',
                label: 'Show Match Setup',
                onClick: () => {
                  onOpenMatchSetup()
                }
              }] : []),
              { separator: true },
              {
                key: 'export',
                label: '📥 Download Game Data (JSON)',
                onClick: async () => {
                  try {
                    // Export all database data
                    const allMatches = await db.matches.toArray()
                    const allTeams = await db.teams.toArray()
                    const allPlayers = await db.players.toArray()
                    const allSets = await db.sets.toArray()
                    const allEvents = await db.events.toArray()
                    const allReferees = await db.referees.toArray()
                    const allScorers = await db.scorers.toArray()

                    const exportData = {
                      exportDate: new Date().toISOString(),
                      matchId: matchId,
                      matches: allMatches,
                      teams: allTeams,
                      players: allPlayers,
                      sets: allSets,
                      events: allEvents,
                      referees: allReferees,
                      scorers: allScorers
                    }

                    // Create a blob and download
                    const jsonString = JSON.stringify(exportData, null, 2)
                    const blob = new Blob([jsonString], { type: 'application/json' })
                    const url = URL.createObjectURL(blob)
                    const link = document.createElement('a')
                    link.href = url
                    link.download = `database_export_${matchId}_${new Date().toISOString().split('T')[0]}.json`
                    document.body.appendChild(link)
                    link.click()
                    document.body.removeChild(link)
                    URL.revokeObjectURL(url)
                  } catch (error) {
                    console.error('Error exporting database:', error)
                    showAlert(t('scoreboard.errors.exportFailed'), 'error')
                  }
                }
              },
              {
                key: 'options',
                label: '⚙️ Options',
                onClick: () => {
                  setShowOptionsInMenu(true)
                }
              }
            ]}
          />
        </div>
      </ScoreboardToolbar>

      {/* Scoresheet Error Modal */}
      {scoresheetErrorModal && (
        <Modal
          title={t('scoreboard.modals.scoresheetError')}
          open={!!scoresheetErrorModal}
          onClose={() => setScoresheetErrorModal(null)}
        >
          <div style={{ padding: '20px' }}>
            <div style={{
              color: '#ef4444',
              fontSize: '16px',
              fontWeight: 600,
              marginBottom: '12px'
            }}>
              {scoresheetErrorModal.error}
            </div>
            {scoresheetErrorModal.details && (
              <div style={{
                marginTop: '12px',
                padding: '12px',
                background: '#1e293b',
                borderRadius: '6px',
                fontFamily: 'monospace',
                fontSize: '12px',
                color: '#cbd5e1',
                whiteSpace: 'pre-wrap',
                wordBreak: 'break-word',
                maxHeight: '400px',
                overflow: 'auto'
              }}>
                {scoresheetErrorModal.details}
              </div>
            )}
            <div style={{ marginTop: '20px', display: 'flex', gap: '10px', justifyContent: 'flex-end' }}>
              <button
                onClick={() => setScoresheetErrorModal(null)}
                style={{
                  padding: '8px 16px',
                  background: 'var(--accent)',
                  color: '#000',
                  border: 'none',
                  borderRadius: '6px',
                  cursor: 'pointer',
                  fontWeight: 600
                }}
              >
                Close
              </button>
            </div>
          </div>
        </Modal>
      )}

      {/* Rosters Modal */}
      {showRosters && (
        <Modal
          title={t('scoreboard.rosters')}
          open={showRosters}
          onClose={() => setShowRosters(false)}
          width={1200}
        >
          {(() => {
            // Separate players and liberos
            const homePlayers = (data.homePlayers || []).filter(p => !p.libero).sort((a, b) => (a.number || 0) - (b.number || 0))
            const homeLiberos = (data.homePlayers || [])
              .filter(p => p.libero)
              .sort((a, b) => (Number(a.number) || 0) - (Number(b.number) || 0))
            const awayPlayers = (data.awayPlayers || []).filter(p => !p.libero).sort((a, b) => (a.number || 0) - (b.number || 0))
            const awayLiberos = (data.awayPlayers || [])
              .filter(p => p.libero)
              .sort((a, b) => (Number(a.number) || 0) - (Number(b.number) || 0))

            // Pad arrays to same length for alignment
            const maxPlayers = Math.max(homePlayers.length, awayPlayers.length)
            const maxLiberos = Math.max(homeLiberos.length, awayLiberos.length)

            const paddedHomePlayers = [...homePlayers, ...Array(maxPlayers - homePlayers.length).fill(null)]
            const paddedAwayPlayers = [...awayPlayers, ...Array(maxPlayers - awayPlayers.length).fill(null)]
            const paddedHomeLiberos = [...homeLiberos, ...Array(maxLiberos - homeLiberos.length).fill(null)]
            const paddedAwayLiberos = [...awayLiberos, ...Array(maxLiberos - awayLiberos.length).fill(null)]

            // Bench officials - sorted by hierarchy: C, AC1, AC2, P, M
            const getRoleOrder = (role) => {
              const roleMap = {
                'Coach': 0,
                'Assistant Coach 1': 1,
                'Assistant Coach 2': 2,
                'Physiotherapist': 3,
                'Medic': 4
              }
              return roleMap[role] ?? 999
            }
            const sortBenchByHierarchy = (bench) => {
              return [...bench].sort((a, b) => getRoleOrder(a.role) - getRoleOrder(b.role))
            }
            const homeBench = sortBenchByHierarchy((data?.match?.bench_home || []).filter(b => b.firstName || b.lastName || b.dob))
            const awayBench = sortBenchByHierarchy((data?.match?.bench_away || []).filter(b => b.firstName || b.lastName || b.dob))
            const maxBench = Math.max(homeBench.length, awayBench.length)
            const paddedHomeBench = [...homeBench, ...Array(maxBench - homeBench.length).fill(null)]
            const paddedAwayBench = [...awayBench, ...Array(maxBench - awayBench.length).fill(null)]

            return (
              <div className="roster-panel">
                {/* Players Section */}
                <div className="roster-tables">
                  <div className="roster-table-wrapper">
                    <h3>{data.homeTeam?.name || t('common.home')} {t('scoreboard.players')}</h3>
                    <table className="roster-table">
                      <thead>
                        <tr>
                          <th>{t('roster.number')}</th>
                          <th>{t('roster.name')}</th>
                          <th>{t('roster.dob')}</th>
                        </tr>
                      </thead>
                      <tbody>
                        {paddedHomePlayers.map((player, idx) => (
                          <tr key={player?.id || `empty-${idx}`}>
                            {player ? (
                              <>
                                <td className="roster-number">
                                  <span>{player.number ?? '—'}</span>
                                  <span className="roster-role">
                                    {player.isCaptain && <span className="roster-badge captain">C</span>}
                                  </span>
                                </td>
                                <td className="roster-name">
                                  {player.lastName || player.name} {player.firstName}
                                </td>
                                <td className="roster-dob">{player.dob || '—'}</td>
                              </>
                            ) : (
                              <td colSpan="3" style={{ height: '40px' }}></td>
                            )}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                  <div className="roster-table-wrapper">
                    <h3>{data.awayTeam?.name || t('common.away')} {t('scoreboard.players')}</h3>
                    <table className="roster-table">
                      <thead>
                        <tr>
                          <th>{t('roster.number')}</th>
                          <th>{t('roster.name')}</th>
                          <th>{t('roster.dob')}</th>
                        </tr>
                      </thead>
                      <tbody>
                        {paddedAwayPlayers.map((player, idx) => (
                          <tr key={player?.id || `empty-${idx}`}>
                            {player ? (
                              <>
                                <td className="roster-number">
                                  <span>{player.number ?? '—'}</span>
                                  <span className="roster-role">
                                    {player.isCaptain && <span className="roster-badge captain">C</span>}
                                  </span>
                                </td>
                                <td className="roster-name">
                                  {player.lastName || player.name} {player.firstName}
                                </td>
                                <td className="roster-dob">{player.dob || '—'}</td>
                              </>
                            ) : (
                              <td colSpan="3" style={{ height: '40px' }}></td>
                            )}
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>

                {/* Liberos Section */}
                {(maxLiberos > 0) && (
                  <div className="roster-tables" style={{ marginTop: '24px' }}>
                    <div className="roster-table-wrapper">
                      <h3>{data.homeTeam?.name || t('common.home')} {t('scoreboard.liberos')}</h3>
                      <table className="roster-table">
                        <thead>
                          <tr>
                            <th>{t('roster.number')}</th>
                            <th>{t('roster.name')}</th>
                            <th>{t('roster.dob')}</th>
                          </tr>
                        </thead>
                        <tbody>
                          {paddedHomeLiberos.map((player, idx) => (
                            <tr key={player?.id || `empty-libero-${idx}`}>
                              {player ? (
                                <>
                                  <td className="roster-number">
                                    <span>{player.number ?? '—'}</span>
                                    <span className="roster-role">
                                      {player.libero === 'libero1' && <span className="roster-badge libero">L1</span>}
                                      {player.libero === 'libero2' && <span className="roster-badge libero">L2</span>}
                                      {player.isCaptain && <span className="roster-badge captain">C</span>}
                                    </span>
                                  </td>
                                  <td className="roster-name">
                                    {player.lastName || player.name} {player.firstName}
                                  </td>
                                  <td className="roster-dob">{player.dob || '—'}</td>
                                </>
                              ) : (
                                <td colSpan="3" style={{ height: '40px' }}></td>
                              )}
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                    <div className="roster-table-wrapper">
                      <h3>{data.awayTeam?.name || t('common.away')} {t('scoreboard.liberos')}</h3>
                      <table className="roster-table">
                        <thead>
                          <tr>
                            <th>{t('roster.number')}</th>
                            <th>{t('roster.name')}</th>
                            <th>{t('roster.dob')}</th>
                          </tr>
                        </thead>
                        <tbody>
                          {paddedAwayLiberos.map((player, idx) => (
                            <tr key={player?.id || `empty-libero-${idx}`}>
                              {player ? (
                                <>
                                  <td className="roster-number">
                                    <span>{player.number ?? '—'}</span>
                                    <span className="roster-role">
                                      {player.libero === 'libero1' && <span className="roster-badge libero">L1</span>}
                                      {player.libero === 'libero2' && <span className="roster-badge libero">L2</span>}
                                      {player.isCaptain && <span className="roster-badge captain">C</span>}
                                    </span>
                                  </td>
                                  <td className="roster-name">
                                    {player.lastName || player.name} {player.firstName}
                                  </td>
                                  <td className="roster-dob">{player.dob || '—'}</td>
                                </>
                              ) : (
                                <td colSpan="3" style={{ height: '40px' }}></td>
                              )}
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                  </div>
                )}
                {/* Bench Officials Section */}
                <div className="bench-officials-section" style={{ marginTop: '32px', paddingTop: '24px', borderTop: '1px solid rgba(255, 255, 255, 0.1)' }}>
                  <div className="roster-tables">
                    <div className="roster-table-wrapper">
                      <h3>{data.homeTeam?.name || t('common.home')} {t('scoreboard.benchOfficials')}</h3>
                      <table className="roster-table">
                        <thead>
                          <tr>
                            <th>{t('roster.role')}</th>
                            <th>{t('roster.name')}</th>
                            <th>{t('roster.dob')}</th>
                          </tr>
                        </thead>
                        <tbody>
                          {paddedHomeBench.map((official, idx) => (
                            <tr key={official ? `home-bench-${idx}` : `empty-bench-${idx}`}>
                              {official ? (
                                <>
                                  <td style={{ textTransform: 'capitalize', fontWeight: 500 }}>{official.role || '—'}</td>
                                  <td>{official.lastName || ''} {official.firstName || ''}</td>
                                  <td>{official.dob || '—'}</td>
                                </>
                              ) : (
                                <td colSpan="3" style={{ height: '40px' }}></td>
                              )}
                            </tr>
                          ))}
                          {maxBench === 0 && (
                            <tr>
                              <td colSpan="3" style={{ textAlign: 'center', color: 'var(--muted)', fontStyle: 'italic' }}>{t('scoreboard.roster.noBenchOfficials')}</td>
                            </tr>
                          )}
                        </tbody>
                      </table>
                    </div>
                    <div className="roster-table-wrapper">
                      <h3>{data.awayTeam?.name || t('common.away')} {t('scoreboard.benchOfficials')}</h3>
                      <table className="roster-table">
                        <thead>
                          <tr>
                            <th>{t('roster.role')}</th>
                            <th>{t('roster.name')}</th>
                            <th>{t('roster.dob')}</th>
                          </tr>
                        </thead>
                        <tbody>
                          {paddedAwayBench.map((official, idx) => (
                            <tr key={official ? `away-bench-${idx}` : `empty-bench-${idx}`}>
                              {official ? (
                                <>
                                  <td style={{ textTransform: 'capitalize', fontWeight: 500 }}>{official.role || '—'}</td>
                                  <td>{official.lastName || ''} {official.firstName || ''}</td>
                                  <td>{official.dob || '—'}</td>
                                </>
                              ) : (
                                <td colSpan="3" style={{ height: '40px' }}></td>
                              )}
                            </tr>
                          ))}
                          {maxBench === 0 && (
                            <tr>
                              <td colSpan="3" style={{ textAlign: 'center', color: 'var(--muted)', fontStyle: 'italic' }}>{t('scoreboard.roster.noBenchOfficials')}</td>
                            </tr>
                          )}
                        </tbody>
                      </table>
                    </div>
                  </div>
                </div>
                {(data?.match?.officials && data.match.officials.length > 0) && (
                  <div className="officials-section" style={{ marginTop: '32px', paddingTop: '24px', borderTop: '1px solid rgba(255, 255, 255, 0.1)' }}>
                    <h3 style={{ margin: '0 0 16px', fontSize: '18px', fontWeight: 600, color: 'var(--text)' }}>Match Officials</h3>
                    <table className="roster-table">
                      <thead>
                        <tr>
                          <th>Role</th>
                          <th>Name</th>
                          <th>Country</th>
                          <th>DOB</th>
                        </tr>
                      </thead>
                      <tbody>
                        {data.match.officials.map((official, idx) => (
                          <tr key={idx}>
                            <td style={{ textTransform: 'capitalize', fontWeight: 500 }}>{official.role || '—'}</td>
                            <td>{official.lastName || ''} {official.firstName || ''}</td>
                            <td>{official.country || '—'}</td>
                            <td>{official.dob || '—'}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}
              </div>
            )
          })()}
        </Modal>
      )}

      {/* Display Mode Suggestion Banner */}
      {showDisplayModeSuggestion && displayModeSuggestion && (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          background: 'linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%)',
          color: '#fff',
          padding: '12px 20px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '16px',
          zIndex: 1000,
          boxShadow: '0 4px 20px rgba(0,0,0,0.3)'
        }}>
          <span style={{ fontSize: '20px' }}>
            {displayModeSuggestion === 'tablet' ? '📱' : '📲'}
          </span>
          <span style={{ fontWeight: 600 }}>
            Small screen detected! Enable {displayModeSuggestion} mode for a better experience?
          </span>
          <button
            onClick={() => enterDisplayMode(displayModeSuggestion)}
            style={{
              padding: '8px 16px',
              fontSize: '14px',
              fontWeight: 600,
              background: '#fff',
              color: '#3b82f6',
              border: 'none',
              borderRadius: '6px',
              cursor: 'pointer'
            }}
          >
            Enable {displayModeSuggestion} mode
          </button>
          <button
            onClick={() => {
              setShowDisplayModeSuggestion(false)
              sessionStorage.setItem('displayModeSuggestionDismissed', 'true')
            }}
            style={{
              padding: '8px 16px',
              fontSize: '14px',
              fontWeight: 600,
              background: 'transparent',
              color: '#fff',
              border: '1px solid rgba(255,255,255,0.5)',
              borderRadius: '6px',
              cursor: 'pointer'
            }}
          >
            Not now
          </button>
        </div>
      )}

      {/* Smartphone Mode Layout */}
      {activeDisplayMode === 'smartphone' ? (() => {
        // Calculate timeout and substitution counts for current set
        const currentLeftTeamKey = leftIsHome ? 'home' : 'away'
        const currentRightTeamKey = leftIsHome ? 'away' : 'home'
        const currentSetIndex = data?.set?.index || 1

        const leftTimeouts = (data?.events || []).filter(e =>
          e.type === 'timeout' && e.setIndex === currentSetIndex && e.payload?.team === currentLeftTeamKey
        ).length

        const rightTimeouts = (data?.events || []).filter(e =>
          e.type === 'timeout' && e.setIndex === currentSetIndex && e.payload?.team === currentRightTeamKey
        ).length

        const leftSubstitutions = (data?.events || []).filter(e =>
          e.type === 'substitution' && e.setIndex === currentSetIndex && e.payload?.team === currentLeftTeamKey
        ).length

        const rightSubstitutions = (data?.events || []).filter(e =>
          e.type === 'substitution' && e.setIndex === currentSetIndex && e.payload?.team === currentRightTeamKey
        ).length

        // Get current lineups for left and right teams
        const leftTeamLineupState = getTeamLineupState(currentLeftTeamKey)
        const rightTeamLineupState = getTeamLineupState(currentRightTeamKey)

        const leftLineup = leftTeamLineupState.currentLineup ?
          Object.entries(leftTeamLineupState.currentLineup).map(([position, number]) => ({ position, number })) :
          []

        const rightLineup = rightTeamLineupState.currentLineup ?
          Object.entries(rightTeamLineupState.currentLineup).map(([position, number]) => ({ position, number })) :
          []

        // Determine who is serving
        const leftServes = data?.set?.servingTeam === currentLeftTeamKey
        const rightServes = data?.set?.servingTeam === currentRightTeamKey

        // Get bench players for left and right teams
        const leftBenchPlayers = leftTeamBench.benchPlayers || []
        const rightBenchPlayers = rightTeamBench.benchPlayers || []

        return (
          <div className="smartphone-layout" style={{
            display: 'flex',
            flexDirection: 'column',
            height: 'calc(100vh - 40px)',
            width: '100%',
            background: 'var(--bg)',
            overflow: 'hidden',
            position: 'relative'
          }}>
            {/* Fixed Header: Menu and Scoresheet buttons */}
            <div style={{
              position: 'sticky',
              top: 0,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              padding: '8px 12px',
              background: 'rgba(15, 23, 42, 0.95)',
              borderBottom: '1px solid rgba(255,255,255,0.1)',
              zIndex: 10,
              flexShrink: 0
            }}>

              <button
                onClick={() => setMenuModal(true)}
                style={{
                  padding: '8px 12px',
                  fontSize: '13px',
                  fontWeight: 600,
                  background: '#22c55e',
                  color: '#000',
                  border: 'none',
                  borderRadius: '6px',
                  cursor: 'pointer'
                }}
              >
                Menu
              </button>

              {/* Set Counter - Center */}
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: '12px',
                fontSize: '16px',
                fontWeight: 700
              }}>
                <span style={{ color: leftTeam?.color || '#ef4444' }}>
                  {setsWon.left}
                </span>
                <span style={{ fontSize: '12px', color: 'rgba(255,255,255,0.5)' }}>{t('scoreboard.labels.sets')}</span>
                <span style={{ color: rightTeam?.color || '#3b82f6' }}>
                  {setsWon.right}
                </span>
              </div>

              <button
                onClick={async () => {
                  const match = data?.match
                  if (!match) return
                  const scoresheetData = {
                    match,
                    homeTeam: data?.homeTeam,
                    awayTeam: data?.awayTeam,
                    homePlayers: data?.homePlayers || [],
                    awayPlayers: data?.awayPlayers || [],
                    sets: data?.sets || [],
                    events: data?.events || [],
                    sanctions: []
                  }
                  sessionStorage.setItem('scoresheetData', JSON.stringify(scoresheetData))
                  window.open('/scoresheet', '_blank', 'width=1200,height=900')
                }}
                style={{
                  padding: '8px 12px',
                  fontSize: '13px',
                  fontWeight: 600,
                  background: '#22c55e',
                  color: '#000',
                  border: 'none',
                  borderRadius: '6px',
                  cursor: 'pointer'
                }}
              >
                Sheet
              </button>
            </div>

            {/* Main 3-Column Layout */}
            <div style={{
              display: 'flex',
              flex: 1,
              minHeight: 0,
              overflow: 'hidden'
            }}>
              {/* Left Team Column */}
              <div style={{
                flex: '0 0 30%',
                maxWidth: '30%',
                display: 'flex',
                flexDirection: 'column',
                padding: '8px 8px 32px 8px',
                background: 'rgba(15, 23, 42, 0.4)',
                borderRight: '1px solid rgba(255,255,255,0.1)',
                overflow: 'auto'
              }}>
                <div style={{
                  background: leftTeam?.color || '#ef4444',
                  color: isBrightColor(leftTeam?.color || '#ef4444') ? '#000' : '#fff',
                  padding: '8px',
                  borderRadius: '6px',
                  textAlign: 'center',
                  fontWeight: 700,
                  fontSize: '14px',
                  marginBottom: '8px'
                }}>
                  {leftTeam?.shortName || leftTeam?.name || 'Team A'}
                </div>

                {/* TO/SUB Counter */}
                <div style={{ display: 'flex', gap: '4px', marginBottom: '8px' }}>
                  <div style={{
                    flex: 1,
                    background: 'rgba(255,255,255,0.1)',
                    padding: '6px',
                    borderRadius: '4px',
                    textAlign: 'center',
                    fontSize: '12px'
                  }}>
                    <div style={{ fontWeight: 600 }}>{t('scoreboard.labels.to')}</div>
                    <div style={{ fontSize: '17px', fontWeight: 700 }}>{leftTimeouts}</div>
                  </div>
                  <div style={{
                    flex: 1,
                    background: 'rgba(255,255,255,0.1)',
                    padding: '6px',
                    borderRadius: '4px',
                    textAlign: 'center',
                    fontSize: '12px'
                  }}>
                    <div style={{ fontWeight: 600 }}>{t('scoreboard.labels.sub')}</div>
                    <div style={{ fontSize: '17px', fontWeight: 700 }}>{leftSubstitutions}</div>
                  </div>
                </div>

                {/* Team Sanctions Button */}
                <button
                  onClick={() => setLeftTeamSanctionsExpanded(!leftTeamSanctionsExpanded)}
                  style={{
                    width: '100%',
                    padding: '8px',
                    fontSize: '13px',
                    fontWeight: 600,
                    background: leftTeamSanctionsExpanded ? 'rgba(239, 68, 68, 0.3)' : 'rgba(255,255,255,0.1)',
                    color: 'var(--text)',
                    border: '1px solid rgba(255,255,255,0.2)',
                    borderRadius: '6px',
                    cursor: 'pointer',
                    marginBottom: '4px'
                  }}
                >
                  {t('scoreboard.sanctions.teamSanctions')} {leftTeamSanctionsExpanded ? '▲' : '▼'}
                </button>

                {leftTeamSanctionsExpanded && (
                  <div style={{
                    background: 'rgba(15, 23, 42, 0.6)',
                    borderRadius: '6px',
                    padding: '8px',
                    marginBottom: '8px',
                    fontSize: '12px'
                  }}>
                    <button
                      className="sanction-team-btn"
                      onClick={() => handleTeamSanction(leftIsHome ? 'home' : 'away', 'improper_request')}
                      style={{
                        width: '100%',
                        padding: '6px',
                        marginBottom: '4px',
                        background: 'rgba(255,255,255,0.1)',
                        color: 'var(--text)',
                        border: 'none',
                        borderRadius: '4px',
                        cursor: 'pointer'
                      }}
                    >
                      {t('scoreboard.sanctions.improperRequest')}
                    </button>
                    <button
                      className="sanction-team-btn"
                      onClick={() => handleTeamSanction(leftIsHome ? 'home' : 'away', 'delay_warning')}
                      style={{
                        width: '100%',
                        padding: '6px',
                        marginBottom: '4px',
                        background: 'rgba(234, 179, 8, 0.3)',
                        color: '#fbbf24',
                        border: 'none',
                        borderRadius: '4px',
                        cursor: 'pointer'
                      }}
                    >
                      {t('scoreboard.sanctions.delayWarning')}
                    </button>
                    <button
                      className="sanction-team-btn"
                      onClick={() => handleTeamSanction(leftIsHome ? 'home' : 'away', 'delay_penalty')}
                      style={{
                        width: '100%',
                        padding: '6px',
                        background: 'rgba(239, 68, 68, 0.3)',
                        color: '#ef4444',
                        border: 'none',
                        borderRadius: '4px',
                        cursor: 'pointer'
                      }}
                    >
                      {t('scoreboard.sanctions.delayPenalty')}
                    </button>
                  </div>
                )}

                {/* Designate Captain on Court Button - shown when team captain is NOT on court */}
                {/* Button always shows when captain is off court (setting only controls automatic prompts) */}
                {/* Only show if lineup is set (players on court) */}
                {!captainOnCourtStatus[leftIsHome ? 'home' : 'away'].captainOnCourt && leftTeamLineupSet && (
                  <button
                    onClick={() => setCaptainOnCourtModal({ team: leftIsHome ? 'home' : 'away' })}
                    style={{
                      width: '100%',
                      padding: '8px',
                      fontSize: '11px',
                      fontWeight: 600,
                      background: 'rgba(251, 191, 36, 0.2)',
                      color: '#fbbf24',
                      border: '1px solid rgba(251, 191, 36, 0.4)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      marginBottom: '4px'
                    }}
                  >
                    {t('scoreboard.captainOnCourt.designate', 'Game Captain')}
                  </button>
                )}

                {/* Show Bench Button */}
                <button
                  onClick={() => setLeftTeamBenchExpanded(!leftTeamBenchExpanded)}
                  style={{
                    width: '100%',
                    padding: '8px',
                    fontSize: '12px',
                    fontWeight: 600,
                    background: leftTeamBenchExpanded ? 'rgba(59, 130, 246, 0.3)' : 'rgba(255,255,255,0.1)',
                    color: 'var(--text)',
                    border: '1px solid rgba(255,255,255,0.2)',
                    borderRadius: '6px',
                    cursor: 'pointer'
                  }}
                >
                  {t('scoreboard.roster.showBench')} {leftTeamBenchExpanded ? '▲' : '▼'}
                </button>

                {leftTeamBenchExpanded && (
                  <div style={{
                    background: 'rgba(15, 23, 42, 0.6)',
                    borderRadius: '6px',
                    padding: '8px',
                    marginTop: '4px',
                    fontSize: '11px'
                  }}>
                    <div style={{ fontWeight: 600, marginBottom: '4px' }}>{t('scoreboard.roster.benchPlayers')}:</div>
                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px' }}>
                      {leftBenchPlayers.filter(p => p.role !== 'libero').map(p => (
                        <span
                          key={p.id}
                          onClick={() => {
                            // Open bench player action menu
                            setBenchPlayerActionMenu({
                              team: leftIsHome ? 'home' : 'away',
                              playerNumber: p.number,
                              element: null,
                              x: window.innerWidth / 2,
                              y: window.innerHeight / 2,
                              side: 'left'
                            })
                          }}
                          style={{
                            padding: '4px 8px',
                            background: 'rgba(255,255,255,0.1)',
                            borderRadius: '4px',
                            cursor: 'pointer'
                          }}
                        >
                          #{p.number}
                        </span>
                      ))}
                    </div>
                    {leftBenchPlayers.filter(p => p.role === 'libero').length > 0 && (
                      <>
                        <div style={{ fontWeight: 600, marginTop: '8px', marginBottom: '4px', color: '#22c55e' }}>{t('scoreboard.roster.liberoLabel')}:</div>
                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px' }}>
                          {leftBenchPlayers.filter(p => p.role === 'libero').map(p => (
                            <span
                              key={p.id}
                              style={{
                                padding: '4px 8px',
                                background: 'rgba(34, 197, 94, 0.3)',
                                borderRadius: '4px',
                                color: '#22c55e'
                              }}
                            >
                              #{p.number}
                            </span>
                          ))}
                        </div>
                      </>
                    )}
                  </div>
                )}
              </div>

              {/* Center Column */}
              <div style={{
                flex: '0 0 40%',
                maxWidth: '40%',
                display: 'flex',
                flexDirection: 'column',
                padding: '8px 8px 32px 8px',
                overflow: 'auto',
                alignItems: 'center'
              }}>
                {/* Score Counter */}
                <div style={{
                  display: 'flex',
                  justifyContent: 'center',
                  alignItems: 'center',
                  gap: '24px',
                  marginBottom: '12px',
                  width: '100%'
                }}>
                  <span style={{
                    fontSize: '48px',
                    fontWeight: 700,
                    color: leftTeam?.color || '#ef4444'
                  }}>
                    {leftIsHome ? (data?.set?.homePoints || 0) : (data?.set?.awayPoints || 0)}
                  </span>
                  <span style={{ fontSize: '24px', color: 'rgba(255,255,255,0.4)' }}>-</span>
                  <span style={{
                    fontSize: '48px',
                    fontWeight: 700,
                    color: rightTeam?.color || '#3b82f6'
                  }}>
                    {leftIsHome ? (data?.set?.awayPoints || 0) : (data?.set?.homePoints || 0)}
                  </span>
                </div>

                {/* Mini Court Position Tables */}
                {!(betweenSetsCountdown && data?.set?.index === 5 && !data?.match?.set5FirstServe) && (
                  <div style={{
                    display: 'flex',
                    gap: '8px',
                    marginBottom: '12px',
                    justifyContent: 'center',
                    width: '100%',
                    flexWrap: 'wrap'
                  }}>
                    {/* Left Team Positions */}
                    <div style={{
                      background: 'rgba(15, 23, 42, 0.6)',
                      borderRadius: '6px',
                      padding: '8px',
                      border: `2px solid ${leftTeam?.color || '#ef4444'}`
                    }}>
                      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '2px', fontSize: '11px' }}>
                        {['IV', 'III', 'II'].map(pos => {
                          const player = leftLineup?.find(p => p.position === pos)
                          const isServing = leftServes && pos === 'I'
                          return (
                            <div key={pos} style={{
                              padding: '4px',
                              background: isServing ? 'rgba(234, 179, 8, 0.3)' : 'rgba(255,255,255,0.1)',
                              borderRadius: '2px',
                              textAlign: 'center'
                            }}>
                              <div style={{ fontSize: '8px', color: 'rgba(255,255,255,0.5)' }}>{pos}</div>
                              <div style={{ fontWeight: 600 }}>{player?.number || '-'}</div>
                            </div>
                          )
                        })}
                        {['V', 'VI', 'I'].map(pos => {
                          const player = leftLineup?.find(p => p.position === pos)
                          const isServing = leftServes && pos === 'I'
                          return (
                            <div key={pos} style={{
                              padding: '4px',
                              background: isServing ? 'rgba(234, 179, 8, 0.3)' : 'rgba(255,255,255,0.1)',
                              borderRadius: '2px',
                              textAlign: 'center'
                            }}>
                              <div style={{ fontSize: '8px', color: 'rgba(255,255,255,0.5)' }}>{pos}</div>
                              <div style={{ fontWeight: 600 }}>{player?.number || '-'}</div>
                            </div>
                          )
                        })}
                      </div>
                    </div>

                    {/* Right Team Positions */}
                    <div style={{
                      background: 'rgba(15, 23, 42, 0.6)',
                      borderRadius: '6px',
                      padding: '8px',
                      border: `2px solid ${rightTeam?.color || '#3b82f6'}`
                    }}>
                      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '2px', fontSize: '11px' }}>
                        {['II', 'III', 'IV'].map(pos => {
                          const player = rightLineup?.find(p => p.position === pos)
                          const isServing = rightServes && pos === 'I'
                          return (
                            <div key={pos} style={{
                              padding: '4px',
                              background: isServing ? 'rgba(234, 179, 8, 0.3)' : 'rgba(255,255,255,0.1)',
                              borderRadius: '2px',
                              textAlign: 'center'
                            }}>
                              <div style={{ fontSize: '8px', color: 'rgba(255,255,255,0.5)' }}>{pos}</div>
                              <div style={{ fontWeight: 600 }}>{player?.number || '-'}</div>
                            </div>
                          )
                        })}
                        {['I', 'VI', 'V'].map(pos => {
                          const player = rightLineup?.find(p => p.position === pos)
                          const isServing = rightServes && pos === 'I'
                          return (
                            <div key={pos} style={{
                              padding: '4px',
                              background: isServing ? 'rgba(234, 179, 8, 0.3)' : 'rgba(255,255,255,0.1)',
                              borderRadius: '2px',
                              textAlign: 'center'
                            }}>
                              <div style={{ fontSize: '8px', color: 'rgba(255,255,255,0.5)' }}>{pos}</div>
                              <div style={{ fontWeight: 600 }}>{player?.number || '-'}</div>
                            </div>
                          )
                        })}
                      </div>
                    </div>
                  </div>
                )}

                {/* Rally Controls */}
                <div style={{
                  display: 'flex',
                  flexDirection: 'column',
                  gap: '8px',
                  marginTop: 'auto'
                }}>
                  {timeoutModal && timeoutModal.started ? (
                    <>
                      <div style={{
                        fontSize: '14px',
                        fontWeight: 600,
                        color: 'var(--muted)',
                        textAlign: 'center',
                        marginBottom: '8px'
                      }}>
                        Time-out — {timeoutModal.team === 'home' ? (data?.homeTeam?.name || 'Home') : (data?.awayTeam?.name || 'Away')}
                      </div>
                      <div style={{
                        fontSize: '32px',
                        fontWeight: 700,
                        color: timeoutModal.countdown <= 10 ? '#ef4444' : 'var(--accent)',
                        textAlign: 'center',
                        fontFamily: getScoreFont()
                      }}>
                        {formatTimeout(timeoutModal.countdown)}
                      </div>
                      {/* Progress bar */}
                      <div style={{
                        width: '60%',
                        height: '8px',
                        background: 'rgba(255, 255, 255, 0.15)',
                        borderRadius: '4px',
                        overflow: 'hidden',
                        marginTop: '8px',
                        marginBottom: '12px',
                        marginLeft: 'auto',
                        marginRight: 'auto'
                      }}>
                        <div style={{
                          width: `${(timeoutModal.countdown / 30) * 100}%`,
                          height: '100%',
                          background: timeoutModal.countdown <= 10 ? '#ef4444' : 'var(--accent)',
                          borderRadius: '4px',
                          transition: 'width 1s linear, background 0.3s',
                          marginLeft: 'auto'
                        }} />
                      </div>
                      <button onClick={stopTimeout} style={{
                        padding: '12px',
                        fontSize: '14px',
                        fontWeight: 600,
                        background: '#ef4444',
                        color: '#fff',
                        border: 'none',
                        borderRadius: '8px',
                        cursor: 'pointer'
                      }}>
                        Stop Timeout
                      </button>
                    </>
                  ) : betweenSetsCountdown ? (
                    <>

                      <div style={{
                        fontSize: '33px',
                        fontWeight: 700,
                        color: betweenSetsCountdown.countdown <= 30 ? '#ef4444' : 'var(--accent)',
                        textAlign: 'center',
                        fontFamily: getScoreFont()
                      }}>
                        {betweenSetsCountdown.countdown <= 0 ? "0" : formatCountdown(betweenSetsCountdown.countdown)}
                      </div>
                      {/* Progress bar */}
                      <div style={{
                        width: '60%',
                        height: '8px',
                        background: 'rgba(255, 255, 255, 0.15)',
                        borderRadius: '4px',
                        overflow: 'hidden',
                        marginTop: '8px',
                        marginBottom: '12px',
                        marginLeft: 'auto',
                        marginRight: 'auto'
                      }}>
                        <div style={{
                          width: `${setIntervalDuration > 0 ? (betweenSetsCountdown.countdown / setIntervalDuration) * 100 : 0}%`,
                          height: '100%',
                          background: betweenSetsCountdown.countdown <= 30 ? '#ef4444' : 'var(--accent)',
                          borderRadius: '4px',
                          transition: 'width 1s linear, background 0.3s',
                          marginLeft: 'auto'
                        }} />
                      </div>

                      {/* Set 5 Coin Toss Logic */}
                      {data?.set?.index === 5 && !data?.match?.set5FirstServe ? (
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '8px', width: '100%' }}>

                          {/* Helper Helper Vars */}
                          {(() => {
                            const teamAKey = data?.match?.coinTossTeamA || 'home'
                            const teamBKey = teamAKey === 'home' ? 'away' : 'home'
                            // Names
                            const teamAName = teamAKey === 'home' ? (data?.homeTeam?.name || 'Home') : (data?.awayTeam?.name || 'Away')
                            const teamBName = teamAKey === 'home' ? (data?.awayTeam?.name || 'Away') : (data?.homeTeam?.name || 'Home')

                            // Draft State
                            const draftSideA = set5CoinTossDraft.sideA // 'left' or 'right'
                            const draftLeftTeamKey = draftSideA === 'left' ? teamAKey : teamBKey
                            const draftLeftName = draftSideA === 'left' ? teamAName : teamBName
                            const draftRightName = draftSideA === 'left' ? teamBName : teamAName

                            const draftServeTeamKey = set5CoinTossDraft.serve === 'A' ? teamAKey : teamBKey
                            const draftServeName = set5CoinTossDraft.serve === 'A' ? teamAName : teamBName

                            return (
                              <>
                                <div style={{ textAlign: 'center', fontSize: '13px', color: 'var(--muted)', marginBottom: '4px' }}>
                                  Set 5 Coin Toss Pending
                                </div>

                                {/* Switch Sides */}
                                <button
                                  onClick={() => setSet5CoinTossDraft(prev => ({ ...prev, sideA: prev.sideA === 'left' ? 'right' : 'left' }))}
                                  style={{
                                    padding: '12px',
                                    background: 'rgba(255,255,255,0.1)',
                                    color: '#fff',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center'
                                  }}
                                >
                                  <span>&lt; {draftLeftName}</span>
                                  <span style={{ fontWeight: 'bold' }}>SWITCH SIDES</span>
                                  <span>{draftRightName} &gt;</span>
                                </button>

                                {/* Switch Serve */}
                                <button
                                  onClick={() => setSet5CoinTossDraft(prev => ({ ...prev, serve: prev.serve === 'A' ? 'B' : 'A' }))}
                                  style={{
                                    padding: '12px',
                                    background: 'rgba(255,255,255,0.1)',
                                    color: '#fff',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '8px',
                                    cursor: 'pointer'
                                  }}
                                >
                                  Serve: <span style={{ fontWeight: 'bold', color: 'var(--accent)' }}>{draftServeName}</span>
                                </button>

                                {/* Confirm */}
                                <button
                                  onClick={async () => {
                                    // Save to DB
                                    // 1. setLeftTeamOverrides
                                    // 2. set5FirstServe
                                    const sideVal = set5CoinTossDraft.sideA === 'left' ? 'A' : 'B'
                                    const overrides = data?.match?.setLeftTeamOverrides || {}

                                    await db.matches.update(matchId, {
                                      setLeftTeamOverrides: { ...overrides, 5: sideVal },
                                      set5FirstServe: set5CoinTossDraft.serve // 'A' or 'B'
                                    })
                                    // This syncs via the regular queue mechanism if the Scoreboard/App handles it, 
                                    // but Scoreboard doesn't auto-sync DB changes to queue usually without a hook?
                                    // Actually, CoinToss.jsx manually adds to sync_queue.
                                    // The Scoreboard uses useSyncQueue but usually for 'logged events'.
                                    // We should ideally add a sync task here or rely on the fact that match updates usually aren't synced unless triggered?
                                    // Wait, Scoreboard.jsx line 50: `flushSyncQueue`.
                                    // The user might be online.
                                    // I'll stick to updating the local DB for now, which updates the UI.
                                    // The sync logic for generic match updates might be elsewhere.
                                    // Given existing patterns, direct DB update renders the changes.
                                  }}
                                  style={{
                                    marginTop: '8px',
                                    padding: '16px',
                                    background: 'var(--accent)',
                                    color: '#000',
                                    border: 'none',
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    fontWeight: 700
                                  }}
                                >
                                  CONFIRM COIN TOSS
                                </button>
                              </>
                            )
                          })()}
                        </div>
                      ) : (
                        <button onClick={endSetInterval} style={{
                          padding: '12px',
                          fontSize: '15px',
                          fontWeight: 600,
                          background: 'var(--accent)',
                          color: '#000',
                          border: 'none',
                          borderRadius: '8px',
                          cursor: 'pointer'
                        }}>
                          End Set Interval
                        </button>
                      )}
                    </>
                  ) : rallyStatus === 'idle' ? (
                    <button
                      onClick={handleStartRally}
                      disabled={isFirstRally && (!leftTeamLineupSet || !rightTeamLineupSet)}
                      style={{
                        width: '100%',
                        height: '56px',
                        padding: '16px',
                        fontSize: '14px',
                        fontWeight: 700,
                        background: 'var(--accent)',
                        color: '#000',
                        border: 'none',
                        borderRadius: '8px',
                        cursor: 'pointer',
                        opacity: (isFirstRally && (!leftTeamLineupSet || !rightTeamLineupSet)) ? 0.5 : 1
                      }}
                    >
                      {isFirstRally ? 'Start Set' : 'Start Rally'}
                    </button>
                  ) : (
                    <>
                      <div style={{ display: 'flex', gap: '8px' }}>
                        <button
                          onClick={() => handlePoint(leftIsHome ? 'home' : 'away')}
                          style={{
                            flex: 1,
                            padding: '16px',
                            fontSize: '14px',
                            fontWeight: 700,
                            background: leftTeam?.color || '#ef4444',
                            color: isBrightColor(leftTeam?.color || '#ef4444') ? '#000' : '#fff',
                            border: 'none',
                            borderRadius: '8px',
                            cursor: 'pointer'
                          }}
                        >
                          Point {leftTeam?.shortName || 'L'}
                        </button>
                        <button
                          onClick={() => handlePoint(leftIsHome ? 'away' : 'home')}
                          style={{
                            flex: 1,
                            padding: '16px',
                            fontSize: '14px',
                            fontWeight: 700,
                            background: rightTeam?.color || '#3b82f6',
                            color: isBrightColor(rightTeam?.color || '#3b82f6') ? '#000' : '#fff',
                            border: 'none',
                            borderRadius: '8px',
                            cursor: 'pointer'
                          }}
                        >
                          Point {rightTeam?.shortName || 'R'}
                        </button>
                      </div>
                      <div style={{ display: 'flex', gap: '8px' }}>
                        <button
                          onClick={() => handleTimeout(leftIsHome ? 'home' : 'away')}
                          disabled={leftTimeouts >= 1}
                          style={{
                            flex: 1,
                            padding: '10px',
                            fontSize: '12px',
                            fontWeight: 600,
                            background: 'rgba(255,255,255,0.1)',
                            color: 'var(--text)',
                            border: '1px solid rgba(255,255,255,0.2)',
                            borderRadius: '6px',
                            cursor: leftTimeouts >= 1 ? 'not-allowed' : 'pointer',
                            opacity: leftTimeouts >= 1 ? 0.5 : 1
                          }}
                        >
                          TO Left
                        </button>
                        <button
                          onClick={handleUndo}
                          disabled={!canUndo}
                          style={{
                            padding: '10px',
                            fontSize: '12px',
                            fontWeight: 600,
                            background: 'rgba(239, 68, 68, 0.2)',
                            color: '#ef4444',
                            border: '1px solid rgba(239, 68, 68, 0.3)',
                            borderRadius: '6px',
                            cursor: canUndo ? 'pointer' : 'not-allowed',
                            opacity: canUndo ? 1 : 0.5
                          }}
                        >
                          Undo
                        </button>
                        <button
                          onClick={() => handleTimeout(leftIsHome ? 'away' : 'home')}
                          disabled={rightTimeouts >= 1}
                          style={{
                            flex: 1,
                            padding: '10px',
                            fontSize: '12px',
                            fontWeight: 600,
                            background: 'rgba(255,255,255,0.1)',
                            color: 'var(--text)',
                            border: '1px solid rgba(255,255,255,0.2)',
                            borderRadius: '6px',
                            cursor: rightTimeouts >= 1 ? 'not-allowed' : 'pointer',
                            opacity: rightTimeouts >= 1 ? 0.5 : 1
                          }}
                        >
                          TO Right
                        </button>
                      </div>
                    </>
                  )}
                </div>
              </div>

              {/* Right Team Column */}
              <div style={{
                flex: '0 0 30%',
                maxWidth: '30%',
                display: 'flex',
                flexDirection: 'column',
                padding: '8px 8px 32px 8px',
                background: 'rgba(15, 23, 42, 0.4)',
                borderLeft: '1px solid rgba(255,255,255,0.1)',
                overflow: 'auto'
              }}>
                <div style={{
                  background: rightTeam?.color || '#3b82f6',
                  color: isBrightColor(rightTeam?.color || '#3b82f6') ? '#000' : '#fff',
                  padding: '8px',
                  borderRadius: '6px',
                  textAlign: 'center',
                  fontWeight: 700,
                  fontSize: '14px',
                  marginBottom: '8px'
                }}>
                  {rightTeam?.shortName || rightTeam?.name || 'Team B'}
                </div>

                {/* TO/SUB Counter */}
                <div style={{ display: 'flex', gap: '4px', marginBottom: '8px' }}>
                  <div style={{
                    flex: 1,
                    background: 'rgba(255,255,255,0.1)',
                    padding: '6px',
                    borderRadius: '4px',
                    textAlign: 'center',
                    fontSize: '12px'
                  }}>
                    <div style={{ fontWeight: 600 }}>{t('scoreboard.labels.to')}</div>
                    <div style={{ fontSize: '17px', fontWeight: 700 }}>{rightTimeouts}</div>
                  </div>
                  <div style={{
                    flex: 1,
                    background: 'rgba(255,255,255,0.1)',
                    padding: '6px',
                    borderRadius: '4px',
                    textAlign: 'center',
                    fontSize: '12px'
                  }}>
                    <div style={{ fontWeight: 600 }}>{t('scoreboard.labels.sub')}</div>
                    <div style={{ fontSize: '17px', fontWeight: 700 }}>{rightSubstitutions}</div>
                  </div>
                </div>

                {/* Team Sanctions Button */}
                <button
                  onClick={() => setRightTeamSanctionsExpanded(!rightTeamSanctionsExpanded)}
                  style={{
                    width: '100%',
                    padding: '8px',
                    fontSize: '13px',
                    fontWeight: 600,
                    background: rightTeamSanctionsExpanded ? 'rgba(239, 68, 68, 0.3)' : 'rgba(255,255,255,0.1)',
                    color: 'var(--text)',
                    border: '1px solid rgba(255,255,255,0.2)',
                    borderRadius: '6px',
                    cursor: 'pointer',
                    marginBottom: '4px'
                  }}
                >
                  {t('scoreboard.sanctions.teamSanctions')} {rightTeamSanctionsExpanded ? '▲' : '▼'}
                </button>

                {rightTeamSanctionsExpanded && (
                  <div style={{
                    background: 'rgba(15, 23, 42, 0.6)',
                    borderRadius: '6px',
                    padding: '8px',
                    marginBottom: '8px',
                    fontSize: '12px'
                  }}>
                    <button
                      className="sanction-team-btn"
                      onClick={() => handleTeamSanction(leftIsHome ? 'away' : 'home', 'improper_request')}
                      style={{
                        width: '100%',
                        padding: '6px',
                        marginBottom: '4px',
                        background: 'rgba(255,255,255,0.1)',
                        color: 'var(--text)',
                        border: 'none',
                        borderRadius: '4px',
                        cursor: 'pointer'
                      }}
                    >
                      {t('scoreboard.sanctions.improperRequest')}
                    </button>
                    <button
                      className="sanction-team-btn"
                      onClick={() => handleTeamSanction(leftIsHome ? 'away' : 'home', 'delay_warning')}
                      style={{
                        width: '100%',
                        padding: '6px',
                        marginBottom: '4px',
                        background: 'rgba(234, 179, 8, 0.3)',
                        color: '#fbbf24',
                        border: 'none',
                        borderRadius: '4px',
                        cursor: 'pointer'
                      }}
                    >
                      {t('scoreboard.sanctions.delayWarning')}
                    </button>
                    <button
                      className="sanction-team-btn"
                      onClick={() => handleTeamSanction(leftIsHome ? 'away' : 'home', 'delay_penalty')}
                      style={{
                        width: '100%',
                        padding: '6px',
                        background: 'rgba(239, 68, 68, 0.3)',
                        color: '#ef4444',
                        border: 'none',
                        borderRadius: '4px',
                        cursor: 'pointer'
                      }}
                    >
                      {t('scoreboard.sanctions.delayPenalty')}
                    </button>
                  </div>
                )}

                {/* Designate Captain on Court Button - shown when team captain is NOT on court */}
                {/* Button always shows when captain is off court (setting only controls automatic prompts) */}
                {/* Only show if lineup is set (players on court) */}
                {!captainOnCourtStatus[leftIsHome ? 'away' : 'home'].captainOnCourt && rightTeamLineupSet && (
                  <button
                    onClick={() => setCaptainOnCourtModal({ team: leftIsHome ? 'away' : 'home' })}
                    style={{
                      width: '100%',
                      padding: '8px',
                      fontSize: '11px',
                      fontWeight: 600,
                      background: 'rgba(251, 191, 36, 0.2)',
                      color: '#fbbf24',
                      border: '1px solid rgba(251, 191, 36, 0.4)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      marginBottom: '4px'
                    }}
                  >
                    {t('scoreboard.captainOnCourt.designate', 'Game Captain')}
                  </button>
                )}

                {/* Show Bench Button */}
                <button
                  onClick={() => setRightTeamBenchExpanded(!rightTeamBenchExpanded)}
                  style={{
                    width: '100%',
                    padding: '8px',
                    fontSize: '12px',
                    fontWeight: 600,
                    background: rightTeamBenchExpanded ? 'rgba(59, 130, 246, 0.3)' : 'rgba(255,255,255,0.1)',
                    color: 'var(--text)',
                    border: '1px solid rgba(255,255,255,0.2)',
                    borderRadius: '6px',
                    cursor: 'pointer'
                  }}
                >
                  {t('scoreboard.roster.showBench')} {rightTeamBenchExpanded ? '▲' : '▼'}
                </button>

                {rightTeamBenchExpanded && (
                  <div style={{
                    background: 'rgba(15, 23, 42, 0.6)',
                    borderRadius: '6px',
                    padding: '8px',
                    marginTop: '4px',
                    fontSize: '11px'
                  }}>
                    <div style={{ fontWeight: 600, marginBottom: '4px' }}>{t('scoreboard.roster.benchPlayers')}:</div>
                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px' }}>
                      {rightBenchPlayers.filter(p => p.role !== 'libero').map(p => (
                        <span
                          key={p.id}
                          onClick={() => {
                            setBenchPlayerActionMenu({
                              team: leftIsHome ? 'away' : 'home',
                              playerNumber: p.number,
                              element: null,
                              x: window.innerWidth / 2,
                              y: window.innerHeight / 2,
                              side: 'right'
                            })
                          }}
                          style={{
                            padding: '4px 8px',
                            background: 'rgba(255,255,255,0.1)',
                            borderRadius: '4px',
                            cursor: 'pointer'
                          }}
                        >
                          #{p.number}
                        </span>
                      ))}
                    </div>
                    {rightBenchPlayers.filter(p => p.role === 'libero').length > 0 && (
                      <>
                        <div style={{ fontWeight: 600, marginTop: '8px', marginBottom: '4px', color: '#22c55e' }}>{t('scoreboard.roster.liberoLabel')}:</div>
                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px' }}>
                          {rightBenchPlayers.filter(p => p.role === 'libero').map(p => (
                            <span
                              key={p.id}
                              style={{
                                padding: '4px 8px',
                                background: 'rgba(34, 197, 94, 0.3)',
                                borderRadius: '4px',
                                color: '#22c55e'
                              }}
                            >
                              #{p.number}
                            </span>
                          ))}
                        </div>
                      </>
                    )}
                  </div>
                )}
              </div>
            </div>
          </div>
        )
      })() : (
        <div className="match-content" style={activeDisplayMode === 'tablet' ? { transform: 'scale(0.85)', transformOrigin: 'top center', height: 'calc(100vh - 40px)', maxHeight: '100vh', overflow: 'hidden' } : {}}>
          <ScoreboardTeamColumn side="left">
            <div className="team-info" style={{ overflow: 'hidden' }}>
              <div
                style={{
                  display: 'inline-flex',
                  alignItems: 'center',
                  gap: '6px',
                  padding: isCompactMode ? '4px 8px' : '6px 12px',
                  background: leftTeam.color || '#ef4444',
                  color: isBrightColor(leftTeam.color || '#ef4444') ? '#000' : '#fff',
                  borderRadius: '6px',
                  fontWeight: 600,
                  fontSize: isCompactMode ? '11px' : '14px',
                  marginBottom: '8px',
                  maxWidth: '100%',
                  overflow: 'hidden',
                  whiteSpace: 'nowrap',
                  textOverflow: 'ellipsis'
                }}
              >
                <span style={{ flexShrink: 0 }}>{teamALabel}</span>
                <span style={{ flexShrink: 0 }}>-</span>
                <span style={{ overflow: 'hidden', textOverflow: 'ellipsis', minWidth: isNarrowMode ? '30px' : '40px' }}>{teamAShortName}</span>
                {(isCompactMode || headerCollapsed) && (
                  <span style={{
                    marginLeft: '4px',
                    padding: '2px 6px',
                    background: 'rgba(255, 255, 255, 0.2)',
                    borderRadius: '4px',
                    fontWeight: 700,
                    flexShrink: 0
                  }}>
                    {setsWon.left}
                  </span>
                )}
              </div>
            </div>
            <div style={{ display: 'flex', gap: '4px', marginBottom: '8px' }}>
              <div
                onClick={() => {
                  // Clicking calls timeout if available
                  const canCallTimeout = getTimeoutsUsed('left') < 2 && rallyStatus !== 'in_play' && !isRallyReplayed
                  if (canCallTimeout) {
                    handleTimeout('left')
                  }
                }}
                className="to-sub-counter"
                style={{
                  flex: 1,
                  background: getTimeoutsUsed('left') >= 2
                    ? 'rgba(239, 68, 68, 0.2)'
                    : (rallyStatus === 'in_play' || isRallyReplayed
                      ? 'rgba(255, 255, 255, 0.05)'
                      : 'rgba(34, 197, 94, 0.2)'),
                  borderRadius: (isCompactMode || isShortHeight) ? '4px' : '8px',
                  padding: (isCompactMode || isShortHeight) ? '4px' : '12px',
                  textAlign: 'center',
                  border: getTimeoutsUsed('left') >= 2
                    ? '1px solid rgba(239, 68, 68, 0.4)'
                    : (rallyStatus === 'in_play' || isRallyReplayed
                      ? '1px solid rgba(255, 255, 255, 0.1)'
                      : '1px solid rgba(34, 197, 94, 0.4)'),
                  cursor: getTimeoutsUsed('left') >= 2 || rallyStatus === 'in_play' || isRallyReplayed ? 'not-allowed' : 'pointer'
                }}
              >
                <div className="to-sub-label" style={{ fontSize: (isCompactMode || isShortHeight) ? '8px' : '11px', color: 'var(--muted)', marginBottom: (isCompactMode || isShortHeight) ? '1px' : '4px' }}>{t('scoreboard.labels.to')}</div>
                <div className="to-sub-value" style={{
                  fontSize: (isCompactMode || isShortHeight) ? '14px' : '24px',
                  fontWeight: 700,
                  color: getTimeoutsUsed('left') >= 2 ? '#ef4444' : (!(rallyStatus === 'in_play' || isRallyReplayed) ? '#22c55e' : 'inherit')
                }}>{getTimeoutsUsed('left')}</div>
              </div>
              <div
                onClick={() => {
                  const subs = getSubstitutionDetails('left')
                  if (subs.length > 0) {
                    setToSubDetailsModal({ type: 'substitution', side: 'left' })
                  }
                }}
                className="to-sub-counter"
                style={{
                  flex: 1,
                  background: getSubstitutionsUsed('left') >= 6
                    ? 'rgba(239, 68, 68, 0.2)'
                    : getSubstitutionsUsed('left') >= 5
                      ? 'rgba(234, 179, 8, 0.2)'
                      : 'rgba(255, 255, 255, 0.05)',
                  borderRadius: (isCompactMode || isShortHeight) ? '4px' : '8px',
                  padding: (isCompactMode || isShortHeight) ? '4px' : '12px',
                  textAlign: 'center',
                  border: getSubstitutionsUsed('left') >= 6
                    ? '1px solid rgba(239, 68, 68, 0.4)'
                    : getSubstitutionsUsed('left') >= 5
                      ? '1px solid rgba(234, 179, 8, 0.4)'
                      : '1px solid rgba(255, 255, 255, 0.1)',
                  cursor: getSubstitutionDetails('left').length > 0 ? 'pointer' : 'default'
                }}
              >
                <div className="to-sub-label" style={{ fontSize: (isCompactMode || isShortHeight) ? '8px' : '11px', color: 'var(--muted)', marginBottom: (isCompactMode || isShortHeight) ? '1px' : '4px' }}>{t('scoreboard.labels.sub')}</div>
                <div className="to-sub-value" style={{
                  fontSize: (isCompactMode || isShortHeight) ? '14px' : '24px',
                  fontWeight: 700,
                  color: getSubstitutionsUsed('left') >= 6 ? '#ef4444' : getSubstitutionsUsed('left') >= 5 ? '#eab308' : 'inherit'
                }}>{getSubstitutionsUsed('left')}</div>
              </div>
            </div>
            {(() => {
              const teamKey = leftIsHome ? 'home' : 'away'
              const teamPlayers = leftIsHome ? data?.homePlayers : data?.awayPlayers
              // Get ALL liberos from player list (including on court), excluding already-unable ones
              const liberos = teamPlayers?.filter(p => p.libero && p.libero !== '' && p.libero !== 'unable') || []
              const activeLiberos = liberos.filter(p => !isLiberoUnable(teamKey, p.number))
              const unableLiberos = liberos.filter(p => isLiberoUnable(teamKey, p.number))

              // Check if already redesignated
              const alreadyRedesignated = data?.events?.some(e =>
                e.type === 'libero_redesignation' &&
                e.payload?.team === teamKey
              )

              // Show redesignation when ALL liberos are unable (whether 1 or 2)
              const needsRedesignation = liberos.length > 0 && activeLiberos.length === 0 && !alreadyRedesignated

              if (needsRedesignation) {
                const lastUnable = unableLiberos[unableLiberos.length - 1]
                return (
                  <div style={{ display: 'flex', gap: '8px', marginBottom: '8px', width: '100%' }}>
                    <button
                      onClick={() => {
                        setLiberoRedesignationModal({
                          team: teamKey,
                          unableLiberoNumber: lastUnable.number,
                          unableLiberoType: lastUnable.libero
                        })
                      }}
                      disabled={rallyStatus === 'in_play' || isRallyReplayed}
                      style={{
                        flex: 1,
                        fontSize: '10px',
                        padding: '8px 4px',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        background: 'rgba(239, 68, 68, 0.2)',
                        borderColor: 'rgba(239, 68, 68, 0.4)',
                        color: '#f87171'
                      }}
                    >
                      Redesignate Libero
                    </button>
                  </div>
                )
              }

              // Libero out/exchange controls moved to player action menu when clicking libero on court
              return null
            })()}

            {/* Sanctions: Improper Request, Delay Warning, Delay Penalty */}
            {isNarrowMode ? (
              <div style={{ marginTop: '4px' }}>
                <button
                  onClick={() => setLeftDelaysDropdownOpen(!leftDelaysDropdownOpen)}
                  style={{ width: '100%', fontSize: '10px', padding: '8px 4px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}
                >
                  {t('scoreboard.sanctions.irAndDelays')} {leftDelaysDropdownOpen ? '▲' : '▼'}
                </button>
                {leftDelaysDropdownOpen && (
                  <div style={{ marginTop: '4px', display: 'flex', flexDirection: 'column', gap: '4px' }}>
                    {!data?.match?.sanctions?.[leftIsHome ? 'improperRequestHome' : 'improperRequestAway'] && (
                      <button
                        onClick={() => { handleImproperRequest('left'); setLeftDelaysDropdownOpen(false) }}
                        disabled={rallyStatus === 'in_play'}
                        style={sanctionButtonStyles.improper}
                      >
                        {t('scoreboard.sanctions.improperRequest')}
                      </button>
                    )}
                    {!data?.match?.sanctions?.[leftIsHome ? 'delayWarningHome' : 'delayWarningAway'] ? (
                      <button
                        onClick={() => { handleDelayWarning('left'); setLeftDelaysDropdownOpen(false) }}
                        disabled={rallyStatus === 'in_play'}
                        style={sanctionButtonStyles.delayWarning}
                      >
                        {t('scoreboard.sanctions.delayWarning')}
                      </button>
                    ) : (
                      <button
                        onClick={() => { handleDelayPenalty('left'); setLeftDelaysDropdownOpen(false) }}
                        disabled={rallyStatus === 'in_play'}
                        style={sanctionButtonStyles.delayPenalty}
                      >
                        {t('scoreboard.sanctions.delayPenalty')}
                      </button>
                    )}
                  </div>
                )}
              </div>
            ) : (
              <div style={{ display: 'flex', gap: '4px', marginTop: '8px' }}>
                {!data?.match?.sanctions?.[leftIsHome ? 'improperRequestHome' : 'improperRequestAway'] && (
                  <button
                    onClick={() => handleImproperRequest('left')}
                    disabled={rallyStatus === 'in_play'}
                    style={sanctionButtonStyles.improper}
                  >
                    {t('scoreboard.sanctions.improperRequest')}
                  </button>
                )}
                {!data?.match?.sanctions?.[leftIsHome ? 'delayWarningHome' : 'delayWarningAway'] ? (
                  <button
                    onClick={() => handleDelayWarning('left')}
                    disabled={rallyStatus === 'in_play'}
                    style={sanctionButtonStyles.delayWarning}
                  >
                    {t('scoreboard.sanctions.delayWarning')}
                  </button>
                ) : (
                  <button
                    onClick={() => handleDelayPenalty('left')}
                    disabled={rallyStatus === 'in_play'}
                    style={sanctionButtonStyles.delayPenalty}
                  >
                    {t('scoreboard.sanctions.delayPenalty')}
                  </button>
                )}
              </div>
            )}

            {/* Status boxes for team sanctions */}
            <div style={{ marginTop: '8px', display: 'flex', flexDirection: 'column', gap: '4px' }}>
              {data?.match?.sanctions?.[leftIsHome ? 'improperRequestHome' : 'improperRequestAway'] && (
                <div style={{
                  padding: '4px 8px',
                  fontSize: '12px',
                  background: 'rgba(156, 163, 175, 0.15)',
                  border: '1px solid rgba(156, 163, 175, 0.3)',
                  borderRadius: '4px',
                  color: '#d1d5db'
                }}>
                  {t('scoreboard.sanctions.sanctionedImproperRequest')}
                </div>
              )}
              {data?.match?.sanctions?.[leftIsHome ? 'delayWarningHome' : 'delayWarningAway'] && (
                <div style={{
                  padding: '4px 8px',
                  fontSize: '12px',
                  background: 'rgba(234, 179, 8, 0.15)',
                  border: '1px solid rgba(234, 179, 8, 0.3)',
                  borderRadius: '4px',
                  color: '#facc15'
                }}>
                  {t('scoreboard.sanctions.sanctionedDelayWarning')}
                </div>
              )}
              {teamHasFormalWarning(leftIsHome ? 'home' : 'away') && (
                <div style={{
                  padding: '4px 8px',
                  fontSize: '12px',
                  background: 'rgba(250, 204, 21, 0.15)',
                  border: '1px solid rgba(250, 204, 21, 0.3)',
                  borderRadius: '4px',
                  color: '#fde047'
                }}>
                  {t('scoreboard.sanctions.sanctionedFormalWarning')} 🟨
                </div>
              )}
            </div>


            {/* Bench Players, Liberos, and Bench Officials */}
            <div style={{ marginTop: isCompactMode ? '12px' : '24px', paddingTop: isCompactMode ? '12px' : '24px', borderTop: '1px solid rgba(255,255,255,0.1)' }}>
              {/* Bench Players */}
              {leftTeamBench.benchPlayers.length > 0 && (
                <div style={{ marginBottom: isCompactMode ? '8px' : '16px' }}>
                  <h4
                    onClick={() => isCompactMode && setLeftMainBenchExpanded(!leftMainBenchExpanded)}
                    style={{
                      margin: '0 0 8px',
                      fontSize: '12px',
                      fontWeight: 600,
                      color: 'var(--muted)',
                      cursor: isCompactMode ? 'pointer' : 'default',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between'
                    }}
                  >
                    <span>{t('scoreboard.roster.bench')}</span>
                    {isCompactMode && <span style={{ fontSize: '10px' }}>{leftMainBenchExpanded ? '▲' : '▼'}</span>}
                  </h4>
                  {(!isCompactMode || leftMainBenchExpanded) && (
                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                      {leftTeamBench.benchPlayers.map(player => {
                        const teamKey = leftIsHome ? 'home' : 'away'
                        const canComeBack = canPlayerComeBack(teamKey, player.number)
                        const hasComeBack = hasPlayerComeBack(teamKey, player.number)
                        const isSubstitutedByLibero = player.substitutedByLibero !== null

                        // Check if player was substituted out but waiting for point to allow comeback
                        const substitutions = getSubstitutionHistory(teamKey)
                        const wasSubstitutedOut = substitutions.some(s => String(s.payload?.playerOut) === String(player.number))
                        const waitingForPoint = wasSubstitutedOut && !canComeBack && !hasComeBack

                        // Find which player on court this bench player replaced (if they were substituted in)
                        const substitutionWherePlayerIn = substitutions
                          .filter(s => String(s.payload?.playerIn) === String(player.number))
                          .sort((a, b) => new Date(b.ts) - new Date(a.ts))[0] // Get most recent
                        const playerOnCourtReplaced = substitutionWherePlayerIn?.payload?.playerOut || null

                        // Find who replaced this player when they were substituted out (for yellow-background display)
                        const playerWhoReplacedThem = wasSubstitutedOut ? (() => {
                          const subEvent = substitutions
                            .filter(s => String(s.payload?.playerOut) === String(player.number))
                            .sort((a, b) => new Date(b.ts) - new Date(a.ts))[0]
                          return subEvent?.payload?.playerIn || null
                        })() : null

                        // Check if player was substituted due to expulsion (cannot re-enter for rest of set)
                        const wasExpelledSub = wasSubstitutedDueToExpulsion(teamKey, player.number)
                        const expulsionSub = wasExpelledSub ? data.events?.find(e =>
                          e.type === 'substitution' &&
                          e.payload?.team === teamKey &&
                          String(e.payload?.playerOut) === String(player.number) &&
                          e.payload?.isExpelled === true
                        ) : null
                        const isExpelledInSet = wasExpelledSub && expulsionSub && expulsionSub.setIndex === data.set.index

                        // Check if player was substituted due to disqualification (cannot re-enter for rest of game)
                        const isDisqualifiedSub = wasSubstitutedDueToDisqualification(teamKey, player.number)

                        // Check if player was exceptionally substituted (cannot re-enter for rest of game)
                        const isExceptionallySub = wasExceptionallySubstituted(teamKey, player.number)

                        // Also check for sanction-based expulsion/disqualification (for display)
                        const hasExpulsionSanction = data.events?.some(e =>
                          e.type === 'sanction' &&
                          e.payload?.team === teamKey &&
                          e.payload?.playerNumber === player.number &&
                          e.payload?.type === 'expulsion' &&
                          e.setIndex === data.set.index
                        )
                        const hasDisqualificationSanction = data.events?.some(e =>
                          e.type === 'sanction' &&
                          e.payload?.team === teamKey &&
                          e.payload?.playerNumber === player.number &&
                          e.payload?.type === 'disqualification'
                        )

                        // Show X if substituted due to expulsion, disqualification, or exceptional substitution
                        const showX = isExpelledInSet || isDisqualifiedSub || isExceptionallySub || hasExpulsionSanction || hasDisqualificationSanction

                        // Get sanctions for this player
                        const sanctions = getPlayerSanctions(teamKey, player.number)
                        const hasWarning = sanctions.some(s => s.payload?.type === 'warning')
                        const hasPenalty = sanctions.some(s => s.payload?.type === 'penalty')
                        const hasExpulsion = sanctions.some(s => s.payload?.type === 'expulsion')
                        const hasDisqualification = sanctions.some(s => s.payload?.type === 'disqualification')

                        // Determine if bench player can substitute (LEFT TEAM)
                        // Case 1: Player was substituted out - can only come back for the player who replaced them
                        // Case 2: Player never played - can substitute for any court player (if team has subs left)
                        // BUT: If player is currently replaced by libero, they cannot substitute at all
                        const neverPlayed = !wasSubstitutedOut && !hasComeBack && !isSubstitutedByLibero
                        const canComeBackFromSub = wasSubstitutedOut && canComeBack && !hasComeBack && !isSubstitutedByLibero
                        const canSubBenchPlayer = !showX && !isSubstitutedByLibero && (canComeBackFromSub || neverPlayed)

                        // Find the court player this bench player can swap with
                        let courtPlayerToSwapWith = null
                        if (canComeBackFromSub) {
                          // Player was substituted out - can only swap with the player who replaced them
                          const subEvent = substitutions
                            .filter(s => String(s.payload?.playerOut) === String(player.number))
                            .sort((a, b) => new Date(b.ts) - new Date(a.ts))[0]
                          if (subEvent?.payload?.playerIn) {
                            // Get the CURRENT position of the player who replaced them (not the original position from the sub event)
                            // The position may have changed due to rotations
                            const currentLineup = getCurrentLineup(teamKey)
                            const playerInNumber = String(subEvent.payload.playerIn)
                            let currentPosition = null
                            if (currentLineup) {
                              for (const [pos, num] of Object.entries(currentLineup)) {
                                if (String(num) === playerInNumber) {
                                  currentPosition = pos
                                  break
                                }
                              }
                            }
                            if (currentPosition) {
                              courtPlayerToSwapWith = {
                                number: subEvent.payload.playerIn,
                                position: currentPosition
                              }
                            }
                          }
                        }
                        // For neverPlayed case, courtPlayerToSwapWith stays null - we'll show expandable list
                        const isDragging = draggedPlayer?.team === teamKey && draggedPlayer?.playerNumber === player.number && draggedPlayer?.type === 'bench'
                        const isDropTargetForCourt = dropTargetBench?.team === teamKey && dropTargetBench?.playerNumber === player.number && !dropTargetBench?.isLibero

                        // Check if this player is a valid drop target during touch drag
                        const isTouchDropTarget = touchDragState.isDragging && validDropTargets.some(t =>
                          t.type === 'bench' && t.team === teamKey && String(t.playerNumber) === String(player.number) && !t.isLibero
                        )

                        return (
                          <div
                            key={`${teamKey}-bench-${player.id || player.number}`}
                            data-bench-player={player.number}
                            data-team={teamKey}
                            data-is-libero="false"
                            draggable={rallyStatus === 'idle' && (canSubBenchPlayer || isSubstitutedByLibero)}
                            onDragStart={(e) => (canSubBenchPlayer || isSubstitutedByLibero) && handleBenchDragStart(e, teamKey, player.number, false)}
                            onDragEnd={handleBenchDragEnd}
                            onDragOver={(e) => (canSubBenchPlayer || isSubstitutedByLibero) && handleBenchDropOver(e, teamKey, player.number, false)}
                            onDragLeave={handleBenchDropLeave}
                            onDrop={(e) => (canSubBenchPlayer || isSubstitutedByLibero) && handleBenchDrop(e, teamKey, player.number, false)}
                            onTouchStart={(e) => (canSubBenchPlayer || isSubstitutedByLibero) && handleTouchDragStart(e, { team: teamKey, playerNumber: player.number, type: 'bench', isLibero: false })}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                            onTouchCancel={handleTouchCancel}
                            onClick={(e) => {
                              if (rallyStatus === 'idle' && !touchDragState.isDragging) {
                                const rect = e.currentTarget.getBoundingClientRect()
                                setBenchPlayerActionMenu({
                                  team: teamKey,
                                  playerNumber: player.number,
                                  element: e.currentTarget,
                                  x: rect.right - 8,
                                  y: rect.top - 8,
                                  side: 'left',
                                  canSubstitute: canSubBenchPlayer,
                                  courtPlayerToSwapWith: courtPlayerToSwapWith,
                                  neverPlayed: neverPlayed
                                })
                              }
                            }}
                            style={{
                              padding: '5px 10px',
                              touchAction: (canSubBenchPlayer || isSubstitutedByLibero) ? 'none' : undefined,
                              background: isTouchDropTarget
                                ? 'rgba(74, 222, 128, 0.4)'  // Green for valid touch drop target
                                : isDropTargetForCourt
                                  ? 'rgba(239, 68, 68, 0.4)'  // Red highlight for court player drop
                                  : isSubstitutedByLibero
                                    ? '#ffffff'  // White for libero-replaced
                                    : (wasSubstitutedOut && !showX && !hasComeBack)
                                      ? '#0f172a'  // Black bg for substituted-out (only if can still sub back)
                                      : (hasComeBack || showX ? 'rgba(255,255,255,0.02)' : 'rgba(255,255,255,0.05)'),
                              borderRadius: '4px',
                              fontSize: '14px',
                              display: 'flex',
                              alignItems: 'center',
                              gap: '4px',
                              position: 'relative',
                              border: isDropTargetForCourt ? '2px solid #ef4444' : (wasSubstitutedOut && !isSubstitutedByLibero && !showX && !hasComeBack ? '2px solid #fde047' : undefined),
                              boxShadow: isDropTargetForCourt ? '0 0 8px rgba(239, 68, 68, 0.5)' : undefined,
                              opacity: isDragging ? 0.5 : (hasComeBack || showX) ? 0.4 : 1,
                              color: isSubstitutedByLibero ? '#000' : (wasSubstitutedOut && !showX && !hasComeBack ? '#fde047' : undefined),
                              cursor: rallyStatus === 'idle' && canSubBenchPlayer ? 'grab' : (rallyStatus === 'idle' ? 'pointer' : 'default')
                            }}
                          >
                            <span style={{ fontWeight: 600 }}>{player.number}</span>
                            {player.isCaptain && (
                              <span style={{ color: isSubstitutedByLibero ? '#000' : (wasSubstitutedOut && !showX && !hasComeBack ? '#fde047' : 'var(--accent)'), fontSize: '10px', fontWeight: 700 }}>C</span>
                            )}
                            {isSubstitutedByLibero && (
                              <span style={{
                                fontSize: '9px',
                                fontWeight: 700,
                                color: '#000',
                                background: 'rgba(0, 0, 0, 0.1)',
                                padding: '1px 3px',
                                borderRadius: '2px'
                              }}>
                                {player.substitutedByLibero.liberoType === 'libero1' ? 'L1' : player.substitutedByLibero.liberoType === 'redesignated' ? 'LR' : 'L2'}
                              </span>
                            )}
                            {showX && (
                              <span
                                style={{
                                  fontSize: '9px',
                                  lineHeight: '1',
                                  background: 'rgba(15, 23, 42, 0.95)',
                                  color: '#ef4444',
                                  fontWeight: 700,
                                  padding: '1px 3px',
                                  borderRadius: '2px',
                                  display: 'flex',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  minWidth: '12px',
                                  minHeight: '12px',
                                  border: '1px solid rgba(255, 255, 255, 0.2)'
                                }}
                                title={
                                  isDisqualifiedSub || hasDisqualificationSanction
                                    ? 'Disqualified - cannot play rest of match'
                                    : isExceptionallySub
                                      ? 'Exceptionally substituted - cannot play rest of match'
                                      : isExpelledInSet || hasExpulsionSanction
                                        ? 'Expelled - cannot play this set'
                                        : 'Cannot re-enter'
                                }
                              >
                                ✕
                              </span>
                            )}
                            {hasComeBack && !showX && (
                              <span
                                style={{
                                  fontSize: '9px',
                                  lineHeight: '1',
                                  background: 'rgba(15, 23, 42, 0.95)',
                                  color: '#ef4444',
                                  fontWeight: 700,
                                  padding: '1px 3px',
                                  borderRadius: '2px',
                                  display: 'flex',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  minWidth: '12px',
                                  minHeight: '12px',
                                  border: '1px solid rgba(255, 255, 255, 0.2)'
                                }}
                              >
                                ✕
                              </span>
                            )}
                            {(waitingForPoint || canComeBack) && !hasComeBack && !showX && (
                              <span
                                style={{
                                  fontSize: '7px',
                                  lineHeight: '1',
                                  display: 'flex',
                                  flexDirection: 'row',
                                  alignItems: 'center',
                                  gap: '2px',
                                  background: 'rgba(15, 23, 42, 0.95)',
                                  padding: '1px 3px',
                                  borderRadius: '2px',
                                  minHeight: '12px',
                                  justifyContent: 'center',
                                  border: '1px solid rgba(255, 255, 255, 0.2)',
                                  opacity: waitingForPoint ? 0.5 : 1
                                }}
                              >
                                <span style={{ color: '#22c55e', fontWeight: 900 }}>↑</span>
                                <span style={{ color: '#ef4444', fontWeight: 900 }}>↓</span>
                                {playerWhoReplacedThem && (
                                  <span style={{
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    fontSize: '8px',
                                    fontWeight: 600,
                                    marginLeft: '2px'
                                  }}>
                                    {playerWhoReplacedThem}
                                  </span>
                                )}
                              </span>
                            )}
                            {sanctions.length > 0 && (
                              <span style={{
                                fontSize: '8px',
                                display: 'flex',
                                gap: '1px',
                                alignItems: 'center'
                              }}>
                                {hasExpulsion ? (
                                  <div style={{ position: 'relative', width: '9px', height: '9px' }}>
                                    <div className="sanction-card yellow" style={{
                                      width: '6px',
                                      height: '8px',
                                      position: 'absolute',
                                      left: '0',
                                      top: '0',
                                      transform: 'rotate(-8deg)',
                                      zIndex: 1
                                    }}></div>
                                    <div className="sanction-card red" style={{
                                      width: '6px',
                                      height: '8px',
                                      position: 'absolute',
                                      right: '0',
                                      top: '0',
                                      transform: 'rotate(8deg)',
                                      zIndex: 2
                                    }}></div>
                                  </div>
                                ) : (
                                  <>
                                    {(hasWarning || hasDisqualification) && (
                                      <div className="sanction-card yellow" style={{ width: '6px', height: '8px' }}></div>
                                    )}
                                    {(hasPenalty || hasDisqualification) && (
                                      <div className="sanction-card red" style={{ width: '6px', height: '8px' }}></div>
                                    )}
                                  </>
                                )}
                              </span>
                            )}
                          </div>
                        )
                      })}
                    </div>
                  )}
                </div>
              )}

              {/* Liberos */}
              {leftTeamBench.liberos.length > 0 && (
                <div style={{ marginBottom: isCompactMode ? '8px' : '16px' }}>
                  <h4
                    onClick={() => isCompactMode && setLeftMainLiberosExpanded(!leftMainLiberosExpanded)}
                    style={{
                      margin: '0 0 8px',
                      fontSize: '12px',
                      fontWeight: 600,
                      color: 'var(--muted)',
                      cursor: isCompactMode ? 'pointer' : 'default',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between'
                    }}
                  >
                    <span>{t('scoreboard.roster.liberos')}</span>
                    {isCompactMode && <span style={{ fontSize: '10px' }}>{leftMainLiberosExpanded ? '▲' : '▼'}</span>}
                  </h4>
                  {(!isCompactMode || leftMainLiberosExpanded) && (
                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                      {leftTeamBench.liberos.map(player => {
                        const teamKey = leftIsHome ? 'home' : 'away'
                        const isUnable = isLiberoUnable(teamKey, player.number)
                        const liberoOnCourt = getLiberoOnCourt(teamKey)
                        const canDragLibero = rallyStatus === 'idle' && !isUnable && !liberoOnCourt && hasPointSinceLastLiberoExchange(teamKey)
                        const isDraggingLibero = draggedPlayer?.team === teamKey && draggedPlayer?.playerNumber === player.number && draggedPlayer?.type === 'bench'
                        // Can receive court player drop (libero exit/exchange if libero on court, OR libero entry if no libero on court)
                        // The handler will validate whether it's a valid operation
                        const canReceiveLiberoFromCourt = rallyStatus === 'idle' && !isUnable
                        const isLiberoDropTarget = dropTargetBench?.team === teamKey && dropTargetBench?.playerNumber === player.number && dropTargetBench?.isLibero

                        // Get sanctions for this libero (LEFT TEAM)
                        const sanctions = getPlayerSanctions(teamKey, player.number)
                        const hasWarning = sanctions.some(s => s.payload?.type === 'warning')
                        const hasPenalty = sanctions.some(s => s.payload?.type === 'penalty')
                        const hasExpulsion = sanctions.some(s => s.payload?.type === 'expulsion')
                        const hasDisqualification = sanctions.some(s => s.payload?.type === 'disqualification')

                        // Check if this libero is a valid drop target during touch drag
                        const isTouchDropTargetLibero = touchDragState.isDragging && validDropTargets.some(t =>
                          t.type === 'bench' && t.team === teamKey && String(t.playerNumber) === String(player.number) && t.isLibero
                        )

                        return (
                          <div
                            key={`${teamKey}-bench-libero-${player.id || player.number}`}
                            style={{
                              display: 'flex',
                              alignItems: 'center',
                              gap: '4px'
                            }}
                          >
                            <div
                              data-bench-player={player.number}
                              data-team={teamKey}
                              data-is-libero="true"
                              draggable={canDragLibero}
                              onDragStart={(e) => canDragLibero && handleBenchDragStart(e, teamKey, player.number, true)}
                              onDragEnd={handleBenchDragEnd}
                              onDragOver={(e) => canReceiveLiberoFromCourt && handleBenchDropOver(e, teamKey, player.number, true)}
                              onDragLeave={handleBenchDropLeave}
                              onDrop={(e) => canReceiveLiberoFromCourt && handleBenchDrop(e, teamKey, player.number, true)}
                              onTouchStart={(e) => canDragLibero && handleTouchDragStart(e, { team: teamKey, playerNumber: player.number, type: 'bench', isLibero: true })}
                              onTouchMove={handleTouchMove}
                              onTouchEnd={handleTouchEnd}
                              onTouchCancel={handleTouchCancel}
                              onClick={(e) => {
                                if (rallyStatus === 'idle' && !isUnable && !touchDragState.isDragging) {
                                  // Open action menu for libero on bench
                                  const rect = e.currentTarget.getBoundingClientRect()
                                  setLiberoBenchActionMenu({
                                    team: teamKey,
                                    liberoNumber: player.number,
                                    liberoType: player.libero,
                                    element: e.currentTarget,
                                    x: rect.left + rect.width / 2,
                                    y: rect.top + rect.height / 2,
                                    side: 'left'
                                  })
                                }
                              }}
                              style={{
                                padding: '5px 10px',
                                touchAction: canDragLibero ? 'none' : undefined,
                                background: isTouchDropTargetLibero
                                  ? 'rgba(74, 222, 128, 0.4)'  // Green for valid touch drop target
                                  : isLiberoDropTarget ? 'rgba(59, 130, 246, 0.5)' : isUnable ? 'rgba(239, 68, 68, 0.2)' : 'rgba(59, 130, 246, 0.2)',
                                borderRadius: '4px',
                                fontSize: '14px',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '4px',
                                border: isLiberoDropTarget ? '2px solid #3b82f6' : `1px solid ${isUnable ? 'rgba(239, 68, 68, 0.3)' : 'rgba(59, 130, 246, 0.3)'}`,
                                boxShadow: isLiberoDropTarget ? '0 0 8px rgba(59, 130, 246, 0.5)' : undefined,
                                cursor: canDragLibero ? 'grab' : (rallyStatus === 'idle' && !isUnable) ? 'pointer' : 'default',
                                opacity: isDraggingLibero ? 0.5 : isUnable ? 0.6 : 1
                              }}
                            >
                              <span style={{ fontWeight: 600 }}>{player.number}</span>
                              <span style={{ color: isUnable ? '#f87171' : '#60a5fa', fontSize: '12px', fontWeight: 700 }}>
                                {player.libero === 'libero1' ? 'L1' : player.libero === 'redesignated' ? 'LR' : 'L2'}
                              </span>
                              {/* Captain badge for libero-captain on bench (left team) */}
                              {(player.isCaptain || player.captain) && (
                                <span style={{
                                  background: '#fff',
                                  color: '#10b981',
                                  border: '1px solid #10b981',
                                  borderRadius: '3px',
                                  padding: '0 3px',
                                  fontSize: '10px',
                                  fontWeight: 700
                                }}>C</span>
                              )}
                              {sanctions.length > 0 && (
                                <span style={{ display: 'flex', gap: '1px', alignItems: 'center' }}>
                                  {hasExpulsion ? (
                                    <div style={{ position: 'relative', width: '9px', height: '9px' }}>
                                      <div className="sanction-card yellow" style={{
                                        width: '5px',
                                        height: '7px',
                                        position: 'absolute',
                                        left: '0',
                                        top: '1px',
                                        transform: 'rotate(-8deg)',
                                        zIndex: 1,
                                        borderRadius: '1px'
                                      }}></div>
                                      <div className="sanction-card red" style={{
                                        width: '5px',
                                        height: '7px',
                                        position: 'absolute',
                                        right: '0',
                                        top: '1px',
                                        transform: 'rotate(8deg)',
                                        zIndex: 2,
                                        borderRadius: '1px'
                                      }}></div>
                                    </div>
                                  ) : (
                                    <>
                                      {(hasWarning || hasDisqualification) && (
                                        <div className="sanction-card yellow" style={{ width: '6px', height: '8px', borderRadius: '1px' }}></div>
                                      )}
                                      {(hasPenalty || hasDisqualification) && (
                                        <div className="sanction-card red" style={{ width: '6px', height: '8px', borderRadius: '1px' }}></div>
                                      )}
                                    </>
                                  )}
                                </span>
                              )}
                            </div>
                            {/* Exchange Libero button - show when another libero is on court */}
                            {liberoOnCourt &&
                              liberoOnCourt.liberoNumber !== player.number &&
                              hasPointSinceLastLiberoExchange(teamKey) &&
                              !isUnable && (
                                <button
                                  onClick={(e) => {
                                    e.stopPropagation()
                                    handleExchangeLibero('left')
                                  }}
                                  style={{
                                    padding: '4px 8px',
                                    background: '#fff',
                                    color: '#000',
                                    border: '1px solid #ccc',
                                    borderRadius: '4px',
                                    fontSize: '11px',
                                    fontWeight: 600,
                                    cursor: 'pointer',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '4px'
                                  }}
                                  title="Exchange liberos (swap L1 ↔ L2)"
                                >
                                  <span style={{ fontSize: '12px' }}>⇄</span>
                                  Exch.
                                </button>
                              )}
                          </div>
                        )
                      })}
                      {/* Redesignate Libero button - shows when all liberos are unable */}
                      {(() => {
                        const teamKey = leftIsHome ? 'home' : 'away'
                        // Get ALL liberos from player list, not just bench (bench excludes liberos on court)
                        const teamPlayers = leftIsHome ? data?.homePlayers : data?.awayPlayers
                        const allLiberos = (teamPlayers || []).filter(p => p.libero && p.libero !== '' && p.libero !== 'unable')
                        const activeLiberos = allLiberos.filter(p => !isLiberoUnable(teamKey, p.number))
                        const unableLiberos = allLiberos.filter(p => isLiberoUnable(teamKey, p.number))
                        const alreadyRedesignated = data?.events?.some(e =>
                          e.type === 'libero_redesignation' && e.payload?.team === teamKey
                        )
                        const shouldShow = activeLiberos.length === 0 && unableLiberos.length > 0 && !alreadyRedesignated && rallyStatus === 'idle'

                        if (!shouldShow) return null

                        return (
                          <button
                            onClick={() => {
                              const lastUnable = unableLiberos[unableLiberos.length - 1]
                              setLiberoRedesignationModal({
                                team: teamKey,
                                unableLiberoNumber: lastUnable.number,
                                unableLiberoType: lastUnable.libero
                              })
                            }}
                            style={{
                              padding: '6px 12px',
                              background: '#f97316',
                              color: '#000',
                              border: 'none',
                              borderRadius: '4px',
                              fontSize: '11px',
                              fontWeight: 600,
                              cursor: 'pointer',
                              display: 'flex',
                              alignItems: 'center',
                              gap: '4px'
                            }}
                          >
                            <span>🔄</span> Redesignate Libero
                          </button>
                        )
                      })()}
                    </div>
                  )}
                </div>
              )}

              {/* Bench Officials */}
              {leftTeamBench.benchOfficials.length > 0 && (
                <div>
                  <h4
                    onClick={() => isCompactMode && setLeftMainOfficialsExpanded(!leftMainOfficialsExpanded)}
                    style={{
                      margin: '0 0 8px',
                      fontSize: '12px',
                      fontWeight: 600,
                      color: 'var(--muted)',
                      cursor: isCompactMode ? 'pointer' : 'default',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between'
                    }}
                  >
                    <span>{t('scoreboard.roster.benchOfficials')}</span>
                    {isCompactMode && <span style={{ fontSize: '10px' }}>{leftMainOfficialsExpanded ? '▲' : '▼'}</span>}
                  </h4>
                  {(!isCompactMode || leftMainOfficialsExpanded) && (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                      {leftTeamBench.benchOfficials.map((official, idx) => {
                        const teamKey = leftIsHome ? 'home' : 'away'

                        // Get sanctions for this official
                        const sanctions = getPlayerSanctions(teamKey, null, official.role)
                        const hasWarning = sanctions.some(s => s.payload?.type === 'warning')
                        const hasPenalty = sanctions.some(s => s.payload?.type === 'penalty')
                        const hasExpulsion = sanctions.some(s => s.payload?.type === 'expulsion')
                        const hasDisqualification = sanctions.some(s => s.payload?.type === 'disqualification')

                        return (
                          <div
                            key={idx}
                            onClick={(e) => {
                              if (rallyStatus === 'idle') {
                                const rect = e.currentTarget.getBoundingClientRect()
                                setSanctionDropdown({
                                  team: teamKey,
                                  type: 'official',
                                  role: official.role,
                                  element: e.currentTarget,
                                  x: rect.left + rect.width / 2,
                                  y: rect.top + rect.height / 2,
                                  side: 'left'
                                })
                              }
                            }}
                            style={{
                              padding: '4px 8px',
                              background: 'rgba(255,255,255,0.05)',
                              borderRadius: '4px',
                              fontSize: '11px',
                              display: 'flex',
                              alignItems: 'center',
                              gap: '6px',
                              cursor: rallyStatus === 'idle' ? 'pointer' : 'default'
                            }}
                          >
                            <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                              <span style={{ fontWeight: 600, color: 'var(--muted)', minWidth: '30px' }}>
                                {official.role === 'Coach' ? 'C' :
                                  official.role === 'Assistant Coach 1' ? 'AC1' :
                                    official.role === 'Assistant Coach 2' ? 'AC2' :
                                      official.role === 'Physiotherapist' ? 'P' :
                                        official.role === 'Medic' ? 'M' : official.role}
                              </span>
                              <span>{official.lastName || ''} {official.firstName || ''}</span>
                              {sanctions.length > 0 && (
                                <span style={{ display: 'flex', gap: '1px', alignItems: 'center' }}>
                                  {hasExpulsion ? (
                                    <div style={{ position: 'relative', width: '9px', height: '9px' }}>
                                      <div className="sanction-card yellow" style={{
                                        width: '5px',
                                        height: '7px',
                                        position: 'absolute',
                                        left: '0',
                                        top: '1px',
                                        transform: 'rotate(-8deg)',
                                        zIndex: 1,
                                        borderRadius: '1px'
                                      }}></div>
                                      <div className="sanction-card red" style={{
                                        width: '5px',
                                        height: '7px',
                                        position: 'absolute',
                                        right: '0',
                                        top: '1px',
                                        transform: 'rotate(8deg)',
                                        zIndex: 2,
                                        borderRadius: '1px'
                                      }}></div>
                                    </div>
                                  ) : (
                                    <>
                                      {(hasWarning || hasDisqualification) && (
                                        <div className="sanction-card yellow" style={{ width: '6px', height: '8px', borderRadius: '1px' }}></div>
                                      )}
                                      {(hasPenalty || hasDisqualification) && (
                                        <div className="sanction-card red" style={{ width: '6px', height: '8px', borderRadius: '1px' }}></div>
                                      )}
                                    </>
                                  )}
                                </span>
                              )}
                            </div>
                          </div>
                        )
                      })}
                    </div>
                  )}
                </div>
              )}

              {/* Set Results Table - Left Team (compact mode only) */}
              {isCompactMode && (
                <div style={{ marginTop: '12px' }}>
                  {(() => {
                    const currentLeftTeamKey = leftIsHome ? 'home' : 'away'
                    const leftTeamData = currentLeftTeamKey === 'home' ? data?.homeTeam : data?.awayTeam
                    const leftTeamColor = leftTeamData?.color || (currentLeftTeamKey === 'home' ? '#ef4444' : '#3b82f6')
                    const leftTeamLabel = currentLeftTeamKey === teamAKey ? 'A' : 'B'
                    const allSets = (data?.sets || []).sort((a, b) => a.index - b.index)
                    const currentSetIndex = data?.set?.index || 1
                    const setsByIndex = new Map()
                    allSets.forEach(set => {
                      if (set.index <= currentSetIndex) {
                        setsByIndex.set(set.index, set)
                      }
                    })
                    const visibleSets = Array.from(setsByIndex.values()).sort((a, b) => a.index - b.index)

                    return (
                      <div style={{
                        background: 'rgba(15, 23, 42, 0.6)',
                        border: '1px solid rgba(255, 255, 255, 0.08)',
                        borderRadius: '6px',
                        padding: '8px',
                        fontSize: '10px',
                        minWidth: '110px'
                      }}>
                        <h4 style={{ margin: '0 0 4px', fontSize: '11px', fontWeight: 600, textAlign: 'center' }}>
                          <span style={{
                            padding: '1px 6px',
                            borderRadius: '3px',
                            fontSize: '10px',
                            fontWeight: 700,
                            background: leftTeamColor,
                            color: isBrightColor(leftTeamColor) ? '#000' : '#fff'
                          }}>{leftTeamLabel}</span>
                        </h4>
                        <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '10px', tableLayout: 'fixed' }}>
                          <thead>
                            <tr style={{ borderBottom: '1px solid rgba(255,255,255,0.2)' }}>
                              <th style={{ padding: '2px 1px', textAlign: 'center', fontWeight: 600, fontSize: '9px', width: '20%' }}>Set</th>
                              <th style={{ padding: '2px 1px', textAlign: 'center', fontWeight: 600, fontSize: '9px', width: '20%' }}>P</th>
                              <th style={{ padding: '2px 1px', textAlign: 'center', fontWeight: 600, fontSize: '9px', width: '20%' }}>W</th>
                              <th style={{ padding: '2px 1px', textAlign: 'center', fontWeight: 600, fontSize: '9px', width: '20%' }}>S</th>
                              <th style={{ padding: '2px 1px', textAlign: 'center', fontWeight: 600, fontSize: '9px', width: '20%' }}>T</th>
                            </tr>
                          </thead>
                          <tbody>
                            {visibleSets.map(set => {
                              const leftPoints = currentLeftTeamKey === 'home' ? set.homePoints : set.awayPoints
                              const rightPoints = currentLeftTeamKey === 'home' ? set.awayPoints : set.homePoints
                              const won = leftPoints > rightPoints ? 1 : 0
                              const substitutions = (data?.events || []).filter(e =>
                                e.type === 'substitution' && e.setIndex === set.index && e.payload?.team === currentLeftTeamKey
                              ).length
                              const timeouts = (data?.events || []).filter(e =>
                                e.type === 'timeout' && e.setIndex === set.index && e.payload?.team === currentLeftTeamKey
                              ).length
                              let rowColor = 'inherit'
                              if (set.finished) {
                                rowColor = won === 1 ? '#22c55e' : '#ef4444'
                              }
                              return (
                                <tr key={set.id} style={{ borderBottom: '1px solid rgba(255,255,255,0.1)', color: rowColor }}>
                                  <td style={{ padding: '2px 1px', textAlign: 'center' }}>{set.index}</td>
                                  <td style={{ padding: '2px 1px', textAlign: 'center' }}>{leftPoints}</td>
                                  <td style={{ padding: '2px 1px', textAlign: 'center' }}>{won}</td>
                                  <td style={{ padding: '2px 1px', textAlign: 'center' }}>{substitutions}</td>
                                  <td style={{ padding: '2px 1px', textAlign: 'center' }}>{timeouts}</td>
                                </tr>
                              )
                            })}
                          </tbody>
                        </table>
                      </div>
                    )
                  })()}
                </div>
              )}
            </div>

          </ScoreboardTeamColumn>

          <ScoreboardCourtColumn>
            {/* Layered layout: Score centered absolutely, serve indicators in flex layer */}
            <div style={{
              position: 'relative',
              width: '100%',
              minHeight: '12vmin'
            }}>
              {/* Layer 1: Serve indicators - flex space-between */}
              <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                width: '100%'
              }}>
                {/* Left Serve indicator */}
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'flex-start',
                  gap: '2vmin',
                  minWidth: '10vmin'
                }}>
                  {leftServing && (() => {
                    const servingPlayer = leftTeam.playersOnCourt.find(p => p.position === 'I')
                    // If lineup not set, show just the ball
                    if (!servingPlayer || !servingPlayer.number) {
                      return (
                        <img
                          src={ballImage} onError={(e) => e.target.src = mikasaVolleyball}
                          alt="Serving team"
                          style={{
                            ...serveBallBaseStyle,
                            width: '8vmin',
                            height: '8vmin'
                          }}
                        />
                      )
                    }
                    return (
                      <div style={{
                        display: 'flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        gap: isVeryCompact ? '1px' : isCompactMode ? '2px' : '4px',
                        zIndex: 10,
                        pointerEvents: 'none'
                      }}>
                        <div style={{
                          fontSize: '3vmin',
                          fontWeight: 700,
                          color: 'var(--text)',
                          textTransform: 'uppercase',
                          letterSpacing: isVeryCompact ? '0.5px' : isCompactMode ? '1px' : '2px'
                        }}>
                          SERVE
                        </div>
                        <div style={{
                          fontSize: '6vmin',
                          fontWeight: 700,
                          color: 'var(--accent)',
                          width: '8vmin',
                          height: '8vmin',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          background: 'rgba(34, 197, 94, 0.1)',
                          border: isVeryCompact ? '2px solid var(--accent)' : isCompactMode ? '3px solid var(--accent)' : '4px solid var(--accent)',
                          borderRadius: isVeryCompact ? '6px' : isCompactMode ? '8px' : '14px'
                        }}>
                          {servingPlayer.number}
                        </div>
                      </div>
                    )
                  })()}
                </div>

                {/* Right Serve indicator */}
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'flex-end',
                  gap: '2vmin',
                  minWidth: '10vmin'
                }}>
                  {rightServing && (() => {
                    const servingPlayer = rightTeam.playersOnCourt.find(p => p.position === 'I')
                    // If lineup not set, show just the ball
                    if (!servingPlayer || !servingPlayer.number) {
                      return (
                        <img
                          src={ballImage} onError={(e) => e.target.src = mikasaVolleyball}
                          alt="Serving team"
                          style={{
                            ...serveBallBaseStyle,
                            width: '8vmin',
                            height: '8vmin'
                          }}
                        />
                      )
                    }
                    return (
                      <div style={{
                        display: 'flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        gap: isVeryCompact ? '1px' : isCompactMode ? '2px' : '4px',
                        zIndex: 10,
                        pointerEvents: 'none'
                      }}>
                        <div style={{
                          fontSize: '3vmin',
                          fontWeight: 700,
                          color: 'var(--text)',
                          textTransform: 'uppercase',
                          letterSpacing: isVeryCompact ? '0.5px' : isCompactMode ? '1px' : '2px'
                        }}>
                          SERVE
                        </div>
                        <div style={{
                          fontSize: '6vmin',
                          fontWeight: 700,
                          color: 'var(--accent)',
                          width: '8vmin',
                          height: '8vmin',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          background: 'rgba(34, 197, 94, 0.1)',
                          border: isVeryCompact ? '2px solid var(--accent)' : isCompactMode ? '3px solid var(--accent)' : '4px solid var(--accent)',
                          borderRadius: isVeryCompact ? '6px' : isCompactMode ? '8px' : '14px'
                        }}>
                          {servingPlayer.number}
                        </div>
                      </div>
                    )
                  })()}
                </div>
              </div>

              {/* Layer 2: Score display - absolutely centered */}
              <div style={{
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                pointerEvents: 'none'
              }}>
                {/* Left Score */}
                <span style={{
                  fontFamily: getScoreFont(),
                  fontVariantNumeric: 'tabular-nums',
                  fontSize: 'min(11vw, 11vh)',
                  fontWeight: 500,
                  lineHeight: 1,
                  minWidth: '1.2em',
                  textAlign: 'right',
                  display: 'inline-block'
                }}>{pointsBySide.left}</span>

                {/* Colon */}
                <span style={{
                  fontFamily: getScoreFont(),
                  fontSize: 'min(11vw, 11vh)',
                  fontWeight: 700,
                  lineHeight: 1,
                  color: '#22c55e',
                  transform: 'translateY(-0.06em)',
                  padding: '0 0.3em'
                }}>:</span>

                {/* Right Score */}
                <span style={{
                  fontFamily: getScoreFont(),
                  fontVariantNumeric: 'tabular-nums',
                  fontSize: 'min(11vw, 11vh)',
                  fontWeight: 500,
                  lineHeight: 1,
                  minWidth: '1.2em',
                  textAlign: 'left',
                  display: 'inline-block'
                }}>{pointsBySide.right}</span>
              </div>
            </div>

            {/* Hide court area during Set 5 setup until confirmation */}
            {!(data?.set?.index === 5 && !set5SetupConfirmed) && (
              <>
                {/* Game Captain Buttons + 1R row - above court */}
                <div style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  width: '100%',
                  marginBottom: '1px'
                }}>
                  {/* Left Game Captain Button */}
                  {leftTeamLineupSet && !captainOnCourtStatus[leftIsHome ? 'home' : 'away'].captainOnCourt ? (
                    <button
                      onClick={() => setCaptainOnCourtModal({ team: leftIsHome ? 'home' : 'away' })}
                      style={{
                        padding: '4px 8px',
                        fontSize: '10px',
                        fontWeight: 600,
                        background: 'rgba(251, 191, 36, 0.2)',
                        color: '#fbbf24',
                        border: '1px solid rgba(251, 191, 36, 0.4)',
                        borderRadius: '4px',
                        cursor: 'pointer'
                      }}
                    >
                      {t('scoreboard.captainOnCourt.designate', 'Game Captain')}
                    </button>
                  ) : <div style={{ width: '80px' }} />}

                  {/* 1R in center - only show in non-compact mode */}
                  {!isCompactMode && (() => {
                    const ref1 = data?.match?.officials?.find(o => o.role === '1st referee' || o.role === '1st Referee')
                    const ref1Name = ref1 ? `${ref1.firstName || ''} ${ref1.lastName || ''}`.trim() : null
                    if (!ref1Name) return <div style={{ flex: 1 }} />
                    return (
                      <span style={{
                        fontSize: isLaptopMode ? '13px' : '16px',
                        color: 'var(--muted)',
                        whiteSpace: 'nowrap'
                      }}>
                        1R: {ref1Name}
                      </span>
                    )
                  })()}

                  {/* Right Game Captain Button */}
                  {rightTeamLineupSet && !captainOnCourtStatus[leftIsHome ? 'away' : 'home'].captainOnCourt ? (
                    <button
                      onClick={() => setCaptainOnCourtModal({ team: leftIsHome ? 'away' : 'home' })}
                      style={{
                        padding: '4px 8px',
                        fontSize: '10px',
                        fontWeight: 600,
                        background: 'rgba(251, 191, 36, 0.2)',
                        color: '#fbbf24',
                        border: '1px solid rgba(251, 191, 36, 0.4)',
                        borderRadius: '4px',
                        cursor: 'pointer'
                      }}
                    >
                      {t('scoreboard.captainOnCourt.designate', 'Game Captain')}
                    </button>
                  ) : <div style={{ width: '80px' }} />}
                </div>

                <div className="court" style={{ marginTop: isCompactMode ? '4px' : '2px', marginBottom: isCompactMode ? '2px' : '1px' }}>
                  <div className="court-attack-line court-attack-left" />
                  <div className="court-attack-line court-attack-right" />
                  {rallyStatus === 'idle' && isFirstRally && (
                    <>
                      {!leftTeamLineupSet && (
                        <button
                          className="lineup-button lineup-button-left"
                          onClick={() => setLineupModal({ team: leftIsHome ? 'home' : 'away', mode: 'initial' })}
                          style={{
                            position: 'absolute',
                            left: '25%',
                            top: '50%',
                            transform: 'translate(-50%, -50%)',
                            zIndex: 100,
                            width: '40%',
                            height: '80%',
                            padding: '0',
                            display: 'flex',
                            flexDirection: 'column',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: '4px',
                            fontSize: 'clamp(20px, 4vw, 32px)',
                            fontWeight: 700,
                            background: 'var(--accent)',
                            color: '#000',
                            border: 'none',
                            borderRadius: '12px',
                            cursor: 'pointer',
                            boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
                            animation: 'lineupFlash 1.5s ease-in-out infinite'
                          }}
                        >
                          <span>{t('scoreboard.lineup', 'Line-up')}</span>
                          <span style={{ fontSize: 'clamp(12px, 2.5vw, 18px)', fontWeight: 600 }}>{teamALabel} - {teamAShortName}</span>
                        </button>
                      )}
                      {!rightTeamLineupSet && (
                        <button
                          className="lineup-button lineup-button-right"
                          onClick={() => setLineupModal({ team: leftIsHome ? 'away' : 'home', mode: 'initial' })}
                          style={{
                            position: 'absolute',
                            left: '75%',
                            top: '50%',
                            transform: 'translate(-50%, -50%)',
                            zIndex: 100,
                            width: '40%',
                            height: '80%',
                            padding: '0',
                            display: 'flex',
                            flexDirection: 'column',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: '4px',
                            fontSize: 'clamp(20px, 4vw, 32px)',
                            fontWeight: 700,
                            background: 'var(--accent)',
                            color: '#000',
                            border: 'none',
                            borderRadius: '12px',
                            cursor: 'pointer',
                            boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
                            animation: 'lineupFlash 1.5s ease-in-out infinite'
                          }}
                        >
                          <span>{t('scoreboard.lineup', 'Line-up')}</span>
                          <span style={{ fontSize: 'clamp(12px, 2.5vw, 18px)', fontWeight: 600 }}>{teamBLabel} - {teamBShortName}</span>
                        </button>
                      )}
                    </>
                  )}
                  <div className="court-side court-side-left">
                    <div className="court-team court-team-left">
                      <div className="court-row court-row-front">
                        {leftTeam.playersOnCourt.slice(0, 3).map((player, idx) => {
                          const teamKey = leftIsHome ? 'home' : 'away'
                          const teamSubstitutions = substitutionsUsed?.[teamKey] || 0
                          const canSubstitute = rallyStatus === 'idle' && !isRallyReplayed && leftTeamLineupSet && player.number && player.number !== '' && !player.isPlaceholder && teamSubstitutions < 6
                          const replacementNumber = resolveReplacementNumber(player, leftTeamActiveReplacements)

                          // Check if this player was recently substituted in
                          const isRecentlySub = recentlySubstitutedPlayers.some(
                            sub => sub.team === teamKey && String(sub.playerNumber) === String(player.number)
                          )

                          // Get sanctions for this player
                          const sanctions = getPlayerSanctions(teamKey, player.number)
                          const hasWarning = sanctions.some(s => s.payload?.type === 'warning')
                          const hasPenalty = sanctions.some(s => s.payload?.type === 'penalty')
                          const hasExpulsion = sanctions.some(s => s.payload?.type === 'expulsion')
                          const hasDisqualification = sanctions.some(s => s.payload?.type === 'disqualification')

                          const isDropTarget = dropTargetPosition?.team === teamKey && dropTargetPosition?.position === player.position
                          const isDragging = draggedPlayer?.type === 'court' && draggedPlayer?.team === teamKey && draggedPlayer?.position === player.position

                          // Check if this position is a valid touch drop target
                          const isTouchDropTargetCourt = touchDragState.isDragging && validDropTargets.some(t =>
                            t.type === 'court' && t.team === teamKey && t.position === player.position
                          )
                          // Check if this is an invalid drop zone during touch drag (wrong team or position)
                          const isInvalidTouchDropZone = touchDragState.isDragging && draggedPlayer?.team === teamKey && !isTouchDropTargetCourt

                          return (
                            <div
                              key={`${teamKey}-court-front-${player.position}-${player.id || player.number || idx}`}
                              data-court-position={player.position}
                              data-team={teamKey}
                              data-player-number={player.number}
                              className={`court-player${isRecentlySub ? ' recently-substituted' : ''}`}
                              draggable={canSubstitute && !player.isLibero}
                              onDragStart={(e) => canSubstitute && handleCourtDragStart(e, teamKey, player.position, player.number, player.isLibero)}
                              onDragEnd={handleCourtDragEnd}
                              onClick={(e) => !touchDragState.isDragging && handlePlayerClick(teamKey, player.position, player.number, e)}
                              onDragOver={(e) => handleCourtDragOver(e, teamKey, player.position)}
                              onDragLeave={handleCourtDragLeave}
                              onDrop={(e) => handleCourtDrop(e, teamKey, player.position, player.number)}
                              onTouchStart={(e) => canSubstitute && !player.isLibero && handleTouchDragStart(e, { team: teamKey, playerNumber: player.number, position: player.position, type: 'court', isLibero: player.isLibero })}
                              onTouchMove={handleTouchMove}
                              onTouchEnd={handleTouchEnd}
                              onTouchCancel={handleTouchCancel}
                              style={{
                                cursor: canSubstitute && !player.isLibero ? 'grab' : 'pointer',
                                opacity: isDragging ? 0.5 : isInvalidTouchDropZone ? 0.5 : undefined,
                                transition: 'transform 0.2s, background 0.15s, box-shadow 0.15s',
                                touchAction: canSubstitute && !player.isLibero ? 'none' : undefined,
                                background: isTouchDropTargetCourt
                                  ? 'rgba(74, 222, 128, 0.5)'  // Bright green for valid touch target
                                  : isInvalidTouchDropZone
                                    ? 'rgba(239, 68, 68, 0.2)'  // Red tint for invalid
                                    : isDropTarget ? 'rgba(74, 222, 128, 0.4)' : isRecentlySub ? '#fdba74' : player.isLibero ? '#FFF8E7' : undefined,
                                color: isRecentlySub ? '#000' : player.isLibero ? '#000' : undefined,
                                position: 'relative',
                                animation: isRecentlySub ? 'recentSubFlash 0.5s ease-in-out infinite' : undefined,
                                fontWeight: isRecentlySub ? 900 : undefined,
                                border: isTouchDropTargetCourt
                                  ? '3px solid #22c55e'
                                  : isInvalidTouchDropZone
                                    ? '2px dashed rgba(239, 68, 68, 0.5)'
                                    : isDropTarget ? '3px solid #4ade80' : isRecentlySub ? '3px solid #f97316' : undefined,
                                boxShadow: isTouchDropTargetCourt
                                  ? '0 0 16px rgba(74, 222, 128, 0.6)'
                                  : isDropTarget ? '0 0 12px rgba(74, 222, 128, 0.5)' : undefined
                              }}
                              onMouseEnter={(e) => {
                                if (!isDropTarget && !isTouchDropTargetCourt) {
                                  e.currentTarget.style.transform = 'scale(1.05)'
                                  e.currentTarget.style.boxShadow = '0 4px 12px rgba(255,255,255,0.2)'
                                }
                              }}
                              onMouseLeave={(e) => {
                                if (!isDropTarget && !isTouchDropTargetCourt) {
                                  e.currentTarget.style.transform = 'scale(1)'
                                  e.currentTarget.style.boxShadow = 'none'
                                }
                              }}
                            >
                              {replacementNumber && (
                                <span style={getReplacementBadgeStyle(player)}>
                                  {replacementNumber}
                                </span>
                              )}
                              <span className="court-player-position">{player.position}</span>
                              {/* Captain indicator - show C for captain (including libero-captain) */}
                              {player.isCaptain && (() => {
                                if (player.isLibero) {
                                  // Libero-captain ON COURT: show LC on white bg with green text
                                  return (
                                    <span className="court-player-captain" style={{ background: '#fff', color: '#10b981', borderColor: '#10b981', fontSize: '9px' }}>LC</span>
                                  )
                                }
                                return <span className="court-player-captain">C</span>
                              })()}
                              {/* Captain on Court indicator (different color) - uses pre-computed isCourtCaptain which checks if team captain is on court */}
                              {player.isCourtCaptain && (
                                <span
                                  className="court-player-captain"
                                  style={{
                                    background: player.isLibero ? '#3b82f6' : undefined,
                                    color: '#fbbf24',
                                    borderColor: '#fbbf24',
                                    fontSize: player.isLibero ? '9px' : undefined
                                  }}
                                >
                                  {player.isLibero ? 'LC' : 'C'}
                                </span>
                              )}
                              {/* Libero indicator (bottom-left) - only if not captain */}
                              {player.isLibero && !player.isCaptain && (() => {
                                const teamPlayers = teamKey === 'home' ? data?.homePlayers : data?.awayPlayers
                                const liberoCount = teamPlayers?.filter(p => p.libero === 'libero1' || p.libero === 'libero2' || p.libero === 'redesignated').length || 0
                                const liberoType = player.liberoType
                                const isUnable = liberoType === 'unable'
                                const isRedesignated = liberoType === 'redesignated'

                                // Determine base label
                                let baseLabel = ''
                                if (liberoCount === 1) {
                                  baseLabel = 'L'
                                } else if (liberoType === 'libero1') {
                                  baseLabel = 'L1'
                                } else if (liberoType === 'libero2') {
                                  baseLabel = 'L2'
                                } else if (isRedesignated) {
                                  baseLabel = 'L'
                                } else {
                                  baseLabel = 'L'
                                }

                                return (
                                  <span style={{
                                    position: 'absolute',
                                    bottom: '-1vmin',
                                    left: '-1vmin',
                                    width: '2vmin',
                                    height: '2vmin',
                                    background: '#3b82f6',
                                    border: '2px solid rgba(255, 255, 255, 0.4)',
                                    borderRadius: '4px',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    fontSize: '1.35vmin',
                                    fontWeight: 700,
                                    color: '#fff',
                                    zIndex: 5,
                                    boxShadow: '0 2px 6px rgba(0, 0, 0, 0.4)'
                                  }}>
                                    <span style={{ position: 'relative', display: 'inline-block' }}>
                                      {baseLabel}
                                      {isRedesignated}
                                      {isUnable && (
                                        <span style={{
                                          position: 'absolute',
                                          top: '50%',
                                          left: '50%',
                                          transform: 'translate(-50%, -50%)',
                                          fontSize: '1.2em',
                                          color: '#ef4444',
                                          fontWeight: 900
                                        }}>✕</span>
                                      )}
                                    </span>
                                  </span>
                                )
                              })()}
                              {player.number}

                              {/* Sanction cards indicator */}
                              {sanctions.length > 0 && (
                                <div style={{
                                  position: 'absolute',
                                  bottom: '-1vmin',
                                  right: '-1vmin',
                                  zIndex: 10
                                }}>
                                  {hasExpulsion ? (
                                    // Expulsion: overlapping rotated cards
                                    <div style={{ position: 'relative', width: '2vmin', height: '2vmin' }}>
                                      <div className="sanction-card yellow" style={{
                                        width: '1vmin',
                                        height: '1.5vmin',
                                        boxShadow: '0 1px 3px rgba(0,0,0,0.8)',
                                        position: 'absolute',
                                        left: '0',
                                        top: '0.15vmin',
                                        transform: 'rotate(-8deg)',
                                        zIndex: 1,
                                        borderRadius: '1px'
                                      }}></div>
                                      <div className="sanction-card red" style={{
                                        width: '1vmin',
                                        height: '1.5vmin',
                                        boxShadow: '0 1px 3px rgba(0,0,0,0.8)',
                                        position: 'absolute',
                                        right: '0',
                                        top: '0.15vmin',
                                        transform: 'rotate(8deg)',
                                        zIndex: 2,
                                        borderRadius: '1px'
                                      }}></div>
                                    </div>
                                  ) : (
                                    // Other sanctions: separate cards
                                    <div style={{ display: 'flex', gap: '0.15vmin' }}>
                                      {(hasWarning || hasDisqualification) && (
                                        <div className="sanction-card yellow" style={{ width: '1.3vmin', height: '1.8vmin', boxShadow: '0 1px 3px rgba(0,0,0,0.8)', borderRadius: '1px' }}></div>
                                      )}
                                      {(hasPenalty || hasDisqualification) && (
                                        <div className="sanction-card red" style={{ width: '1.3vmin', height: '1.8vmin', boxShadow: '0 1px 3px rgba(0,0,0,0.8)', borderRadius: '1px' }}></div>
                                      )}
                                    </div>
                                  )}
                                </div>
                              )}
                              {/* Player name rectangle - clickable to expand/collapse full name */}
                              {showNamesOnCourt && (player.lastName || player.firstName) && !player.isPlaceholder && (
                                <div
                                  onClick={(e) => toggleExpandedPlayerName(teamKey, player.number, e)}
                                  style={{
                                    position: 'absolute',
                                    bottom: '-27px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    background: 'rgba(0, 0, 0, 0.85)',
                                    border: '1px solid rgba(255, 255, 255, 0.3)',
                                    borderRadius: '3px',
                                    padding: '1px 4px',
                                    fontSize: '9px',
                                    fontWeight: 600,
                                    color: '#fff',
                                    whiteSpace: 'nowrap',
                                    minWidth: '68px',
                                    zIndex: 10,
                                    textTransform: 'uppercase',
                                    letterSpacing: '0.3px',
                                    cursor: 'pointer',
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'center',
                                    gap: '2px'
                                  }}>
                                  <div style={{ display: 'flex', alignItems: 'center', gap: '2px' }}>
                                    <span style={{ fontSize: '7px', opacity: 0.7, transform: expandedPlayerName === `${teamKey}-${player.number}` ? 'rotate(180deg)' : 'none', transition: 'transform 0.2s' }}>▼</span>
                                    {expandedPlayerName === `${teamKey}-${player.number}`
                                      ? `#${player.number}`
                                      : getCourtPlayerDisplayName(teamKey, player.number, player.firstName, player.lastName)}
                                  </div>
                                  {expandedPlayerName === `${teamKey}-${player.number}` && (
                                    <div style={{ fontSize: '8px', opacity: 0.9, borderTop: '1px solid rgba(255,255,255,0.2)', paddingTop: '2px', marginTop: '1px', display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                                      <div>{player.firstName}</div>
                                      <div>{player.lastName}</div>
                                    </div>
                                  )}
                                </div>
                              )}
                            </div>
                          )
                        })}
                      </div>
                      <div className="court-row court-row-back">
                        {leftTeam.playersOnCourt.slice(3, 6).map((player, idx) => {
                          const leftTeamKey = leftIsHome ? 'home' : 'away'
                          const currentServe = getCurrentServe()
                          const leftTeamServes = currentServe === leftTeamKey
                          const shouldShowBall = player.position === 'I' && leftTeamServes
                          const teamSubstitutions = substitutionsUsed?.[leftTeamKey] || 0
                          const canSubstitute = rallyStatus === 'idle' && !isRallyReplayed && leftTeamLineupSet && player.number && player.number !== '' && !player.isPlaceholder && teamSubstitutions < 6
                          const replacementNumber = resolveReplacementNumber(player, leftTeamActiveReplacements)

                          // Check if this player was recently substituted in
                          const isRecentlySub = recentlySubstitutedPlayers.some(
                            sub => sub.team === leftTeamKey && String(sub.playerNumber) === String(player.number)
                          )

                          // Get sanctions for this player
                          const sanctions = getPlayerSanctions(leftTeamKey, player.number)
                          const hasWarning = sanctions.some(s => s.payload?.type === 'warning')
                          const hasPenalty = sanctions.some(s => s.payload?.type === 'penalty')
                          const hasExpulsion = sanctions.some(s => s.payload?.type === 'expulsion')
                          const hasDisqualification = sanctions.some(s => s.payload?.type === 'disqualification')

                          const isDropTarget = dropTargetPosition?.team === leftTeamKey && dropTargetPosition?.position === player.position
                          const isDragging = draggedPlayer?.type === 'court' && draggedPlayer?.team === leftTeamKey && draggedPlayer?.position === player.position
                          // For liberos on court, they can be dragged back to libero bench
                          const canDragCourtPlayer = canSubstitute || (rallyStatus === 'idle' && player.isLibero)

                          // Check if this position is a valid touch drop target
                          const isTouchDropTargetCourt = touchDragState.isDragging && validDropTargets.some(t =>
                            t.type === 'court' && t.team === leftTeamKey && t.position === player.position
                          )
                          const isInvalidTouchDropZone = touchDragState.isDragging && draggedPlayer?.team === leftTeamKey && !isTouchDropTargetCourt

                          return (
                            <div
                              key={`${leftTeamKey}-court-back-${player.position}-${player.id || player.number || idx}`}
                              ref={player.position === 'V' ? leftCourtPositionVRef : undefined}
                              data-court-position={player.position}
                              data-team={leftTeamKey}
                              data-player-number={player.number}
                              className={`court-player${isRecentlySub ? ' recently-substituted' : ''}`}
                              draggable={canDragCourtPlayer}
                              onDragStart={(e) => canDragCourtPlayer && handleCourtDragStart(e, leftTeamKey, player.position, player.number, player.isLibero)}
                              onDragEnd={handleCourtDragEnd}
                              onTouchStart={(e) => canDragCourtPlayer && handleTouchDragStart(e, { team: leftTeamKey, playerNumber: player.number, position: player.position, type: 'court', isLibero: player.isLibero })}
                              onTouchMove={handleTouchMove}
                              onTouchEnd={handleTouchEnd}
                              onTouchCancel={handleTouchCancel}
                              style={{
                                position: 'relative',
                                cursor: canDragCourtPlayer ? 'grab' : (player.number && player.number !== '' ? 'pointer' : 'default'),
                                opacity: isDragging ? 0.5 : isInvalidTouchDropZone ? 0.5 : undefined,
                                transition: 'transform 0.2s, background 0.15s, box-shadow 0.15s',
                                touchAction: canDragCourtPlayer ? 'none' : undefined,
                                background: isTouchDropTargetCourt
                                  ? 'rgba(74, 222, 128, 0.5)'
                                  : isInvalidTouchDropZone
                                    ? 'rgba(239, 68, 68, 0.2)'
                                    : isDropTarget ? 'rgba(74, 222, 128, 0.4)' : isRecentlySub ? '#86efac' : player.isLibero ? '#FFF8E7' : undefined,
                                color: isRecentlySub ? '#000' : player.isLibero ? '#000' : undefined,
                                animation: isRecentlySub ? 'recentSubFlash 0.5s ease-in-out infinite' : undefined,
                                fontWeight: isRecentlySub ? 900 : undefined,
                                border: isTouchDropTargetCourt
                                  ? '3px solid #22c55e'
                                  : isInvalidTouchDropZone
                                    ? '2px dashed rgba(239, 68, 68, 0.5)'
                                    : isDropTarget ? '3px solid #4ade80' : isRecentlySub ? '3px solid #22c55e' : undefined,
                                boxShadow: isTouchDropTargetCourt
                                  ? '0 0 16px rgba(74, 222, 128, 0.6)'
                                  : isDropTarget ? '0 0 12px rgba(74, 222, 128, 0.5)' : undefined
                              }}
                              onClick={(e) => !touchDragState.isDragging && handlePlayerClick(leftTeamKey, player.position, player.number, e)}
                              onDragOver={(e) => handleCourtDragOver(e, leftTeamKey, player.position)}
                              onDragLeave={handleCourtDragLeave}
                              onDrop={(e) => handleCourtDrop(e, leftTeamKey, player.position, player.number)}
                              onMouseEnter={(e) => {
                                if (player.number && player.number !== '' && !isDropTarget && !isTouchDropTargetCourt) {
                                  e.currentTarget.style.transform = 'scale(1.05)'
                                  e.currentTarget.style.boxShadow = '0 4px 12px rgba(255,255,255,0.2)'
                                }
                              }}
                              onMouseLeave={(e) => {
                                if (player.number && player.number !== '' && !isDropTarget && !isTouchDropTargetCourt) {
                                  e.currentTarget.style.transform = 'scale(1)'
                                  e.currentTarget.style.boxShadow = 'none'
                                }
                              }}
                            >
                              {shouldShowBall && (
                                <img
                                  src={ballImage} onError={(e) => e.target.src = mikasaVolleyball}
                                  alt="Volleyball"
                                  style={{
                                    position: 'absolute',
                                    left: '-8vmin',
                                    top: '50%',
                                    transform: 'translateY(-50%)',
                                    width: '8vmin',
                                    height: '8vmin',
                                    zIndex: 5
                                  }}
                                />
                              )}
                              {replacementNumber && (
                                <span style={getReplacementBadgeStyle(player)}>
                                  {replacementNumber}
                                </span>
                              )}
                              <span className="court-player-position">{player.position}</span>
                              {/* Captain indicator - show C for captain (including libero-captain) */}
                              {player.isCaptain && (() => {
                                if (player.isLibero) {
                                  // Libero-captain ON COURT: show LC on white bg with green text
                                  return (
                                    <span className="court-player-captain" style={{ background: '#fff', color: '#10b981', borderColor: '#10b981', fontSize: '9px' }}>LC</span>
                                  )
                                }
                                return <span className="court-player-captain">C</span>
                              })()}
                              {/* Captain on Court indicator (different color) - uses pre-computed isCourtCaptain which checks if team captain is on court */}
                              {player.isCourtCaptain && (
                                <span
                                  className="court-player-captain"
                                  style={{
                                    background: player.isLibero ? '#3b82f6' : undefined,
                                    color: '#fbbf24',
                                    borderColor: '#fbbf24',
                                    fontSize: player.isLibero ? '9px' : undefined
                                  }}
                                >
                                  {player.isLibero ? 'LC' : 'C'}
                                </span>
                              )}
                              {/* Libero indicator (bottom-left) - only if not captain */}
                              {player.isLibero && !player.isCaptain && (() => {
                                const teamPlayers = leftTeamKey === 'home' ? data?.homePlayers : data?.awayPlayers
                                const liberoCount = teamPlayers?.filter(p => p.libero === 'libero1' || p.libero === 'libero2' || p.libero === 'redesignated').length || 0
                                const liberoLabel = liberoCount === 1 ? 'L' : (player.liberoType === 'libero1' ? 'L1' : player.liberoType === 'redesignated' ? 'LR' : 'L2')
                                return (
                                  <span style={{
                                    position: 'absolute',
                                    bottom: '-1vmin',
                                    left: '-1vmin',
                                    width: '2vmin',
                                    height: '2vmin',
                                    background: '#3b82f6',
                                    border: '2px solid rgba(255, 255, 255, 0.4)',
                                    borderRadius: '4px',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    fontSize: '1.35vmin',
                                    fontWeight: 700,
                                    color: '#fff',
                                    zIndex: 5,
                                    boxShadow: '0 2px 6px rgba(0, 0, 0, 0.4)'
                                  }}>
                                    {liberoLabel}
                                  </span>
                                )
                              })()}
                              {player.number}

                              {/* Sanction cards indicator */}
                              {sanctions.length > 0 && (
                                <div style={{
                                  position: 'absolute',
                                  bottom: '-1vmin',
                                  right: '-1vmin',
                                  zIndex: 10
                                }}>
                                  {hasExpulsion ? (
                                    // Expulsion: overlapping rotated cards
                                    <div style={{ position: 'relative', width: '2vmin', height: '2vmin' }}>
                                      <div className="sanction-card yellow" style={{
                                        width: '1vmin',
                                        height: '1.5vmin',
                                        boxShadow: '0 1px 3px rgba(0,0,0,0.8)',
                                        position: 'absolute',
                                        left: '0',
                                        top: '0.15vmin',
                                        transform: 'rotate(-8deg)',
                                        zIndex: 1,
                                        borderRadius: '1px'
                                      }}></div>
                                      <div className="sanction-card red" style={{
                                        width: '1vmin',
                                        height: '1.5vmin',
                                        boxShadow: '0 1px 3px rgba(0,0,0,0.8)',
                                        position: 'absolute',
                                        right: '0',
                                        top: '0.15vmin',
                                        transform: 'rotate(8deg)',
                                        zIndex: 2,
                                        borderRadius: '1px'
                                      }}></div>
                                    </div>
                                  ) : (
                                    // Other sanctions: separate cards
                                    <div style={{ display: 'flex', gap: '0.15vmin' }}>
                                      {(hasWarning || hasDisqualification) && (
                                        <div className="sanction-card yellow" style={{ width: '1.3vmin', height: '1.8vmin', boxShadow: '0 1px 3px rgba(0,0,0,0.8)', borderRadius: '1px' }}></div>
                                      )}
                                      {(hasPenalty || hasDisqualification) && (
                                        <div className="sanction-card red" style={{ width: '1.3vmin', height: '1.8vmin', boxShadow: '0 1px 3px rgba(0,0,0,0.8)', borderRadius: '1px' }}></div>
                                      )}
                                    </div>
                                  )}
                                </div>
                              )}
                              {/* Player name rectangle - clickable to expand/collapse full name */}
                              {showNamesOnCourt && (player.lastName || player.firstName) && !player.isPlaceholder && (
                                <div
                                  onClick={(e) => toggleExpandedPlayerName(leftTeamKey, player.number, e)}
                                  style={{
                                    position: 'absolute',
                                    bottom: '-27px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    background: 'rgba(0, 0, 0, 0.85)',
                                    border: '1px solid rgba(255, 255, 255, 0.3)',
                                    borderRadius: '3px',
                                    padding: '1px 4px',
                                    fontSize: '9px',
                                    fontWeight: 600,
                                    color: '#fff',
                                    whiteSpace: 'nowrap',
                                    minWidth: '68px',
                                    zIndex: 10,
                                    textTransform: 'uppercase',
                                    letterSpacing: '0.3px',
                                    cursor: 'pointer',
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'center',
                                    gap: '2px'
                                  }}>
                                  <div style={{ display: 'flex', alignItems: 'center', gap: '2px' }}>
                                    <span style={{ fontSize: '7px', opacity: 0.7, transform: expandedPlayerName === `${leftTeamKey}-${player.number}` ? 'rotate(180deg)' : 'none', transition: 'transform 0.2s' }}>▼</span>
                                    {expandedPlayerName === `${leftTeamKey}-${player.number}`
                                      ? `#${player.number}`
                                      : getCourtPlayerDisplayName(leftTeamKey, player.number, player.firstName, player.lastName)}
                                  </div>
                                  {expandedPlayerName === `${leftTeamKey}-${player.number}` && (
                                    <div style={{ fontSize: '8px', opacity: 0.9, borderTop: '1px solid rgba(255,255,255,0.2)', paddingTop: '2px', marginTop: '1px', display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                                      <div>{player.firstName}</div>
                                      <div>{player.lastName}</div>
                                    </div>
                                  )}
                                </div>
                              )}
                            </div>
                          )
                        })}
                      </div>
                      {/* Blur overlay when lineup is set but other team hasn't set theirs yet */}
                      {leftTeamLineupSet && !rightTeamLineupSet && isFirstRally && !peekingLineup.left && (
                        <div style={{
                          position: 'absolute',
                          top: 0,
                          left: 0,
                          right: 0,
                          bottom: 0,
                          background: 'rgba(0, 0, 0, 0.7)',
                          backdropFilter: 'blur(8px)',
                          display: 'flex',
                          flexDirection: 'column',
                          alignItems: 'center',
                          justifyContent: 'center',
                          gap: '12px',
                          zIndex: 50,
                          borderRadius: '8px'
                        }}>
                          <div style={{
                            fontSize: 'clamp(16px, 3vw, 24px)',
                            fontWeight: 700,
                            color: '#22c55e',
                            textAlign: 'center'
                          }}>
                            {t('scoreboard.lineupSet', 'Line-up set')}
                          </div>
                          <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap', justifyContent: 'center' }}>
                            <button
                              onMouseDown={() => setPeekingLineup(prev => ({ ...prev, left: true }))}
                              onMouseUp={() => setPeekingLineup(prev => ({ ...prev, left: false }))}
                              onMouseLeave={() => setPeekingLineup(prev => ({ ...prev, left: false }))}
                              onTouchStart={() => setPeekingLineup(prev => ({ ...prev, left: true }))}
                              onTouchEnd={() => setPeekingLineup(prev => ({ ...prev, left: false }))}
                              style={{
                                padding: '8px 16px',
                                fontSize: 'clamp(11px, 2vw, 14px)',
                                fontWeight: 600,
                                background: 'rgba(59, 130, 246, 0.3)',
                                color: '#fff',
                                border: '1px solid rgba(59, 130, 246, 0.5)',
                                borderRadius: '6px',
                                cursor: 'pointer'
                              }}
                            >
                              {t('scoreboard.showLineup', 'Show Line-up')}
                            </button>
                            <button
                              onClick={() => setLineupModal({ team: leftIsHome ? 'home' : 'away', mode: 'initial' })}
                              style={{
                                padding: '8px 16px',
                                fontSize: 'clamp(11px, 2vw, 14px)',
                                fontWeight: 600,
                                background: 'rgba(251, 191, 36, 0.3)',
                                color: '#fbbf24',
                                border: '1px solid rgba(251, 191, 36, 0.5)',
                                borderRadius: '6px',
                                cursor: 'pointer'
                              }}
                            >
                              {t('scoreboard.changeLineup', 'Change Line-up')}
                            </button>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                  <div className="court-net" />
                  <div className="court-side court-side-right">
                    <div className="court-team court-team-right">
                      <div className="court-row court-row-front">
                        {rightTeam.playersOnCourt.slice(0, 3).map((player, idx) => {
                          const teamKey = leftIsHome ? 'away' : 'home'
                          const teamSubstitutions = substitutionsUsed?.[teamKey] || 0
                          const canSubstitute = rallyStatus === 'idle' && !isRallyReplayed && rightTeamLineupSet && player.number && player.number !== '' && !player.isPlaceholder && teamSubstitutions < 6
                          const replacementNumber = resolveReplacementNumber(player, rightTeamActiveReplacements)

                          // Get sanctions for this player
                          const sanctions = getPlayerSanctions(teamKey, player.number)
                          const hasWarning = sanctions.some(s => s.payload?.type === 'warning')
                          const hasPenalty = sanctions.some(s => s.payload?.type === 'penalty')
                          const hasExpulsion = sanctions.some(s => s.payload?.type === 'expulsion')
                          const hasDisqualification = sanctions.some(s => s.payload?.type === 'disqualification')

                          // Check if this player was recently substituted in
                          const isRecentlySub = recentlySubstitutedPlayers.some(
                            sub => sub.team === teamKey && String(sub.playerNumber) === String(player.number)
                          )

                          const isDropTarget = dropTargetPosition?.team === teamKey && dropTargetPosition?.position === player.position
                          const isDragging = draggedPlayer?.type === 'court' && draggedPlayer?.team === teamKey && draggedPlayer?.position === player.position

                          return (
                            <div
                              key={`${teamKey}-court-front-${player.position}-${player.id || player.number || idx}`}
                              ref={player.position === 'II' ? rightCourtPositionIIRef : undefined}
                              className="court-player"
                              draggable={canSubstitute && !player.isLibero}
                              onDragStart={(e) => canSubstitute && handleCourtDragStart(e, teamKey, player.position, player.number, player.isLibero)}
                              onDragEnd={handleCourtDragEnd}
                              onClick={(e) => handlePlayerClick(teamKey, player.position, player.number, e)}
                              onDragOver={(e) => handleCourtDragOver(e, teamKey, player.position)}
                              onDragLeave={handleCourtDragLeave}
                              onDrop={(e) => handleCourtDrop(e, teamKey, player.position, player.number)}
                              style={{
                                cursor: canSubstitute && !player.isLibero ? 'grab' : 'pointer',
                                opacity: isDragging ? 0.5 : undefined,
                                transition: 'transform 0.2s, background 0.15s, box-shadow 0.15s',
                                background: isDropTarget ? 'rgba(74, 222, 128, 0.4)' : isRecentlySub ? '#86efac' : player.isLibero ? '#FFF8E7' : undefined,
                                color: isRecentlySub ? '#000' : player.isLibero ? '#000' : undefined,
                                animation: isRecentlySub ? 'recentSubFlash 0.5s ease-in-out infinite' : undefined,
                                fontWeight: isRecentlySub ? 900 : undefined,
                                border: isDropTarget ? '3px solid #4ade80' : isRecentlySub ? '3px solid #22c55e' : undefined,
                                boxShadow: isDropTarget ? '0 0 12px rgba(74, 222, 128, 0.5)' : undefined,
                                position: 'relative'
                              }}
                              onMouseEnter={(e) => {
                                if (!isDropTarget) {
                                  e.currentTarget.style.transform = 'scale(1.05)'
                                  e.currentTarget.style.boxShadow = '0 4px 12px rgba(255,255,255,0.2)'
                                }
                              }}
                              onMouseLeave={(e) => {
                                if (!isDropTarget) {
                                  e.currentTarget.style.transform = 'scale(1)'
                                  e.currentTarget.style.boxShadow = 'none'
                                }
                              }}
                            >
                              {replacementNumber && (
                                <span style={getReplacementBadgeStyle(player)}>
                                  {replacementNumber}
                                </span>
                              )}
                              <span className="court-player-position">{player.position}</span>
                              {/* Bottom-left indicators: Captain C (including libero-captain) */}
                              {player.isCaptain && (() => {
                                if (player.isLibero) {
                                  // Libero-captain ON COURT: show LC on white bg with green text
                                  return (
                                    <span className="court-player-captain" style={{ background: '#fff', color: '#10b981', borderColor: '#10b981', fontSize: '9px' }}>LC</span>
                                  )
                                }
                                return <span className="court-player-captain">C</span>
                              })()}
                              {/* Captain on Court indicator (different color) - uses pre-computed isCourtCaptain which checks if team captain is on court */}
                              {player.isCourtCaptain && (
                                <span
                                  className="court-player-captain"
                                  style={{
                                    background: player.isLibero ? '#3b82f6' : undefined,
                                    color: '#fbbf24',
                                    borderColor: '#fbbf24',
                                    fontSize: player.isLibero ? '9px' : undefined
                                  }}
                                >
                                  {player.isLibero ? 'LC' : 'C'}
                                </span>
                              )}
                              {/* Libero indicator (bottom-left) - only if not captain */}
                              {player.isLibero && !player.isCaptain && (() => {
                                const teamPlayers = teamKey === 'home' ? data?.homePlayers : data?.awayPlayers
                                const liberoCount = teamPlayers?.filter(p => p.libero === 'libero1' || p.libero === 'libero2' || p.libero === 'redesignated').length || 0
                                const liberoType = player.liberoType
                                const isUnable = liberoType === 'unable'
                                const isRedesignated = liberoType === 'redesignated'

                                // Determine base label
                                let baseLabel = ''
                                if (liberoCount === 1) {
                                  baseLabel = 'L'
                                } else if (liberoType === 'libero1') {
                                  baseLabel = 'L1'
                                } else if (liberoType === 'libero2') {
                                  baseLabel = 'L2'
                                } else if (isRedesignated) {
                                  baseLabel = 'L'
                                } else {
                                  baseLabel = 'L'
                                }

                                return (
                                  <span style={{
                                    position: 'absolute',
                                    bottom: '-1vmin',
                                    left: '-1vmin',
                                    width: '2vmin',
                                    height: '2vmin',
                                    background: '#3b82f6',
                                    border: '2px solid rgba(255, 255, 255, 0.4)',
                                    borderRadius: '4px',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    fontSize: '1.35vmin',
                                    fontWeight: 700,
                                    color: '#fff',
                                    zIndex: 5,
                                    boxShadow: '0 2px 6px rgba(0, 0, 0, 0.4)'
                                  }}>
                                    <span style={{ position: 'relative', display: 'inline-block' }}>
                                      {baseLabel}
                                      {isRedesignated}
                                      {isUnable && (
                                        <span style={{
                                          position: 'absolute',
                                          top: '50%',
                                          left: '50%',
                                          transform: 'translate(-50%, -50%)',
                                          fontSize: '1.2em',
                                          color: '#ef4444',
                                          fontWeight: 900
                                        }}>✕</span>
                                      )}
                                    </span>
                                  </span>
                                )
                              })()}
                              {player.number}

                              {/* Sanction cards indicator */}
                              {sanctions.length > 0 && (
                                <div style={{
                                  position: 'absolute',
                                  bottom: '-1vmin',
                                  right: '-1vmin',
                                  zIndex: 10
                                }}>
                                  {hasExpulsion ? (
                                    // Expulsion: overlapping rotated cards
                                    <div style={{ position: 'relative', width: '2vmin', height: '2vmin' }}>
                                      <div className="sanction-card yellow" style={{
                                        width: '1vmin',
                                        height: '1.5vmin',
                                        boxShadow: '0 1px 3px rgba(0,0,0,0.8)',
                                        position: 'absolute',
                                        left: '0',
                                        top: '0.15vmin',
                                        transform: 'rotate(-8deg)',
                                        zIndex: 1,
                                        borderRadius: '1px'
                                      }}></div>
                                      <div className="sanction-card red" style={{
                                        width: '1vmin',
                                        height: '1.5vmin',
                                        boxShadow: '0 1px 3px rgba(0,0,0,0.8)',
                                        position: 'absolute',
                                        right: '0',
                                        top: '0.15vmin',
                                        transform: 'rotate(8deg)',
                                        zIndex: 2,
                                        borderRadius: '1px'
                                      }}></div>
                                    </div>
                                  ) : (
                                    // Other sanctions: separate cards
                                    <div style={{ display: 'flex', gap: '0.15vmin' }}>
                                      {(hasWarning || hasDisqualification) && (
                                        <div className="sanction-card yellow" style={{ width: '1.3vmin', height: '1.8vmin', boxShadow: '0 1px 3px rgba(0,0,0,0.8)', borderRadius: '1px' }}></div>
                                      )}
                                      {(hasPenalty || hasDisqualification) && (
                                        <div className="sanction-card red" style={{ width: '1.3vmin', height: '1.8vmin', boxShadow: '0 1px 3px rgba(0,0,0,0.8)', borderRadius: '1px' }}></div>
                                      )}
                                    </div>
                                  )}
                                </div>
                              )}
                              {/* Player name rectangle - clickable to expand/collapse full name */}
                              {showNamesOnCourt && (player.lastName || player.firstName) && !player.isPlaceholder && (
                                <div
                                  onClick={(e) => toggleExpandedPlayerName(teamKey, player.number, e)}
                                  style={{
                                    position: 'absolute',
                                    bottom: '-27px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    background: 'rgba(0, 0, 0, 0.85)',
                                    border: '1px solid rgba(255, 255, 255, 0.3)',
                                    borderRadius: '3px',
                                    padding: '1px 4px',
                                    fontSize: '9px',
                                    fontWeight: 600,
                                    color: '#fff',
                                    whiteSpace: 'nowrap',
                                    minWidth: '68px',
                                    zIndex: 10,
                                    textTransform: 'uppercase',
                                    letterSpacing: '0.3px',
                                    cursor: 'pointer',
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'center',
                                    gap: '2px'
                                  }}>
                                  <div style={{ display: 'flex', alignItems: 'center', gap: '2px' }}>
                                    <span style={{ fontSize: '7px', opacity: 0.7, transform: expandedPlayerName === `${teamKey}-${player.number}` ? 'rotate(180deg)' : 'none', transition: 'transform 0.2s' }}>▼</span>
                                    {expandedPlayerName === `${teamKey}-${player.number}`
                                      ? `#${player.number}`
                                      : getCourtPlayerDisplayName(teamKey, player.number, player.firstName, player.lastName)}
                                  </div>
                                  {expandedPlayerName === `${teamKey}-${player.number}` && (
                                    <div style={{ fontSize: '8px', opacity: 0.9, borderTop: '1px solid rgba(255,255,255,0.2)', paddingTop: '2px', marginTop: '1px', display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                                      <div>{player.firstName}</div>
                                      <div>{player.lastName}</div>
                                    </div>
                                  )}
                                </div>
                              )}
                            </div>
                          )
                        })}
                      </div>
                      <div className="court-row court-row-back">
                        {rightTeam.playersOnCourt.slice(3, 6).map((player, idx) => {
                          const rightTeamKey = leftIsHome ? 'away' : 'home'
                          const currentServe = getCurrentServe()
                          const rightTeamServes = currentServe === rightTeamKey
                          const shouldShowBall = player.position === 'I' && rightTeamServes
                          const teamSubstitutions = substitutionsUsed?.[rightTeamKey] || 0
                          const canSubstitute = rallyStatus === 'idle' && rightTeamLineupSet && player.number && player.number !== '' && !player.isPlaceholder && teamSubstitutions < 6
                          const replacementNumber = resolveReplacementNumber(player, rightTeamActiveReplacements)

                          // Get sanctions for this player
                          const sanctions = getPlayerSanctions(rightTeamKey, player.number)
                          const hasWarning = sanctions.some(s => s.payload?.type === 'warning')
                          const hasPenalty = sanctions.some(s => s.payload?.type === 'penalty')
                          const hasExpulsion = sanctions.some(s => s.payload?.type === 'expulsion')
                          const hasDisqualification = sanctions.some(s => s.payload?.type === 'disqualification')

                          // Check if this player was recently substituted in
                          const isRecentlySub = recentlySubstitutedPlayers.some(
                            sub => sub.team === rightTeamKey && String(sub.playerNumber) === String(player.number)
                          )

                          const isDropTarget = dropTargetPosition?.team === rightTeamKey && dropTargetPosition?.position === player.position
                          const isDragging = draggedPlayer?.type === 'court' && draggedPlayer?.team === rightTeamKey && draggedPlayer?.position === player.position
                          // For liberos on court, they can be dragged back to libero bench
                          const canDragCourtPlayer = canSubstitute || (rallyStatus === 'idle' && player.isLibero)

                          // Check if this position is a valid touch drop target (RIGHT TEAM BACK ROW)
                          const isTouchDropTargetCourt = touchDragState.isDragging && validDropTargets.some(t =>
                            t.type === 'court' && t.team === rightTeamKey && t.position === player.position
                          )
                          const isInvalidTouchDropZone = touchDragState.isDragging && draggedPlayer?.team === rightTeamKey && !isTouchDropTargetCourt

                          return (
                            <div
                              key={`${rightTeamKey}-court-back-${player.position}-${player.id || player.number || idx}`}
                              data-court-position={player.position}
                              data-team={rightTeamKey}
                              data-player-number={player.number}
                              className="court-player"
                              draggable={canDragCourtPlayer}
                              onDragStart={(e) => canDragCourtPlayer && handleCourtDragStart(e, rightTeamKey, player.position, player.number, player.isLibero)}
                              onDragEnd={handleCourtDragEnd}
                              onTouchStart={(e) => canDragCourtPlayer && handleTouchDragStart(e, { team: rightTeamKey, playerNumber: player.number, position: player.position, type: 'court', isLibero: player.isLibero })}
                              onTouchMove={handleTouchMove}
                              onTouchEnd={handleTouchEnd}
                              onTouchCancel={handleTouchCancel}
                              style={{
                                position: 'relative',
                                cursor: canDragCourtPlayer ? 'grab' : (player.number && player.number !== '' ? 'pointer' : 'default'),
                                opacity: isDragging ? 0.5 : isInvalidTouchDropZone ? 0.5 : undefined,
                                transition: 'transform 0.2s, background 0.15s, box-shadow 0.15s',
                                touchAction: canDragCourtPlayer ? 'none' : undefined,
                                background: isTouchDropTargetCourt
                                  ? 'rgba(74, 222, 128, 0.5)'
                                  : isInvalidTouchDropZone
                                    ? 'rgba(239, 68, 68, 0.2)'
                                    : isDropTarget ? 'rgba(74, 222, 128, 0.4)' : isRecentlySub ? '#86efac' : player.isLibero ? '#FFF8E7' : undefined,
                                color: isRecentlySub ? '#000' : player.isLibero ? '#000' : undefined,
                                animation: isRecentlySub ? 'recentSubFlash 0.5s ease-in-out infinite' : undefined,
                                fontWeight: isRecentlySub ? 900 : undefined,
                                border: isTouchDropTargetCourt
                                  ? '3px solid #22c55e'
                                  : isInvalidTouchDropZone
                                    ? '2px dashed rgba(239, 68, 68, 0.5)'
                                    : isDropTarget ? '3px solid #4ade80' : isRecentlySub ? '3px solid #22c55e' : undefined,
                                boxShadow: isTouchDropTargetCourt
                                  ? '0 0 16px rgba(74, 222, 128, 0.6)'
                                  : isDropTarget ? '0 0 12px rgba(74, 222, 128, 0.5)' : undefined
                              }}
                              onClick={(e) => !touchDragState.isDragging && handlePlayerClick(rightTeamKey, player.position, player.number, e)}
                              onDragOver={(e) => handleCourtDragOver(e, rightTeamKey, player.position)}
                              onDragLeave={handleCourtDragLeave}
                              onDrop={(e) => handleCourtDrop(e, rightTeamKey, player.position, player.number)}
                              onMouseEnter={(e) => {
                                if (player.number && player.number !== '' && !isDropTarget) {
                                  e.currentTarget.style.transform = 'scale(1.05)'
                                  e.currentTarget.style.boxShadow = '0 4px 12px rgba(255,255,255,0.2)'
                                }
                              }}
                              onMouseLeave={(e) => {
                                if (player.number && player.number !== '' && !isDropTarget) {
                                  e.currentTarget.style.transform = 'scale(1)'
                                  e.currentTarget.style.boxShadow = 'none'
                                }
                              }}
                            >
                              {shouldShowBall && (
                                <img
                                  src={ballImage} onError={(e) => e.target.src = mikasaVolleyball}
                                  alt="Volleyball"
                                  style={{
                                    position: 'absolute',
                                    right: '-8vmin',
                                    top: '50%',
                                    transform: 'translateY(-50%)',
                                    width: '8vmin',
                                    height: '8vmin',
                                    zIndex: 5
                                  }}
                                />
                              )}
                              {replacementNumber && (
                                <span style={getReplacementBadgeStyle(player)}>
                                  {replacementNumber}
                                </span>
                              )}
                              <span className="court-player-position">{player.position}</span>
                              {/* Captain indicator - show C for captain (including libero-captain) */}
                              {player.isCaptain && (() => {
                                if (player.isLibero) {
                                  // Libero-captain ON COURT: show LC on white bg with green text
                                  return (
                                    <span className="court-player-captain" style={{ background: '#fff', color: '#10b981', borderColor: '#10b981', fontSize: '9px' }}>LC</span>
                                  )
                                }
                                return <span className="court-player-captain">C</span>
                              })()}
                              {/* Captain on Court indicator (different color) - uses pre-computed isCourtCaptain which checks if team captain is on court */}
                              {player.isCourtCaptain && (
                                <span
                                  className="court-player-captain"
                                  style={{
                                    background: player.isLibero ? '#3b82f6' : undefined,
                                    color: '#fbbf24',
                                    borderColor: '#fbbf24',
                                    fontSize: player.isLibero ? '9px' : undefined
                                  }}
                                >
                                  {player.isLibero ? 'LC' : 'C'}
                                </span>
                              )}
                              {/* Libero indicator (bottom-left) */}
                              {player.isLibero && !player.isCaptain && (() => {
                                const teamPlayers = rightTeamKey === 'home' ? data?.homePlayers : data?.awayPlayers
                                const liberoCount = teamPlayers?.filter(p => p.libero === 'libero1' || p.libero === 'libero2' || p.libero === 'redesignated').length || 0
                                const liberoType = player.liberoType
                                const isUnable = liberoType === 'unable'
                                const isRedesignated = liberoType === 'redesignated'

                                // Determine base label
                                let baseLabel = ''
                                if (liberoCount === 1) {
                                  baseLabel = 'L'
                                } else if (liberoType === 'libero1') {
                                  baseLabel = 'L1'
                                } else if (liberoType === 'libero2') {
                                  baseLabel = 'L2'
                                } else if (isRedesignated) {
                                  baseLabel = 'L'
                                } else {
                                  baseLabel = 'L'
                                }

                                return (
                                  <span style={{
                                    position: 'absolute',
                                    bottom: '-1vmin',
                                    left: '-1vmin',
                                    width: '2vmin',
                                    height: '2vmin',
                                    background: '#3b82f6',
                                    border: '2px solid rgba(255, 255, 255, 0.4)',
                                    borderRadius: '4px',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    fontSize: '1.35vmin',
                                    fontWeight: 700,
                                    color: '#fff',
                                    zIndex: 5,
                                    boxShadow: '0 2px 6px rgba(0, 0, 0, 0.4)'
                                  }}>
                                    <span style={{ position: 'relative', display: 'inline-block' }}>
                                      {baseLabel}
                                      {isRedesignated}
                                      {isUnable && (
                                        <span style={{
                                          position: 'absolute',
                                          top: '50%',
                                          left: '50%',
                                          transform: 'translate(-50%, -50%)',
                                          fontSize: '1.2em',
                                          color: '#ef4444',
                                          fontWeight: 900
                                        }}>✕</span>
                                      )}
                                    </span>
                                  </span>
                                )
                              })()}
                              {player.number}

                              {/* Sanction cards indicator */}
                              {sanctions.length > 0 && (
                                <div style={{
                                  position: 'absolute',
                                  bottom: '-1vmin',
                                  right: '-1vmin',
                                  zIndex: 10
                                }}>
                                  {hasExpulsion ? (
                                    // Expulsion: overlapping rotated cards
                                    <div style={{ position: 'relative', width: '2vmin', height: '2vmin' }}>
                                      <div className="sanction-card yellow" style={{
                                        width: '1vmin',
                                        height: '1.5vmin',
                                        boxShadow: '0 1px 3px rgba(0,0,0,0.8)',
                                        position: 'absolute',
                                        left: '0',
                                        top: '0.15vmin',
                                        transform: 'rotate(-8deg)',
                                        zIndex: 1,
                                        borderRadius: '1px'
                                      }}></div>
                                      <div className="sanction-card red" style={{
                                        width: '1vmin',
                                        height: '1.5vmin',
                                        boxShadow: '0 1px 3px rgba(0,0,0,0.8)',
                                        position: 'absolute',
                                        right: '0',
                                        top: '0.15vmin',
                                        transform: 'rotate(8deg)',
                                        zIndex: 2,
                                        borderRadius: '1px'
                                      }}></div>
                                    </div>
                                  ) : (
                                    // Other sanctions: separate cards
                                    <div style={{ display: 'flex', gap: '0.15vmin' }}>
                                      {(hasWarning || hasDisqualification) && (
                                        <div className="sanction-card yellow" style={{ width: '1.3vmin', height: '1.8vmin', boxShadow: '0 1px 3px rgba(0,0,0,0.8)', borderRadius: '1px' }}></div>
                                      )}
                                      {(hasPenalty || hasDisqualification) && (
                                        <div className="sanction-card red" style={{ width: '1.3vmin', height: '1.8vmin', boxShadow: '0 1px 3px rgba(0,0,0,0.8)', borderRadius: '1px' }}></div>
                                      )}
                                    </div>
                                  )}
                                </div>
                              )}
                              {/* Player name rectangle - clickable to expand/collapse full name */}
                              {showNamesOnCourt && (player.lastName || player.firstName) && !player.isPlaceholder && (
                                <div
                                  onClick={(e) => toggleExpandedPlayerName(rightTeamKey, player.number, e)}
                                  style={{
                                    position: 'absolute',
                                    bottom: '-27px',
                                    left: '50%',
                                    transform: 'translateX(-50%)',
                                    background: 'rgba(0, 0, 0, 0.85)',
                                    border: '1px solid rgba(255, 255, 255, 0.3)',
                                    borderRadius: '3px',
                                    padding: '1px 4px',
                                    fontSize: '9px',
                                    fontWeight: 600,
                                    color: '#fff',
                                    whiteSpace: 'nowrap',
                                    minWidth: '68px',
                                    zIndex: 10,
                                    textTransform: 'uppercase',
                                    letterSpacing: '0.3px',
                                    cursor: 'pointer',
                                    display: 'flex',
                                    flexDirection: 'column',
                                    alignItems: 'center',
                                    gap: '2px'
                                  }}>
                                  <div style={{ display: 'flex', alignItems: 'center', gap: '2px' }}>
                                    <span style={{ fontSize: '7px', opacity: 0.7, transform: expandedPlayerName === `${rightTeamKey}-${player.number}` ? 'rotate(180deg)' : 'none', transition: 'transform 0.2s' }}>▼</span>
                                    {expandedPlayerName === `${rightTeamKey}-${player.number}`
                                      ? `#${player.number}`
                                      : getCourtPlayerDisplayName(rightTeamKey, player.number, player.firstName, player.lastName)}
                                  </div>
                                  {expandedPlayerName === `${rightTeamKey}-${player.number}` && (
                                    <div style={{ fontSize: '8px', opacity: 0.9, borderTop: '1px solid rgba(255,255,255,0.2)', paddingTop: '2px', marginTop: '1px', display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                                      <div>{player.firstName}</div>
                                      <div>{player.lastName}</div>
                                    </div>
                                  )}
                                </div>
                              )}
                            </div>
                          )
                        })}
                      </div>
                      {/* Blur overlay when lineup is set but other team hasn't set theirs yet */}
                      {rightTeamLineupSet && !leftTeamLineupSet && isFirstRally && !peekingLineup.right && (
                        <div style={{
                          position: 'absolute',
                          top: 0,
                          left: 0,
                          right: 0,
                          bottom: 0,
                          background: 'rgba(0, 0, 0, 0.7)',
                          backdropFilter: 'blur(8px)',
                          display: 'flex',
                          flexDirection: 'column',
                          alignItems: 'center',
                          justifyContent: 'center',
                          gap: '12px',
                          zIndex: 50,
                          borderRadius: '8px'
                        }}>
                          <div style={{
                            fontSize: 'clamp(16px, 3vw, 24px)',
                            fontWeight: 700,
                            color: '#22c55e',
                            textAlign: 'center'
                          }}>
                            {t('scoreboard.lineupSet', 'Line-up set')}
                          </div>
                          <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap', justifyContent: 'center' }}>
                            <button
                              onMouseDown={() => setPeekingLineup(prev => ({ ...prev, right: true }))}
                              onMouseUp={() => setPeekingLineup(prev => ({ ...prev, right: false }))}
                              onMouseLeave={() => setPeekingLineup(prev => ({ ...prev, right: false }))}
                              onTouchStart={() => setPeekingLineup(prev => ({ ...prev, right: true }))}
                              onTouchEnd={() => setPeekingLineup(prev => ({ ...prev, right: false }))}
                              style={{
                                padding: '8px 16px',
                                fontSize: 'clamp(11px, 2vw, 14px)',
                                fontWeight: 600,
                                background: 'rgba(59, 130, 246, 0.3)',
                                color: '#fff',
                                border: '1px solid rgba(59, 130, 246, 0.5)',
                                borderRadius: '6px',
                                cursor: 'pointer'
                              }}
                            >
                              {t('scoreboard.showLineup', 'Show Line-up')}
                            </button>
                            <button
                              onClick={() => setLineupModal({ team: leftIsHome ? 'away' : 'home', mode: 'initial' })}
                              style={{
                                padding: '8px 16px',
                                fontSize: 'clamp(11px, 2vw, 14px)',
                                fontWeight: 600,
                                background: 'rgba(251, 191, 36, 0.3)',
                                color: '#fbbf24',
                                border: '1px solid rgba(251, 191, 36, 0.5)',
                                borderRadius: '6px',
                                cursor: 'pointer'
                              }}
                            >
                              {t('scoreboard.changeLineup', 'Change Line-up')}
                            </button>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                </div>

                {/* 2nd Referee - below court, or spacer if no 2R */}
                {!isCompactMode && (() => {
                  const ref2 = data?.match?.officials?.find(o => o.role === '2nd referee' || o.role === '2nd Referee')
                  const ref2Name = ref2 ? `${ref2.firstName || ''} ${ref2.lastName || ''}`.trim() : null
                  return (
                    <div style={{
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      marginTop: '-5px',
                      height: ref2Name ? 'auto' : '12px'
                    }}>
                      {ref2Name && (
                        <span style={{
                          fontSize: isLaptopMode ? '13px' : '16px',
                          color: 'var(--muted)',
                          whiteSpace: 'nowrap'
                        }}>
                          2R: {ref2Name}
                        </span>
                      )}
                    </div>
                  )
                })()}
              </>
            )}

            <div style={{
              display: 'flex',
              alignItems: 'stretch',
              gap: isCompactMode ? '8px' : '16px',
              width: '100%',
              minHeight: isCompactMode ? '100px' : '200px'
            }}>
              {/* Set Results Table - Left Team (hidden in compact mode - shown in team column instead) */}
              {!isCompactMode && (
                <div style={{
                  flex: '0 0 auto',
                  display: 'flex',
                  flexDirection: 'column',
                  justifyContent: 'center'
                }}>
                  {(() => {
                    // Get current left team
                    const currentLeftTeamKey = leftIsHome ? 'home' : 'away'
                    const leftTeamData = currentLeftTeamKey === 'home' ? data?.homeTeam : data?.awayTeam
                    const leftTeamColor = leftTeamData?.color || (currentLeftTeamKey === 'home' ? '#ef4444' : '#3b82f6')
                    const leftTeamLabel = currentLeftTeamKey === teamAKey ? 'A' : 'B'

                    // Get all sets, filter to show only current set and previous sets
                    // Also deduplicate by index (keep the latest one for each index)
                    const allSets = (data?.sets || []).sort((a, b) => a.index - b.index)
                    const currentSetIndex = data?.set?.index || 1
                    const setsByIndex = new Map()
                    allSets.forEach(set => {
                      if (set.index <= currentSetIndex) {
                        setsByIndex.set(set.index, set) // Later entries overwrite earlier ones
                      }
                    })
                    const visibleSets = Array.from(setsByIndex.values()).sort((a, b) => a.index - b.index)

                    return (
                      <div style={{
                        background: 'rgba(15, 23, 42, 0.6)',
                        border: '1px solid rgba(255, 255, 255, 0.08)',
                        borderRadius: '8px',
                        padding: '12px',
                        fontSize: '10px',
                        minWidth: '140px'
                      }}>
                        <h4 style={{ margin: '0 0 8px', fontSize: '12px', fontWeight: 600, textAlign: 'center' }}>
                          <span style={{
                            padding: '2px 8px',
                            borderRadius: '4px',
                            fontSize: '11px',
                            fontWeight: 700,
                            background: leftTeamColor,
                            color: isBrightColor(leftTeamColor) ? '#000' : '#fff'
                          }}>{leftTeamLabel}</span>
                        </h4>
                        <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '10px' }}>
                          <thead>
                            <tr style={{ borderBottom: '2px solid rgba(255,255,255,0.2)' }}>
                              <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '9px' }}>Set</th>
                              <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '9px' }}>P</th>
                              <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '9px' }}>W</th>
                              <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '9px' }}>S</th>
                              <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '9px' }}>T</th>
                            </tr>
                          </thead>
                          <tbody>
                            {visibleSets.map(set => {
                              const leftPoints = currentLeftTeamKey === 'home' ? set.homePoints : set.awayPoints
                              const rightPoints = currentLeftTeamKey === 'home' ? set.awayPoints : set.homePoints
                              const won = leftPoints > rightPoints ? 1 : 0
                              const substitutions = (data?.events || []).filter(e =>
                                e.type === 'substitution' && e.setIndex === set.index && e.payload?.team === currentLeftTeamKey
                              ).length
                              const timeouts = (data?.events || []).filter(e =>
                                e.type === 'timeout' && e.setIndex === set.index && e.payload?.team === currentLeftTeamKey
                              ).length

                              // Determine row color based on set status
                              let rowColor = 'inherit'
                              if (set.finished) {
                                rowColor = won === 1 ? '#22c55e' : '#ef4444' // Green if won, red if lost
                              }

                              return (
                                <tr key={set.id} style={{
                                  borderBottom: '1px solid rgba(255,255,255,0.1)',
                                  color: rowColor
                                }}>
                                  <td style={{ padding: '4px 2px', textAlign: 'center' }}>{set.index}</td>
                                  <td style={{ padding: '4px 2px', textAlign: 'center' }}>{leftPoints}</td>
                                  <td style={{ padding: '4px 2px', textAlign: 'center' }}>{won}</td>
                                  <td style={{ padding: '4px 2px', textAlign: 'center' }}>{substitutions}</td>
                                  <td style={{ padding: '4px 2px', textAlign: 'center' }}>{timeouts}</td>
                                </tr>
                              )
                            })}
                          </tbody>
                        </table>
                      </div>
                    )
                  })()}
                </div>
              )}

              {/* Rally Controls - Center */}
              <div className="rally-controls" style={{ flex: '1 1 auto', display: 'flex', flexDirection: 'column', justifyContent: 'center', marginTop: '12px' }}>
                {/* Show timeout countdown if timeout is active */}
                {timeoutModal && timeoutModal.started ? (
                  <>
                    <div style={{
                      fontSize: '16px',
                      fontWeight: 600,
                      color: 'var(--muted)',
                      textAlign: 'center',
                      marginBottom: '8px'
                    }}>
                      Time-out — {timeoutModal.team === 'home' ? (data?.homeTeam?.name || 'Home') : (data?.awayTeam?.name || 'Away')}
                    </div>
                    <div style={{
                      fontSize: '48px',
                      fontWeight: 700,
                      color: timeoutModal.countdown <= 10 ? '#ef4444' : 'var(--accent)',
                      textAlign: 'center',
                      fontFamily: getScoreFont()
                    }}>
                      {formatTimeout(timeoutModal.countdown)}
                    </div>
                    {/* Progress bar */}
                    <div style={{
                      width: '60%',
                      height: '8px',
                      background: 'rgba(255, 255, 255, 0.15)',
                      borderRadius: '4px',
                      overflow: 'hidden',
                      marginTop: '8px',
                      marginBottom: '16px',
                      marginLeft: 'auto',
                      marginRight: 'auto'
                    }}>
                      <div style={{
                        width: `${(timeoutModal.countdown / 30) * 100}%`,
                        height: '100%',
                        background: timeoutModal.countdown <= 10 ? '#ef4444' : 'var(--accent)',
                        borderRadius: '4px',
                        transition: 'width 1s linear, background 0.3s',
                        marginLeft: 'auto'
                      }} />
                    </div>
                    <button
                      className="secondary"
                      onClick={stopTimeout}
                      style={{ width: 'auto' }}
                    >
                      {t('scoreboard.buttons.stopTimeout')}
                    </button>
                  </>
                ) : (data?.set?.index === 5 && !set5SetupConfirmed) ? (
                  <>
                    {/* Set 5 inline setup UI - buttons first, countdown beneath */}
                    <div style={{
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      gap: '10px',
                      marginTop: '10vmin'
                    }}>
                      <button
                        onClick={async () => {
                          const newLeftTeam = data?.match?.set5LeftTeam === 'A' ? 'B' : 'A'
                          await db.matches.update(matchId, { set5LeftTeam: newLeftTeam })
                        }}
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          gap: '12px',
                          padding: '16px 0',
                          fontSize: '18px',
                          fontWeight: 700,
                          background: '#22c55e',
                          color: '#fff',
                          border: 'none',
                          borderRadius: '12px',
                          cursor: 'pointer',
                          width: '300px',
                          height: '56px'
                        }}
                      >
                        <span style={{ fontSize: '24px' }}>↔</span>
                        {t('scoreboard.buttons.switchSides')}
                      </button>
                      <button
                        onClick={async () => {
                          const newFirstServe = data?.match?.set5FirstServe === 'A' ? 'B' : 'A'
                          await db.matches.update(matchId, { set5FirstServe: newFirstServe })
                        }}
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          gap: '12px',
                          padding: '16px 0',
                          fontSize: '18px',
                          fontWeight: 700,
                          background: '#22c55e',
                          color: '#fff',
                          border: 'none',
                          borderRadius: '12px',
                          cursor: 'pointer',
                          width: '300px',
                          height: '56px'
                        }}
                      >
                        <img src={ballImage} onError={(e) => e.target.src = mikasaVolleyball} alt="" style={{ width: 32, height: 32, objectFit: 'contain' }} />
                        {t('scoreboard.buttons.switchServe')}
                      </button>
                      <button
                        onClick={() => {
                          confirmSet5SideService(data?.match?.set5LeftTeam || 'A', data?.match?.set5FirstServe || 'A', true)
                          setBetweenSetsCountdown(null)
                        }}
                        style={{
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          gap: '12px',
                          padding: '16px 0',
                          fontSize: '18px',
                          fontWeight: 700,
                          background: '#3b82f6',
                          color: '#fff',
                          border: 'none',
                          borderRadius: '12px',
                          cursor: 'pointer',
                          width: '300px',
                          height: '56px'
                        }}
                      >
                        {t('scoreboard.buttons.confirmSet5Setup')}
                      </button>
                    </div>

                    {/* Countdown beneath buttons - only shown if active */}
                    {betweenSetsCountdown && (
                      <div style={{ marginTop: '20px', textAlign: 'center' }}>
                        <div style={{
                          fontSize: '49px',
                          fontWeight: 700,
                          color: betweenSetsCountdown.countdown <= 30 ? '#ef4444' : 'var(--accent)',
                          fontFamily: getScoreFont()
                        }}>
                          {betweenSetsCountdown.countdown <= 0 ? "0" : formatCountdown(betweenSetsCountdown.countdown)}
                        </div>
                        <div style={{
                          width: '60%',
                          height: '8px',
                          background: 'rgba(255, 255, 255, 0.15)',
                          borderRadius: '4px',
                          overflow: 'hidden',
                          marginTop: '8px',
                          marginLeft: 'auto',
                          marginRight: 'auto'
                        }}>
                          <div style={{
                            width: `${setIntervalDuration > 0 ? (betweenSetsCountdown.countdown / setIntervalDuration) * 100 : 0}%`,
                            height: '100%',
                            background: betweenSetsCountdown.countdown <= 30 ? '#ef4444' : 'var(--accent)',
                            borderRadius: '4px',
                            transition: 'width 1s linear, background 0.3s',
                            marginLeft: 'auto'
                          }} />
                        </div>
                      </div>
                    )}
                  </>
                ) : betweenSetsCountdown ? (
                  <>
                    <div style={{
                      fontSize: '49px',
                      fontWeight: 700,
                      color: betweenSetsCountdown.countdown <= 30 ? '#ef4444' : 'var(--accent)',
                      textAlign: 'center',
                      fontFamily: getScoreFont()
                    }}>
                      {betweenSetsCountdown.countdown <= 0 ? "0" : formatCountdown(betweenSetsCountdown.countdown)}
                    </div>
                    {/* Progress bar */}
                    <div style={{
                      width: '60%',
                      height: '8px',
                      background: 'rgba(255, 255, 255, 0.15)',
                      borderRadius: '4px',
                      overflow: 'hidden',
                      marginTop: '8px',
                      marginBottom: '16px',
                      marginLeft: 'auto',
                      marginRight: 'auto'
                    }}>
                      <div style={{
                        width: `${(betweenSetsCountdown.countdown / setIntervalDuration) * 100}%`,
                        height: '100%',
                        background: betweenSetsCountdown.countdown <= 30 ? '#ef4444' : 'var(--accent)',
                        borderRadius: '4px',
                        transition: 'width 1s linear, background 0.3s',
                        marginLeft: 'auto'
                      }} />
                    </div>
                    <button
                      className="secondary"
                      onClick={endSetInterval}
                      style={{ width: 'auto' }}
                    >
                      {t('scoreboard.buttons.endSetInterval')}
                    </button>
                  </>
                ) : (
                  <>
                    {rallyStatus === 'idle' ? (
                      <button
                        className="secondary start-rally-button"
                        onClick={handleStartRally}
                        disabled={isFirstRally && (!leftTeamLineupSet || !rightTeamLineupSet)}
                      >
                        {isFirstRally ? t('scoreboard.buttons.startSet') : t('scoreboard.buttons.startRally')}
                      </button>
                    ) : (
                      <>
                        <div className="rally-controls-row" style={{ gap: '5px' }}>
                          <button className="rally-point-button" onClick={() => handlePoint('left')}>
                            {t('scoreboard.buttons.pointTeam', { team: teamALabel })}
                          </button>
                          <button className="rally-point-button" onClick={() => handlePoint('right')}>
                            {t('scoreboard.buttons.pointTeam', { team: teamBLabel })}
                          </button>
                        </div>
                      </>
                    )}
                    <div style={{ display: 'flex', gap: '8px' }}>
                      {rallyStatus === 'in_play' && (
                        <button
                          className="secondary"
                          onClick={handleReplay}
                          style={{ flex: 1 }}
                        >
                          {t('scoreboard.buttons.replay')}
                        </button>
                      )}
                      {rallyStatus === 'idle' && canReplayRally && (
                        <button
                          onClick={handleReplay}
                          style={{
                            flex: 1,
                            background: '#eab308',
                            color: '#000',
                            border: 'none',
                            borderRadius: '8px',
                            padding: '8px 12px',
                            fontSize: '13px',
                            fontWeight: 600,
                            cursor: 'pointer'
                          }}
                        >
                          {t('scoreboard.buttons.decisionChange')}
                        </button>
                      )}
                      <button
                        className="danger"
                        onClick={showUndoConfirm}
                        disabled={!canUndo}
                        style={{
                          flex: (rallyStatus === 'in_play' || (rallyStatus === 'idle' && canReplayRally)) ? 1 : 'none',
                          padding: '8px 12px',
                          fontSize: '13px'
                        }}
                      >
                        {t('scoreboard.buttons.undo')}
                      </button>
                    </div>
                    {/* Rally status and last action - only show beneath rally controls in full desktop mode (compact and laptop show in header) */}
                    {!isCompactMode && !isLaptopMode && (
                      <div
                        style={{
                          marginTop: '8px',
                          textAlign: 'center'
                        }}
                      >
                        <div style={{ fontSize: '12px' }}>
                          <span className="summary-label">{t('scoreboard.labels.rallyStatus')}: </span>
                          <span className="summary-value" style={{ color: rallyStatus === 'in_play' ? '#4ade80' : '#fb923c' }}>
                            {rallyStatus === 'in_play' ? t('scoreboard.labels.inPlay') : t('scoreboard.labels.notInPlay')}
                          </span>
                        </div>
                        {/* Last action - filtered to current set */}
                        {data?.events && data.events.length > 0 && data?.set && (() => {
                          // IMPORTANT: Only show events from the CURRENT SET
                          const currentSetIndex = data.set.index
                          const currentSetEvents = data.events.filter(e => e.setIndex === currentSetIndex)

                          if (currentSetEvents.length === 0) return null

                          // Sort by sequence number (highest first)
                          const sortedEvents = [...currentSetEvents].sort((a, b) => {
                            const aSeq = a.seq || 0
                            const bSeq = b.seq || 0
                            if (aSeq !== 0 || bSeq !== 0) {
                              return bSeq - aSeq // Descending
                            }
                            // Fallback to timestamp
                            const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
                            const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
                            return bTime - aTime
                          })

                          // Helper to check if an event is a sub-event (decimal sequence like 7.1)
                          const isSubEvent = (event) => {
                            const seq = event.seq || 0
                            return seq !== Math.floor(seq)
                          }

                          // Find the last main event (integer sequence)
                          let lastEvent = null
                          for (const e of sortedEvents) {
                            // Skip sub-events (they're part of their parent)
                            if (isSubEvent(e)) continue

                            // Skip rally_start and replay from display
                            if (e.type === 'rally_start' || e.type === 'replay') continue

                            // For lineup events, only show initial or substitution
                            if (e.type === 'lineup') {
                              const hasInitial = e.payload?.isInitial === true
                              const hasSubstitution = e.payload?.fromSubstitution === true
                              if (!hasInitial && !hasSubstitution) continue
                            }

                            // Try to get description
                            const desc = getActionDescription(e)
                            if (desc && desc !== 'Unknown action') {
                              lastEvent = e
                              break
                            }
                          }

                          if (!lastEvent) return null

                          const description = getActionDescription(lastEvent)

                          return (
                            <div style={{ fontSize: '12px', wordBreak: 'break-word', margin: '0 auto', whiteSpace: 'normal' }}>
                              <span className="summary-label" style={{ whiteSpace: 'normal' }}>{t('scoreboard.lastAction', 'Last action:')} </span>
                              <span className="summary-value" style={{ color: 'var(--muted)', whiteSpace: 'normal' }}>
                                {description} <span style={{ opacity: 0.5, fontSize: '10px' }}>(seq: {lastEvent.seq})</span>
                              </span>
                            </div>
                          )
                        })()}
                      </div>
                    )}
                  </>
                )}
              </div>

              {/* Set Results Table - Right Team (hidden in compact mode - shown in team column instead) */}
              {!isCompactMode && (
                <div style={{
                  flex: '0 0 auto',
                  display: 'flex',
                  flexDirection: 'column',
                  justifyContent: 'center'
                }}>
                  {(() => {
                    // Get current right team
                    const currentRightTeamKey = leftIsHome ? 'away' : 'home'
                    const rightTeamData = currentRightTeamKey === 'home' ? data?.homeTeam : data?.awayTeam
                    const rightTeamColor = rightTeamData?.color || (currentRightTeamKey === 'home' ? '#ef4444' : '#3b82f6')
                    const rightTeamLabel = currentRightTeamKey === teamAKey ? 'A' : 'B'

                    // Get all sets, filter to show only current set and previous sets
                    // Also deduplicate by index (keep the latest one for each index)
                    const allSets = (data?.sets || []).sort((a, b) => a.index - b.index)
                    const currentSetIndex = data?.set?.index || 1
                    const setsByIndex = new Map()
                    allSets.forEach(set => {
                      if (set.index <= currentSetIndex) {
                        setsByIndex.set(set.index, set) // Later entries overwrite earlier ones
                      }
                    })
                    const visibleSets = Array.from(setsByIndex.values()).sort((a, b) => a.index - b.index)

                    return (
                      <div style={{
                        background: 'rgba(15, 23, 42, 0.6)',
                        border: '1px solid rgba(255, 255, 255, 0.08)',
                        borderRadius: '8px',
                        padding: '12px',
                        fontSize: '10px',
                        minWidth: '140px'
                      }}>
                        <h4 style={{ margin: '0 0 8px', fontSize: '12px', fontWeight: 600, textAlign: 'center' }}>
                          <span style={{
                            padding: '2px 8px',
                            borderRadius: '4px',
                            fontSize: '11px',
                            fontWeight: 700,
                            background: rightTeamColor,
                            color: isBrightColor(rightTeamColor) ? '#000' : '#fff'
                          }}>{rightTeamLabel}</span>
                        </h4>
                        <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '10px' }}>
                          <thead>
                            <tr style={{ borderBottom: '2px solid rgba(255,255,255,0.2)' }}>
                              <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '9px' }}>Set</th>
                              <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '9px' }}>P</th>
                              <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '9px' }}>W</th>
                              <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '9px' }}>S</th>
                              <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '9px' }}>T</th>
                            </tr>
                          </thead>
                          <tbody>
                            {visibleSets.map(set => {
                              const rightPoints = currentRightTeamKey === 'home' ? set.homePoints : set.awayPoints
                              const leftPoints = currentRightTeamKey === 'home' ? set.awayPoints : set.homePoints
                              const won = rightPoints > leftPoints ? 1 : 0
                              const substitutions = (data?.events || []).filter(e =>
                                e.type === 'substitution' && e.setIndex === set.index && e.payload?.team === currentRightTeamKey
                              ).length
                              const timeouts = (data?.events || []).filter(e =>
                                e.type === 'timeout' && e.setIndex === set.index && e.payload?.team === currentRightTeamKey
                              ).length

                              // Determine row color based on set status
                              let rowColor = 'inherit'
                              if (set.finished) {
                                rowColor = won === 1 ? '#22c55e' : '#ef4444' // Green if won, red if lost
                              }

                              return (
                                <tr key={set.id} style={{
                                  borderBottom: '1px solid rgba(255,255,255,0.1)',
                                  color: rowColor
                                }}>
                                  <td style={{ padding: '4px 2px', textAlign: 'center' }}>{set.index}</td>
                                  <td style={{ padding: '4px 2px', textAlign: 'center' }}>{rightPoints}</td>
                                  <td style={{ padding: '4px 2px', textAlign: 'center' }}>{won}</td>
                                  <td style={{ padding: '4px 2px', textAlign: 'center' }}>{substitutions}</td>
                                  <td style={{ padding: '4px 2px', textAlign: 'center' }}>{timeouts}</td>
                                </tr>
                              )
                            })}
                          </tbody>
                        </table>
                      </div>
                    )
                  })()}
                </div>
              )}
            </div>
          </ScoreboardCourtColumn>

          <ScoreboardTeamColumn side="right">
            <div className="team-info" style={{ overflow: 'hidden' }}>
              <div
                style={{
                  display: 'inline-flex',
                  alignItems: 'center',
                  gap: '6px',
                  padding: isCompactMode ? '4px 8px' : '6px 12px',
                  background: rightTeam.color || '#3b82f6',
                  color: isBrightColor(rightTeam.color || '#3b82f6') ? '#000' : '#fff',
                  borderRadius: '6px',
                  fontWeight: 600,
                  fontSize: isCompactMode ? '11px' : '14px',
                  marginBottom: '8px',
                  maxWidth: '100%',
                  overflow: 'hidden',
                  whiteSpace: 'nowrap',
                  textOverflow: 'ellipsis'
                }}
              >
                <span style={{ flexShrink: 0 }}>{teamBLabel}</span>
                <span style={{ flexShrink: 0 }}>-</span>
                <span style={{ overflow: 'hidden', textOverflow: 'ellipsis', minWidth: isNarrowMode ? '30px' : '40px' }}>{teamBShortName}</span>
                {(isCompactMode || headerCollapsed) && (
                  <span style={{
                    marginLeft: '4px',
                    padding: '2px 6px',
                    background: 'rgba(255, 255, 255, 0.2)',
                    borderRadius: '4px',
                    fontWeight: 700,
                    flexShrink: 0
                  }}>
                    {setsWon.right}
                  </span>
                )}
              </div>
            </div>
            <div style={{ display: 'flex', gap: '4px', marginBottom: (isCompactMode || isShortHeight) ? '4px' : '8px' }}>
              <div
                onClick={() => {
                  // Clicking calls timeout if available
                  const canCallTimeout = getTimeoutsUsed('right') < 2 && rallyStatus !== 'in_play' && !isRallyReplayed
                  if (canCallTimeout) {
                    handleTimeout('right')
                  }
                }}
                className="to-sub-counter"
                style={{
                  flex: 1,
                  background: getTimeoutsUsed('right') >= 2
                    ? 'rgba(239, 68, 68, 0.2)'
                    : (rallyStatus === 'in_play' || isRallyReplayed
                      ? 'rgba(255, 255, 255, 0.05)'
                      : 'rgba(34, 197, 94, 0.2)'),
                  borderRadius: (isCompactMode || isShortHeight) ? '4px' : '8px',
                  padding: (isCompactMode || isShortHeight) ? '4px' : '12px',
                  textAlign: 'center',
                  border: getTimeoutsUsed('right') >= 2
                    ? '1px solid rgba(239, 68, 68, 0.4)'
                    : (rallyStatus === 'in_play' || isRallyReplayed
                      ? '1px solid rgba(255, 255, 255, 0.1)'
                      : '1px solid rgba(34, 197, 94, 0.4)'),
                  cursor: getTimeoutsUsed('right') >= 2 || rallyStatus === 'in_play' || isRallyReplayed ? 'not-allowed' : 'pointer'
                }}
              >
                <div className="to-sub-label" style={{ fontSize: (isCompactMode || isShortHeight) ? '8px' : '11px', color: 'var(--muted)', marginBottom: (isCompactMode || isShortHeight) ? '1px' : '4px' }}>{t('scoreboard.labels.to')}</div>
                <div className="to-sub-value" style={{
                  fontSize: (isCompactMode || isShortHeight) ? '14px' : '24px',
                  fontWeight: 700,
                  color: getTimeoutsUsed('right') >= 2 ? '#ef4444' : (!(rallyStatus === 'in_play' || isRallyReplayed) ? '#22c55e' : 'inherit')
                }}>{getTimeoutsUsed('right')}</div>
              </div>
              <div
                onClick={() => {
                  const subs = getSubstitutionDetails('right')
                  if (subs.length > 0) {
                    setToSubDetailsModal({ type: 'substitution', side: 'right' })
                  }
                }}
                className="to-sub-counter"
                style={{
                  flex: 1,
                  background: getSubstitutionsUsed('right') >= 6
                    ? 'rgba(239, 68, 68, 0.2)'
                    : getSubstitutionsUsed('right') >= 5
                      ? 'rgba(234, 179, 8, 0.2)'
                      : 'rgba(255, 255, 255, 0.05)',
                  borderRadius: (isCompactMode || isShortHeight) ? '4px' : '8px',
                  padding: (isCompactMode || isShortHeight) ? '4px' : '12px',
                  textAlign: 'center',
                  border: getSubstitutionsUsed('right') >= 6
                    ? '1px solid rgba(239, 68, 68, 0.4)'
                    : getSubstitutionsUsed('right') >= 5
                      ? '1px solid rgba(234, 179, 8, 0.4)'
                      : '1px solid rgba(255, 255, 255, 0.1)',
                  cursor: getSubstitutionDetails('right').length > 0 ? 'pointer' : 'default'
                }}
              >
                <div className="to-sub-label" style={{ fontSize: (isCompactMode || isShortHeight) ? '8px' : '11px', color: 'var(--muted)', marginBottom: (isCompactMode || isShortHeight) ? '1px' : '4px' }}>{t('scoreboard.labels.sub')}</div>
                <div className="to-sub-value" style={{
                  fontSize: (isCompactMode || isShortHeight) ? '14px' : '24px',
                  fontWeight: 700,
                  color: getSubstitutionsUsed('right') >= 6 ? '#ef4444' : getSubstitutionsUsed('right') >= 5 ? '#eab308' : 'inherit'
                }}>{getSubstitutionsUsed('right')}</div>
              </div>
            </div>
            {(() => {
              const teamKey = leftIsHome ? 'away' : 'home'
              const teamPlayers = leftIsHome ? data?.awayPlayers : data?.homePlayers
              // Get ALL liberos from player list (including on court), excluding already-unable ones
              const liberos = teamPlayers?.filter(p => p.libero && p.libero !== '' && p.libero !== 'unable') || []
              const activeLiberos = liberos.filter(p => !isLiberoUnable(teamKey, p.number))
              const unableLiberos = liberos.filter(p => isLiberoUnable(teamKey, p.number))

              // Check if already redesignated
              const alreadyRedesignated = data?.events?.some(e =>
                e.type === 'libero_redesignation' &&
                e.payload?.team === teamKey
              )

              // Show redesignation when ALL liberos are unable (whether 1 or 2)
              const needsRedesignation = liberos.length > 0 && activeLiberos.length === 0 && !alreadyRedesignated

              if (needsRedesignation) {
                const lastUnable = unableLiberos[unableLiberos.length - 1]
                return (
                  <div style={{ display: 'flex', gap: '8px', marginBottom: '8px', width: '100%' }}>
                    <button
                      onClick={() => {
                        setLiberoRedesignationModal({
                          team: teamKey,
                          unableLiberoNumber: lastUnable.number,
                          unableLiberoType: lastUnable.libero
                        })
                      }}
                      disabled={rallyStatus === 'in_play' || isRallyReplayed}
                      style={{
                        flex: 1,
                        fontSize: '10px',
                        padding: '8px 4px',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        background: 'rgba(239, 68, 68, 0.2)',
                        borderColor: 'rgba(239, 68, 68, 0.4)',
                        color: '#f87171'
                      }}
                    >
                      Redesignate Libero
                    </button>
                  </div>
                )
              }

              // Libero out/exchange controls moved to player action menu when clicking libero on court
              return null
            })()}

            {/* Sanctions: Improper Request, Delay Warning, Delay Penalty */}
            {isNarrowMode ? (
              <div style={{ marginTop: '4px' }}>
                <button
                  onClick={() => setRightDelaysDropdownOpen(!rightDelaysDropdownOpen)}
                  style={{ width: '100%', fontSize: '10px', padding: '8px 4px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}
                >
                  {t('scoreboard.sanctions.irAndDelays')} {rightDelaysDropdownOpen ? '▲' : '▼'}
                </button>
                {rightDelaysDropdownOpen && (
                  <div style={{ marginTop: '4px', display: 'flex', flexDirection: 'column', gap: '4px' }}>
                    {!data?.match?.sanctions?.[leftIsHome ? 'improperRequestAway' : 'improperRequestHome'] && (
                      <button
                        onClick={() => { handleImproperRequest('right'); setRightDelaysDropdownOpen(false) }}
                        disabled={rallyStatus === 'in_play'}
                        style={sanctionButtonStyles.improper}
                      >
                        {t('scoreboard.sanctions.improperRequest')}
                      </button>
                    )}
                    {!data?.match?.sanctions?.[leftIsHome ? 'delayWarningAway' : 'delayWarningHome'] ? (
                      <button
                        onClick={() => { handleDelayWarning('right'); setRightDelaysDropdownOpen(false) }}
                        disabled={rallyStatus === 'in_play'}
                        style={sanctionButtonStyles.delayWarning}
                      >
                        {t('scoreboard.sanctions.delayWarning')}
                      </button>
                    ) : (
                      <button
                        onClick={() => { handleDelayPenalty('right'); setRightDelaysDropdownOpen(false) }}
                        disabled={rallyStatus === 'in_play'}
                        style={sanctionButtonStyles.delayPenalty}
                      >
                        {t('scoreboard.sanctions.delayPenalty')}
                      </button>
                    )}
                  </div>
                )}
              </div>
            ) : (
              <div style={{ display: 'flex', gap: '4px', marginTop: '8px' }}>
                {!data?.match?.sanctions?.[leftIsHome ? 'improperRequestAway' : 'improperRequestHome'] && (
                  <button
                    onClick={() => handleImproperRequest('right')}
                    disabled={rallyStatus === 'in_play'}
                    style={sanctionButtonStyles.improper}
                  >
                    {t('scoreboard.sanctions.improperRequest')}
                  </button>
                )}
                {!data?.match?.sanctions?.[leftIsHome ? 'delayWarningAway' : 'delayWarningHome'] ? (
                  <button
                    onClick={() => handleDelayWarning('right')}
                    disabled={rallyStatus === 'in_play'}
                    style={sanctionButtonStyles.delayWarning}
                  >
                    {t('scoreboard.sanctions.delayWarning')}
                  </button>
                ) : (
                  <button
                    onClick={() => handleDelayPenalty('right')}
                    disabled={rallyStatus === 'in_play'}
                    style={sanctionButtonStyles.delayPenalty}
                  >
                    {t('scoreboard.sanctions.delayPenalty')}
                  </button>
                )}
              </div>
            )}

            {/* Status boxes for team sanctions */}
            <div style={{ marginTop: '8px', display: 'flex', flexDirection: 'column', gap: '4px' }}>
              {data?.match?.sanctions?.[leftIsHome ? 'improperRequestAway' : 'improperRequestHome'] && (
                <div style={{
                  padding: '4px 8px',
                  fontSize: '12px',
                  background: 'rgba(156, 163, 175, 0.15)',
                  border: '1px solid rgba(156, 163, 175, 0.3)',
                  borderRadius: '4px',
                  color: '#d1d5db'
                }}>
                  {t('scoreboard.sanctions.sanctionedImproperRequest')}
                </div>
              )}
              {data?.match?.sanctions?.[leftIsHome ? 'delayWarningAway' : 'delayWarningHome'] && (
                <div style={{
                  padding: '4px 8px',
                  fontSize: '12px',
                  background: 'rgba(234, 179, 8, 0.15)',
                  border: '1px solid rgba(234, 179, 8, 0.3)',
                  borderRadius: '4px',
                  color: '#facc15'
                }}>
                  {t('scoreboard.sanctions.sanctionedDelayWarning')}
                </div>
              )}
              {teamHasFormalWarning(leftIsHome ? 'away' : 'home') && (
                <div style={{
                  padding: '4px 8px',
                  fontSize: '12px',
                  background: 'rgba(250, 204, 21, 0.15)',
                  border: '1px solid rgba(250, 204, 21, 0.3)',
                  borderRadius: '4px',
                  color: '#fde047'
                }}>
                  {t('scoreboard.sanctions.sanctionedFormalWarning')} 🟨
                </div>
              )}
            </div>


            {/* Bench Players, Liberos, and Bench Officials */}
            <div style={{ marginTop: isCompactMode ? '12px' : '24px', paddingTop: isCompactMode ? '12px' : '24px', borderTop: '1px solid rgba(255,255,255,0.1)' }}>
              {/* Bench Players */}
              {rightTeamBench.benchPlayers.length > 0 && (
                <div style={{ marginBottom: isCompactMode ? '8px' : '16px' }}>
                  <h4
                    onClick={() => isCompactMode && setRightMainBenchExpanded(!rightMainBenchExpanded)}
                    style={{
                      margin: '0 0 8px',
                      fontSize: '12px',
                      fontWeight: 600,
                      color: 'var(--muted)',
                      cursor: isCompactMode ? 'pointer' : 'default',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between'
                    }}
                  >
                    <span>{t('scoreboard.roster.bench')}</span>
                    {isCompactMode && <span style={{ fontSize: '10px' }}>{rightMainBenchExpanded ? '▲' : '▼'}</span>}
                  </h4>
                  {(!isCompactMode || rightMainBenchExpanded) && (
                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                      {rightTeamBench.benchPlayers.map(player => {
                        const teamKey = leftIsHome ? 'away' : 'home'
                        const canComeBack = canPlayerComeBack(teamKey, player.number)
                        const hasComeBack = hasPlayerComeBack(teamKey, player.number)
                        const isSubstitutedByLibero = player.substitutedByLibero !== null

                        // Check if player was substituted out but waiting for point to allow comeback
                        const substitutions = getSubstitutionHistory(teamKey)
                        const wasSubstitutedOut = substitutions.some(s => String(s.payload?.playerOut) === String(player.number))
                        const waitingForPoint = wasSubstitutedOut && !canComeBack && !hasComeBack

                        // Find which player on court this bench player replaced (if they were substituted in)
                        const substitutionWherePlayerIn = substitutions
                          .filter(s => String(s.payload?.playerIn) === String(player.number))
                          .sort((a, b) => new Date(b.ts) - new Date(a.ts))[0] // Get most recent
                        const playerOnCourtReplaced = substitutionWherePlayerIn?.payload?.playerOut || null

                        // Find who replaced this player when they were substituted out (for yellow-background display)
                        const playerWhoReplacedThem = wasSubstitutedOut ? (() => {
                          const subEvent = substitutions
                            .filter(s => String(s.payload?.playerOut) === String(player.number))
                            .sort((a, b) => new Date(b.ts) - new Date(a.ts))[0]
                          return subEvent?.payload?.playerIn || null
                        })() : null

                        // Check if player was substituted due to expulsion (cannot re-enter for rest of set)
                        const wasExpelledSub = wasSubstitutedDueToExpulsion(teamKey, player.number)
                        const expulsionSub = wasExpelledSub ? data.events?.find(e =>
                          e.type === 'substitution' &&
                          e.payload?.team === teamKey &&
                          String(e.payload?.playerOut) === String(player.number) &&
                          e.payload?.isExpelled === true
                        ) : null
                        const isExpelledInSet = wasExpelledSub && expulsionSub && expulsionSub.setIndex === data.set.index

                        // Check if player was substituted due to disqualification (cannot re-enter for rest of game)
                        const isDisqualifiedSub = wasSubstitutedDueToDisqualification(teamKey, player.number)

                        // Check if player was exceptionally substituted (cannot re-enter for rest of game)
                        const isExceptionallySub = wasExceptionallySubstituted(teamKey, player.number)

                        // Also check for sanction-based expulsion/disqualification (for display)
                        const hasExpulsionSanction = data.events?.some(e =>
                          e.type === 'sanction' &&
                          e.payload?.team === teamKey &&
                          e.payload?.playerNumber === player.number &&
                          e.payload?.type === 'expulsion' &&
                          e.setIndex === data.set.index
                        )
                        const hasDisqualificationSanction = data.events?.some(e =>
                          e.type === 'sanction' &&
                          e.payload?.team === teamKey &&
                          e.payload?.playerNumber === player.number &&
                          e.payload?.type === 'disqualification'
                        )

                        // Show X if substituted due to expulsion, disqualification, or exceptional substitution
                        const showX = isExpelledInSet || isDisqualifiedSub || isExceptionallySub || hasExpulsionSanction || hasDisqualificationSanction

                        // Get sanctions for this player (RIGHT TEAM)
                        const sanctions = getPlayerSanctions(teamKey, player.number)
                        const hasWarning = sanctions.some(s => s.payload?.type === 'warning')
                        const hasPenalty = sanctions.some(s => s.payload?.type === 'penalty')
                        const hasExpulsion = sanctions.some(s => s.payload?.type === 'expulsion')
                        const hasDisqualification = sanctions.some(s => s.payload?.type === 'disqualification')

                        // Determine if bench player can substitute (RIGHT TEAM)
                        // Case 1: Player was substituted out - can only come back for the player who replaced them
                        // Case 2: Player never played - can substitute for any court player (if team has subs left)
                        // BUT: If player is currently replaced by libero, they cannot substitute at all
                        const neverPlayed = !wasSubstitutedOut && !hasComeBack && !isSubstitutedByLibero
                        const canComeBackFromSub = wasSubstitutedOut && canComeBack && !hasComeBack && !isSubstitutedByLibero
                        const canSubBenchPlayer = !showX && !isSubstitutedByLibero && (canComeBackFromSub || neverPlayed)

                        // Find the court player this bench player can swap with
                        let courtPlayerToSwapWith = null
                        if (canComeBackFromSub) {
                          // Player was substituted out - can only swap with the player who replaced them
                          const subEvent = substitutions
                            .filter(s => String(s.payload?.playerOut) === String(player.number))
                            .sort((a, b) => new Date(b.ts) - new Date(a.ts))[0]
                          if (subEvent?.payload?.playerIn) {
                            // Get the CURRENT position of the player who replaced them (not the original position from the sub event)
                            // The position may have changed due to rotations
                            const currentLineup = getCurrentLineup(teamKey)
                            const playerInNumber = String(subEvent.payload.playerIn)
                            let currentPosition = null
                            if (currentLineup) {
                              for (const [pos, num] of Object.entries(currentLineup)) {
                                if (String(num) === playerInNumber) {
                                  currentPosition = pos
                                  break
                                }
                              }
                            }
                            if (currentPosition) {
                              courtPlayerToSwapWith = {
                                number: subEvent.payload.playerIn,
                                position: currentPosition
                              }
                            }
                          }
                        }
                        // For neverPlayed case, courtPlayerToSwapWith stays null - we'll show expandable list
                        const isDragging = draggedPlayer?.team === teamKey && draggedPlayer?.playerNumber === player.number && draggedPlayer?.type === 'bench'
                        const isDropTargetForCourt = dropTargetBench?.team === teamKey && dropTargetBench?.playerNumber === player.number && !dropTargetBench?.isLibero

                        // Check if this player is a valid drop target during touch drag (RIGHT TEAM)
                        const isTouchDropTarget = touchDragState.isDragging && validDropTargets.some(t =>
                          t.type === 'bench' && t.team === teamKey && String(t.playerNumber) === String(player.number) && !t.isLibero
                        )

                        return (
                          <div
                            key={`${teamKey}-bench-${player.id || player.number}`}
                            data-bench-player={player.number}
                            data-team={teamKey}
                            data-is-libero="false"
                            draggable={rallyStatus === 'idle' && (canSubBenchPlayer || isSubstitutedByLibero)}
                            onDragStart={(e) => (canSubBenchPlayer || isSubstitutedByLibero) && handleBenchDragStart(e, teamKey, player.number, false)}
                            onDragEnd={handleBenchDragEnd}
                            onDragOver={(e) => (canSubBenchPlayer || isSubstitutedByLibero) && handleBenchDropOver(e, teamKey, player.number, false)}
                            onDragLeave={handleBenchDropLeave}
                            onDrop={(e) => (canSubBenchPlayer || isSubstitutedByLibero) && handleBenchDrop(e, teamKey, player.number, false)}
                            onTouchStart={(e) => (canSubBenchPlayer || isSubstitutedByLibero) && handleTouchDragStart(e, { team: teamKey, playerNumber: player.number, type: 'bench', isLibero: false })}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                            onTouchCancel={handleTouchCancel}
                            onClick={(e) => {
                              if (rallyStatus === 'idle' && !touchDragState.isDragging) {
                                const rect = e.currentTarget.getBoundingClientRect()
                                setBenchPlayerActionMenu({
                                  team: teamKey,
                                  playerNumber: player.number,
                                  element: e.currentTarget,
                                  x: rect.left + 8,
                                  y: rect.top - 8,
                                  side: 'right',
                                  canSubstitute: canSubBenchPlayer,
                                  courtPlayerToSwapWith: courtPlayerToSwapWith,
                                  neverPlayed: neverPlayed
                                })
                              }
                            }}
                            style={{
                              padding: '5px 10px',
                              touchAction: (canSubBenchPlayer || isSubstitutedByLibero) ? 'none' : undefined,
                              background: isTouchDropTarget
                                ? 'rgba(74, 222, 128, 0.4)'  // Green for valid touch drop target
                                : isDropTargetForCourt
                                  ? 'rgba(239, 68, 68, 0.4)'  // Red highlight for court player drop
                                  : isSubstitutedByLibero
                                    ? '#ffffff'  // White for libero-replaced
                                    : (wasSubstitutedOut && !showX && !hasComeBack)
                                      ? '#0f172a'  // Black bg for substituted-out (only if can still sub back)
                                      : (hasComeBack || showX ? 'rgba(255,255,255,0.02)' : 'rgba(255,255,255,0.05)'),
                              borderRadius: '4px',
                              fontSize: '14px',
                              display: 'flex',
                              alignItems: 'center',
                              gap: '4px',
                              position: 'relative',
                              border: isDropTargetForCourt ? '2px solid #ef4444' : (wasSubstitutedOut && !isSubstitutedByLibero && !showX && !hasComeBack ? '2px solid #fde047' : undefined),
                              boxShadow: isDropTargetForCourt ? '0 0 8px rgba(239, 68, 68, 0.5)' : undefined,
                              opacity: isDragging ? 0.5 : (hasComeBack || showX) ? 0.4 : 1,
                              color: isSubstitutedByLibero ? '#000' : (wasSubstitutedOut && !showX && !hasComeBack ? '#fde047' : undefined),
                              cursor: rallyStatus === 'idle' && canSubBenchPlayer ? 'grab' : (rallyStatus === 'idle' ? 'pointer' : 'default')
                            }}
                          >
                            <span style={{ fontWeight: 600 }}>{player.number}</span>
                            {player.isCaptain && (
                              <span style={{ color: isSubstitutedByLibero ? '#000' : (wasSubstitutedOut && !showX && !hasComeBack ? '#fde047' : 'var(--accent)'), fontSize: '10px', fontWeight: 700 }}>C</span>
                            )}
                            {isSubstitutedByLibero && (
                              <span style={{
                                fontSize: '9px',
                                fontWeight: 700,
                                color: '#000',
                                background: 'rgba(0, 0, 0, 0.1)',
                                padding: '1px 3px',
                                borderRadius: '2px'
                              }}>
                                {player.substitutedByLibero.liberoType === 'libero1' ? 'L1' : player.substitutedByLibero.liberoType === 'redesignated' ? 'LR' : 'L2'}
                              </span>
                            )}
                            {showX && (
                              <span
                                style={{
                                  fontSize: '9px',
                                  lineHeight: '1',
                                  background: 'rgba(15, 23, 42, 0.95)',
                                  color: '#ef4444',
                                  fontWeight: 700,
                                  padding: '1px 3px',
                                  borderRadius: '2px',
                                  display: 'flex',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  minWidth: '12px',
                                  minHeight: '12px',
                                  border: '1px solid rgba(255, 255, 255, 0.2)'
                                }}
                                title={
                                  isDisqualifiedSub || hasDisqualificationSanction
                                    ? 'Disqualified - cannot play rest of match'
                                    : isExceptionallySub
                                      ? 'Exceptionally substituted - cannot play rest of match'
                                      : isExpelledInSet || hasExpulsionSanction
                                        ? 'Expelled - cannot play this set'
                                        : 'Cannot re-enter'
                                }
                              >
                                ✕
                              </span>
                            )}
                            {hasComeBack && !showX && (
                              <span
                                style={{
                                  fontSize: '9px',
                                  lineHeight: '1',
                                  background: 'rgba(15, 23, 42, 0.95)',
                                  color: '#ef4444',
                                  fontWeight: 700,
                                  padding: '1px 3px',
                                  borderRadius: '2px',
                                  display: 'flex',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  minWidth: '12px',
                                  minHeight: '12px',
                                  border: '1px solid rgba(255, 255, 255, 0.2)'
                                }}
                              >
                                ✕
                              </span>
                            )}
                            {(waitingForPoint || canComeBack) && !hasComeBack && !showX && (
                              <span
                                style={{
                                  fontSize: '7px',
                                  lineHeight: '1',
                                  display: 'flex',
                                  flexDirection: 'row',
                                  alignItems: 'center',
                                  gap: '2px',
                                  background: 'rgba(15, 23, 42, 0.95)',
                                  padding: '1px 3px',
                                  borderRadius: '2px',
                                  minHeight: '12px',
                                  justifyContent: 'center',
                                  border: '1px solid rgba(255, 255, 255, 0.2)',
                                  opacity: waitingForPoint ? 0.5 : 1
                                }}
                              >
                                <span style={{ color: '#22c55e', fontWeight: 900 }}>↑</span>
                                <span style={{ color: '#ef4444', fontWeight: 900 }}>↓</span>
                                {playerWhoReplacedThem && (
                                  <span style={{
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    fontSize: '8px',
                                    fontWeight: 600,
                                    marginLeft: '2px'
                                  }}>
                                    {playerWhoReplacedThem}
                                  </span>
                                )}
                              </span>
                            )}
                            {sanctions.length > 0 && (
                              <span style={{
                                fontSize: '8px',
                                display: 'flex',
                                gap: '1px',
                                alignItems: 'center'
                              }}>
                                {hasExpulsion ? (
                                  <div style={{ position: 'relative', width: '9px', height: '9px' }}>
                                    <div className="sanction-card yellow" style={{
                                      width: '6px',
                                      height: '8px',
                                      position: 'absolute',
                                      left: '0',
                                      top: '0',
                                      transform: 'rotate(-8deg)',
                                      zIndex: 1
                                    }}></div>
                                    <div className="sanction-card red" style={{
                                      width: '6px',
                                      height: '8px',
                                      position: 'absolute',
                                      right: '0',
                                      top: '0',
                                      transform: 'rotate(8deg)',
                                      zIndex: 2
                                    }}></div>
                                  </div>
                                ) : (
                                  <>
                                    {(hasWarning || hasDisqualification) && (
                                      <div className="sanction-card yellow" style={{ width: '6px', height: '8px' }}></div>
                                    )}
                                    {(hasPenalty || hasDisqualification) && (
                                      <div className="sanction-card red" style={{ width: '6px', height: '8px' }}></div>
                                    )}
                                  </>
                                )}
                              </span>
                            )}
                          </div>
                        )
                      })}
                    </div>
                  )}
                </div>
              )}

              {/* Liberos */}
              {rightTeamBench.liberos.length > 0 && (
                <div style={{ marginBottom: isCompactMode ? '8px' : '16px' }}>
                  <h4
                    onClick={() => isCompactMode && setRightMainLiberosExpanded(!rightMainLiberosExpanded)}
                    style={{
                      margin: '0 0 8px',
                      fontSize: '12px',
                      fontWeight: 600,
                      color: 'var(--muted)',
                      cursor: isCompactMode ? 'pointer' : 'default',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between'
                    }}
                  >
                    <span>{t('scoreboard.roster.liberos')}</span>
                    {isCompactMode && <span style={{ fontSize: '10px' }}>{rightMainLiberosExpanded ? '▲' : '▼'}</span>}
                  </h4>
                  {(!isCompactMode || rightMainLiberosExpanded) && (
                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                      {rightTeamBench.liberos.map(player => {
                        const teamKey = leftIsHome ? 'away' : 'home'
                        const isUnable = isLiberoUnable(teamKey, player.number)
                        const liberoOnCourt = getLiberoOnCourt(teamKey)
                        const canDragLibero = rallyStatus === 'idle' && !isUnable && !liberoOnCourt && hasPointSinceLastLiberoExchange(teamKey)
                        const isDraggingLibero = draggedPlayer?.team === teamKey && draggedPlayer?.playerNumber === player.number && draggedPlayer?.type === 'bench'
                        // Can receive court player drop (libero exit/exchange if libero on court, OR libero entry if no libero on court)
                        // The handler will validate whether it's a valid operation
                        const canReceiveLiberoFromCourt = rallyStatus === 'idle' && !isUnable
                        const isLiberoDropTarget = dropTargetBench?.team === teamKey && dropTargetBench?.playerNumber === player.number && dropTargetBench?.isLibero

                        // Get sanctions for this libero (RIGHT TEAM)
                        const sanctions = getPlayerSanctions(teamKey, player.number)
                        const hasWarning = sanctions.some(s => s.payload?.type === 'warning')
                        const hasPenalty = sanctions.some(s => s.payload?.type === 'penalty')
                        const hasExpulsion = sanctions.some(s => s.payload?.type === 'expulsion')
                        const hasDisqualification = sanctions.some(s => s.payload?.type === 'disqualification')

                        return (
                          <div
                            key={`${teamKey}-bench-libero-${player.id || player.number}`}
                            style={{
                              display: 'flex',
                              alignItems: 'center',
                              gap: '4px'
                            }}
                          >
                            <div
                              draggable={canDragLibero}
                              onDragStart={(e) => canDragLibero && handleBenchDragStart(e, teamKey, player.number, true)}
                              onDragEnd={handleBenchDragEnd}
                              onDragOver={(e) => canReceiveLiberoFromCourt && handleBenchDropOver(e, teamKey, player.number, true)}
                              onDragLeave={handleBenchDropLeave}
                              onDrop={(e) => canReceiveLiberoFromCourt && handleBenchDrop(e, teamKey, player.number, true)}
                              onClick={(e) => {
                                if (rallyStatus === 'idle' && !isUnable) {
                                  // Open action menu for libero on bench
                                  const rect = e.currentTarget.getBoundingClientRect()
                                  setLiberoBenchActionMenu({
                                    team: teamKey,
                                    liberoNumber: player.number,
                                    liberoType: player.libero,
                                    element: e.currentTarget,
                                    x: rect.left + rect.width / 2,
                                    y: rect.top + rect.height / 2,
                                    side: 'right'
                                  })
                                }
                              }}
                              style={{
                                padding: '5px 10px',
                                background: isLiberoDropTarget ? 'rgba(59, 130, 246, 0.5)' : isUnable ? 'rgba(239, 68, 68, 0.2)' : 'rgba(59, 130, 246, 0.2)',
                                borderRadius: '4px',
                                fontSize: '14px',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '4px',
                                border: isLiberoDropTarget ? '2px solid #3b82f6' : `1px solid ${isUnable ? 'rgba(239, 68, 68, 0.3)' : 'rgba(59, 130, 246, 0.3)'}`,
                                boxShadow: isLiberoDropTarget ? '0 0 8px rgba(59, 130, 246, 0.5)' : undefined,
                                cursor: canDragLibero ? 'grab' : (rallyStatus === 'idle' && !isUnable) ? 'pointer' : 'default',
                                opacity: isDraggingLibero ? 0.5 : isUnable ? 0.6 : 1
                              }}
                            >
                              <span style={{ fontWeight: 600 }}>{player.number}</span>
                              <span style={{ color: isUnable ? '#f87171' : '#60a5fa', fontSize: '12px', fontWeight: 700 }}>
                                {player.libero === 'libero1' ? 'L1' : player.libero === 'redesignated' ? 'LR' : 'L2'}
                              </span>
                              {/* Captain badge for libero-captain on bench (right team) */}
                              {(player.isCaptain || player.captain) && (
                                <span style={{
                                  background: '#fff',
                                  color: '#10b981',
                                  border: '1px solid #10b981',
                                  borderRadius: '3px',
                                  padding: '0 3px',
                                  fontSize: '10px',
                                  fontWeight: 700
                                }}>C</span>
                              )}
                              {sanctions.length > 0 && (
                                <span style={{ display: 'flex', gap: '1px', alignItems: 'center' }}>
                                  {hasExpulsion ? (
                                    <div style={{ position: 'relative', width: '9px', height: '9px' }}>
                                      <div className="sanction-card yellow" style={{
                                        width: '5px',
                                        height: '7px',
                                        position: 'absolute',
                                        left: '0',
                                        top: '1px',
                                        transform: 'rotate(-8deg)',
                                        zIndex: 1,
                                        borderRadius: '1px'
                                      }}></div>
                                      <div className="sanction-card red" style={{
                                        width: '5px',
                                        height: '7px',
                                        position: 'absolute',
                                        right: '0',
                                        top: '1px',
                                        transform: 'rotate(8deg)',
                                        zIndex: 2,
                                        borderRadius: '1px'
                                      }}></div>
                                    </div>
                                  ) : (
                                    <>
                                      {(hasWarning || hasDisqualification) && (
                                        <div className="sanction-card yellow" style={{ width: '6px', height: '8px', borderRadius: '1px' }}></div>
                                      )}
                                      {(hasPenalty || hasDisqualification) && (
                                        <div className="sanction-card red" style={{ width: '6px', height: '8px', borderRadius: '1px' }}></div>
                                      )}
                                    </>
                                  )}
                                </span>
                              )}
                            </div>
                            {/* Exchange Libero button - show when another libero is on court */}
                            {liberoOnCourt &&
                              liberoOnCourt.liberoNumber !== player.number &&
                              hasPointSinceLastLiberoExchange(teamKey) &&
                              !isUnable && (
                                <button
                                  onClick={(e) => {
                                    e.stopPropagation()
                                    handleExchangeLibero('right')
                                  }}
                                  style={{
                                    padding: '4px 8px',
                                    background: '#fff',
                                    color: '#000',
                                    border: '1px solid #ccc',
                                    borderRadius: '4px',
                                    fontSize: '11px',
                                    fontWeight: 600,
                                    cursor: 'pointer',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '4px'
                                  }}
                                  title="Exchange liberos (swap L1 ↔ L2)"
                                >
                                  <span style={{ fontSize: '12px' }}>⇄</span>
                                  Exch.
                                </button>
                              )}
                          </div>
                        )
                      })}
                      {/* Redesignate Libero button - shows when all liberos are unable */}
                      {(() => {
                        const teamKey = leftIsHome ? 'away' : 'home'
                        // Get ALL liberos from player list, not just bench (bench excludes liberos on court)
                        const teamPlayers = leftIsHome ? data?.awayPlayers : data?.homePlayers
                        const allLiberos = (teamPlayers || []).filter(p => p.libero && p.libero !== '' && p.libero !== 'unable')
                        const activeLiberos = allLiberos.filter(p => !isLiberoUnable(teamKey, p.number))
                        const unableLiberos = allLiberos.filter(p => isLiberoUnable(teamKey, p.number))
                        const alreadyRedesignated = data?.events?.some(e =>
                          e.type === 'libero_redesignation' && e.payload?.team === teamKey
                        )
                        const shouldShow = activeLiberos.length === 0 && unableLiberos.length > 0 && !alreadyRedesignated && rallyStatus === 'idle'

                        if (!shouldShow) return null

                        return (
                          <button
                            onClick={() => {
                              const lastUnable = unableLiberos[unableLiberos.length - 1]
                              setLiberoRedesignationModal({
                                team: teamKey,
                                unableLiberoNumber: lastUnable.number,
                                unableLiberoType: lastUnable.libero
                              })
                            }}
                            style={{
                              padding: '6px 12px',
                              background: '#f97316',
                              color: '#000',
                              border: 'none',
                              borderRadius: '4px',
                              fontSize: '11px',
                              fontWeight: 600,
                              cursor: 'pointer',
                              display: 'flex',
                              alignItems: 'center',
                              gap: '4px'
                            }}
                          >
                            <span>🔄</span> Redesignate Libero
                          </button>
                        )
                      })()}
                    </div>
                  )}
                </div>
              )}

              {/* Bench Officials */}
              {rightTeamBench.benchOfficials.length > 0 && (
                <div>
                  <h4
                    onClick={() => isCompactMode && setRightMainOfficialsExpanded(!rightMainOfficialsExpanded)}
                    style={{
                      margin: '0 0 8px',
                      fontSize: '12px',
                      fontWeight: 600,
                      color: 'var(--muted)',
                      cursor: isCompactMode ? 'pointer' : 'default',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between'
                    }}
                  >
                    <span>{t('scoreboard.roster.benchOfficials')}</span>
                    {isCompactMode && <span style={{ fontSize: '10px' }}>{rightMainOfficialsExpanded ? '▲' : '▼'}</span>}
                  </h4>
                  {(!isCompactMode || rightMainOfficialsExpanded) && (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                      {rightTeamBench.benchOfficials.map((official, idx) => {
                        const teamKey = leftIsHome ? 'away' : 'home'

                        // Get sanctions for this official
                        const sanctions = getPlayerSanctions(teamKey, null, official.role)
                        const hasWarning = sanctions.some(s => s.payload?.type === 'warning')
                        const hasPenalty = sanctions.some(s => s.payload?.type === 'penalty')
                        const hasExpulsion = sanctions.some(s => s.payload?.type === 'expulsion')
                        const hasDisqualification = sanctions.some(s => s.payload?.type === 'disqualification')

                        return (
                          <div
                            key={idx}
                            onClick={(e) => {
                              if (rallyStatus === 'idle') {
                                const rect = e.currentTarget.getBoundingClientRect()
                                setSanctionDropdown({
                                  team: teamKey,
                                  type: 'official',
                                  role: official.role,
                                  element: e.currentTarget,
                                  x: rect.left + rect.width / 2,
                                  y: rect.top + rect.height / 2,
                                  side: 'right'
                                })
                              }
                            }}
                            style={{
                              padding: '4px 8px',
                              background: 'rgba(255,255,255,0.05)',
                              borderRadius: '4px',
                              fontSize: '11px',
                              display: 'flex',
                              alignItems: 'center',
                              gap: '6px',
                              cursor: rallyStatus === 'idle' ? 'pointer' : 'default'
                            }}
                          >
                            <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                              <span style={{ fontWeight: 600, color: 'var(--muted)', minWidth: '30px' }}>
                                {official.role === 'Coach' ? 'C' :
                                  official.role === 'Assistant Coach 1' ? 'AC1' :
                                    official.role === 'Assistant Coach 2' ? 'AC2' :
                                      official.role === 'Physiotherapist' ? 'P' :
                                        official.role === 'Medic' ? 'M' : official.role}
                              </span>
                              <span>{official.lastName || ''} {official.firstName || ''}</span>
                              {sanctions.length > 0 && (
                                <span style={{ display: 'flex', gap: '1px', alignItems: 'center' }}>
                                  {hasExpulsion ? (
                                    <div style={{ position: 'relative', width: '9px', height: '9px' }}>
                                      <div className="sanction-card yellow" style={{
                                        width: '5px',
                                        height: '7px',
                                        position: 'absolute',
                                        left: '0',
                                        top: '1px',
                                        transform: 'rotate(-8deg)',
                                        zIndex: 1,
                                        borderRadius: '1px'
                                      }}></div>
                                      <div className="sanction-card red" style={{
                                        width: '5px',
                                        height: '7px',
                                        position: 'absolute',
                                        right: '0',
                                        top: '1px',
                                        transform: 'rotate(8deg)',
                                        zIndex: 2,
                                        borderRadius: '1px'
                                      }}></div>
                                    </div>
                                  ) : (
                                    <>
                                      {(hasWarning || hasDisqualification) && (
                                        <div className="sanction-card yellow" style={{ width: '6px', height: '8px', borderRadius: '1px' }}></div>
                                      )}
                                      {(hasPenalty || hasDisqualification) && (
                                        <div className="sanction-card red" style={{ width: '6px', height: '8px', borderRadius: '1px' }}></div>
                                      )}
                                    </>
                                  )}
                                </span>
                              )}
                            </div>
                          </div>
                        )
                      })}
                    </div>
                  )}
                </div>
              )}

              {/* Set Results Table - Right Team (compact mode only) */}
              {isCompactMode && (
                <div style={{ marginTop: '12px' }}>
                  {(() => {
                    const currentRightTeamKey = leftIsHome ? 'away' : 'home'
                    const rightTeamData = currentRightTeamKey === 'home' ? data?.homeTeam : data?.awayTeam
                    const rightTeamColor = rightTeamData?.color || (currentRightTeamKey === 'home' ? '#ef4444' : '#3b82f6')
                    const rightTeamLabel = currentRightTeamKey === teamAKey ? 'A' : 'B'
                    const allSets = (data?.sets || []).sort((a, b) => a.index - b.index)
                    const currentSetIndex = data?.set?.index || 1
                    const setsByIndex = new Map()
                    allSets.forEach(set => {
                      if (set.index <= currentSetIndex) {
                        setsByIndex.set(set.index, set)
                      }
                    })
                    const visibleSets = Array.from(setsByIndex.values()).sort((a, b) => a.index - b.index)

                    return (
                      <div style={{
                        background: 'rgba(15, 23, 42, 0.6)',
                        border: '1px solid rgba(255, 255, 255, 0.08)',
                        borderRadius: '6px',
                        padding: '8px',
                        fontSize: '8px',
                        minWidth: '110px'
                      }}>
                        <h4 style={{ margin: '0 0 4px', fontSize: '9px', fontWeight: 600, textAlign: 'center' }}>
                          <span style={{
                            padding: '1px 6px',
                            borderRadius: '3px',
                            fontSize: '8px',
                            fontWeight: 700,
                            background: rightTeamColor,
                            color: isBrightColor(rightTeamColor) ? '#000' : '#fff'
                          }}>{rightTeamLabel}</span>
                        </h4>
                        <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '8px', tableLayout: 'fixed' }}>
                          <thead>
                            <tr style={{ borderBottom: '1px solid rgba(255,255,255,0.2)' }}>
                              <th style={{ padding: '2px 1px', textAlign: 'center', fontWeight: 600, fontSize: '7px', width: '20%' }}>Set</th>
                              <th style={{ padding: '2px 1px', textAlign: 'center', fontWeight: 600, fontSize: '7px', width: '20%' }}>P</th>
                              <th style={{ padding: '2px 1px', textAlign: 'center', fontWeight: 600, fontSize: '7px', width: '20%' }}>W</th>
                              <th style={{ padding: '2px 1px', textAlign: 'center', fontWeight: 600, fontSize: '7px', width: '20%' }}>S</th>
                              <th style={{ padding: '2px 1px', textAlign: 'center', fontWeight: 600, fontSize: '7px', width: '20%' }}>T</th>
                            </tr>
                          </thead>
                          <tbody>
                            {visibleSets.map(set => {
                              const rightPoints = currentRightTeamKey === 'home' ? set.homePoints : set.awayPoints
                              const leftPoints = currentRightTeamKey === 'home' ? set.awayPoints : set.homePoints
                              const won = rightPoints > leftPoints ? 1 : 0
                              const substitutions = (data?.events || []).filter(e =>
                                e.type === 'substitution' && e.setIndex === set.index && e.payload?.team === currentRightTeamKey
                              ).length
                              const timeouts = (data?.events || []).filter(e =>
                                e.type === 'timeout' && e.setIndex === set.index && e.payload?.team === currentRightTeamKey
                              ).length
                              let rowColor = 'inherit'
                              if (set.finished) {
                                rowColor = won === 1 ? '#22c55e' : '#ef4444'
                              }
                              return (
                                <tr key={set.id} style={{ borderBottom: '1px solid rgba(255,255,255,0.1)', color: rowColor }}>
                                  <td style={{ padding: '2px 1px', textAlign: 'center' }}>{set.index}</td>
                                  <td style={{ padding: '2px 1px', textAlign: 'center' }}>{rightPoints}</td>
                                  <td style={{ padding: '2px 1px', textAlign: 'center' }}>{won}</td>
                                  <td style={{ padding: '2px 1px', textAlign: 'center' }}>{substitutions}</td>
                                  <td style={{ padding: '2px 1px', textAlign: 'center' }}>{timeouts}</td>
                                </tr>
                              )
                            })}
                          </tbody>
                        </table>
                      </div>
                    )
                  })()}
                </div>
              )}
            </div>

          </ScoreboardTeamColumn>
        </div>
      )}

      {/* Menu Modal - Keep for Options submenu */}
      {menuModal && (
        <Modal
          title={t('scoreboard.menu.menu')}
          open={true}
          onClose={() => setMenuModal(false)}
          width={400}
        >
          <div style={{ padding: '20px' }}>
            <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
              <div style={{
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '8px',
                padding: '12px 16px',
                cursor: 'pointer',
                transition: 'all 0.2s'
              }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.1)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.2)'
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                }}
                onClick={() => {
                  setShowLogs(true)
                  setMenuModal(false)
                }}>
                {t('scoreboard.menu.showActionLog', 'Show Action Log')}
              </div>
              <div style={{
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '8px',
                padding: '12px 16px',
                cursor: 'pointer',
                transition: 'all 0.2s'
              }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.1)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.2)'
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                }}
                onClick={() => {
                  setShowSanctions(true)
                  setMenuModal(false)
                }}>
                {t('scoreboard.menu.showSanctionsResults', 'Show Sanctions and Results')}
              </div>
              <div style={{
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '8px',
                padding: '12px 16px',
                cursor: 'pointer',
                transition: 'all 0.2s'
              }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.1)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.2)'
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                }}
                onClick={() => {
                  setShowManualPanel(true)
                  setMenuModal(false)
                }}>
                {t('scoreboard.menu.manualChanges', 'Manual Changes')}
              </div>
              <div style={{
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '8px',
                padding: '12px 16px',
                cursor: 'pointer',
                transition: 'all 0.2s'
              }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.1)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.2)'
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                }}
                onClick={() => {
                  setShowRemarks(true)
                  setMenuModal(false)
                }}>
                {t('scoreboard.menu.openRemarksRecording', 'Open Remarks Recording')}
              </div>
              <div style={{
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '8px',
                padding: '12px 16px',
                cursor: 'pointer',
                transition: 'all 0.2s'
              }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.1)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.2)'
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                }}
                onClick={() => {
                  setShowRosters(true)
                  setMenuModal(false)
                }}>
                {t('scoreboard.showRosters')}
              </div>
              <div style={{
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '8px',
                padding: '12px 16px',
                cursor: 'pointer',
                transition: 'all 0.2s'
              }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.1)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.2)'
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                }}
                onClick={() => {
                  setShowPinsModal(true)
                  setMenuModal(false)
                }}>
                {t('scoreboard.menu.showPins', 'Show PINs')}
              </div>
              {onOpenMatchSetup && (
                <div style={{
                  background: 'rgba(255, 255, 255, 0.05)',
                  border: '1px solid rgba(255, 255, 255, 0.1)',
                  borderRadius: '8px',
                  padding: '12px 16px',
                  cursor: 'pointer',
                  transition: 'all 0.2s'
                }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.background = 'rgba(255, 255, 255, 0.1)'
                    e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.2)'
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                    e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                  }}
                  onClick={() => {
                    onOpenMatchSetup()
                    setMenuModal(false)
                  }}>
                  {t('scoreboard.menu.showMatchSetup', 'Show Match Setup')}
                </div>
              )}

              <div style={{
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '8px',
                padding: '12px 16px',
                cursor: 'pointer',
                transition: 'all 0.2s',
                marginTop: '8px',
                borderTop: '1px solid rgba(255,255,255,0.1)'
              }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.1)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.2)'
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                }}
                onClick={async () => {
                  try {
                    // Export all database data
                    const allMatches = await db.matches.toArray()
                    const allTeams = await db.teams.toArray()
                    const allPlayers = await db.players.toArray()
                    const allSets = await db.sets.toArray()
                    const allEvents = await db.events.toArray()
                    const allReferees = await db.referees.toArray()
                    const allScorers = await db.scorers.toArray()

                    const exportData = {
                      exportDate: new Date().toISOString(),
                      matchId: matchId,
                      matches: allMatches,
                      teams: allTeams,
                      players: allPlayers,
                      sets: allSets,
                      events: allEvents,
                      referees: allReferees,
                      scorers: allScorers
                    }

                    // Create a blob and download
                    const jsonString = JSON.stringify(exportData, null, 2)
                    const blob = new Blob([jsonString], { type: 'application/json' })
                    const url = URL.createObjectURL(blob)
                    const link = document.createElement('a')
                    link.href = url
                    link.download = `database_export_${matchId}_${new Date().toISOString().split('T')[0]}.json`
                    document.body.appendChild(link)
                    link.click()
                    document.body.removeChild(link)
                    URL.revokeObjectURL(url)

                    setMenuModal(false)
                  } catch (error) {
                    console.error('Error exporting database:', error)
                    showAlert(t('scoreboard.errors.exportFailed'), 'error')
                  }
                }}>
                📥 {t('scoreboard.menu.downloadGameData', 'Download Game Data (JSON)')}
              </div>
              <div style={{
                background: 'rgba(255, 255, 255, 0.05)',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                borderRadius: '8px',
                padding: '12px 16px',
                cursor: 'pointer',
                transition: 'all 0.2s',
                marginTop: '8px',
                borderTop: '1px solid rgba(255,255,255,0.1)'
              }}
                onMouseEnter={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.1)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.2)'
                }}
                onMouseLeave={(e) => {
                  e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                  e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                }}
                onClick={() => {
                  setShowOptionsInMenu(true)
                }}>
                ⚙️ {t('scoreboard.menu.options', 'Options')}
              </div>
            </div>
          </div>
        </Modal>
      )}

      {/* Show PINs Modal */}
      {showPinsModal && (
        <Modal
          title={t('scoreboard.menu.gamePins')}
          open={true}
          onClose={() => setShowPinsModal(false)}
          width={500}
        >
          <div style={{ padding: '24px' }}>
            <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
              {/* Referee PIN */}
              {data?.match?.refereePin && data?.match?.refereeConnectionEnabled === true && (
                <div style={{
                  display: 'flex',
                  gap: '16px',
                  width: '100%'
                }}>
                  <div style={{
                    background: 'rgba(255, 255, 255, 0.05)',
                    border: '1px solid rgba(255, 255, 255, 0.1)',
                    borderRadius: '8px',
                    padding: '16px',
                    flex: 1,
                    display: 'flex',
                    flexDirection: 'column',
                    justifyContent: 'space-between',
                    alignItems: 'flex-start',
                    minWidth: 0
                  }}>
                    <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '4px' }}>Referee PIN</div>
                    <div style={{ fontSize: '20px', fontWeight: 600, fontFamily: 'monospace', letterSpacing: '2px', wordBreak: 'break-all' }}>
                      {String(data.match.refereePin).padStart(6, '0')}
                    </div>
                  </div>
                </div>
              )}

              {/* Game PIN */}
              {data?.match?.gamePin && (
                <div style={{
                  display: 'flex',
                  gap: '16px',
                  width: '100%'
                }}>
                  <div style={{
                    background: 'rgba(255, 255, 255, 0.05)',
                    border: '1px solid rgba(255, 255, 255, 0.1)',
                    borderRadius: '8px',
                    padding: '16px',
                    flex: 1,
                    display: 'flex',
                    flexDirection: 'column',
                    justifyContent: 'space-between',
                    alignItems: 'flex-start',
                    minWidth: 0
                  }}>
                    <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '4px' }}>Game PIN</div>
                    <div style={{ fontSize: '20px', fontWeight: 600, fontFamily: 'monospace', letterSpacing: '2px', wordBreak: 'break-all' }}>
                      {String(data.match.gamePin).padStart(6, '0')}
                    </div>
                  </div>
                </div>
              )}

              {/* Team Bench Dashboard PINs - Same row (50/50) */}
              {((data?.match?.homeTeamPin && data?.match?.homeTeamConnectionEnabled === true) ||
                (data?.match?.awayTeamPin && data?.match?.awayTeamConnectionEnabled === true)) && (
                  <div style={{
                    display: 'flex',
                    gap: '16px',
                    width: '100%'
                  }}>
                    {data?.match?.homeTeamPin && data?.match?.homeTeamConnectionEnabled === true && (
                      <div style={{
                        background: 'rgba(255, 255, 255, 0.05)',
                        border: '1px solid rgba(255, 255, 255, 0.1)',
                        borderRadius: '8px',
                        padding: '16px',
                        flex: 1,
                        display: 'flex',
                        flexDirection: 'column',
                        justifyContent: 'space-between',
                        alignItems: 'flex-start',
                        minWidth: 0
                      }}>
                        <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '4px' }}>
                          {data?.homeTeam?.name || 'Home Team'} Bench PIN
                        </div>
                        <div style={{ fontSize: '20px', fontWeight: 600, fontFamily: 'monospace', letterSpacing: '2px', wordBreak: 'break-all' }}>
                          {String(data.match.homeTeamPin).padStart(6, '0')}
                        </div>
                      </div>
                    )}

                    {data?.match?.awayTeamPin && data?.match?.awayTeamConnectionEnabled === true && (
                      <div style={{
                        background: 'rgba(255, 255, 255, 0.05)',
                        border: '1px solid rgba(255, 255, 255, 0.1)',
                        borderRadius: '8px',
                        padding: '16px',
                        flex: 1,
                        display: 'flex',
                        flexDirection: 'column',
                        justifyContent: 'space-between',
                        alignItems: 'flex-start',
                        minWidth: 0
                      }}>
                        <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '4px' }}>
                          {data?.awayTeam?.name || 'Away Team'} Bench PIN
                        </div>
                        <div style={{ fontSize: '20px', fontWeight: 600, fontFamily: 'monospace', letterSpacing: '2px', wordBreak: 'break-all' }}>
                          {String(data.match.awayTeamPin).padStart(6, '0')}
                        </div>
                      </div>
                    )}
                  </div>
                )}
            </div>
          </div>
        </Modal>
      )}

      {/* Captain on Court Modal - Simplified */}
      {captainOnCourtModal && (
        <Modal
          title={t('scoreboard.captainOnCourt.selectTitle', 'Game Captain')}
          open={true}
          onClose={handleCancelCaptainOnCourt}
          width={360}
        >
          <div style={{ padding: '16px' }}>
            <div style={{
              display: 'grid',
              gridTemplateColumns: 'repeat(3, 1fr)',
              gap: '8px',
              marginBottom: '16px'
            }}>
              {(() => {
                const team = captainOnCourtModal.team
                const teamLineupState = getTeamLineupState(team)
                const currentLineup = teamLineupState.currentLineup || {}

                // Court position order: IV III II (front row), V VI I (back row)
                const positionOrder = ['IV', 'III', 'II', 'V', 'VI', 'I']

                return positionOrder.map((pos) => {
                  const playerNumber = currentLineup[pos]
                  if (!playerNumber) return <div key={pos} />
                  return (
                    <button
                      key={pos}
                      onClick={() => handleSelectCaptainOnCourt(playerNumber)}
                      style={{
                        padding: '12px 8px',
                        background: 'rgba(234, 179, 8, 0.15)',
                        border: '2px solid rgba(234, 179, 8, 0.5)',
                        borderRadius: '8px',
                        cursor: 'pointer',
                        fontSize: '24px',
                        fontWeight: 700,
                        color: '#eab308'
                      }}
                    >
                      {playerNumber}
                    </button>
                  )
                })
              })()}
            </div>

            <button
              onClick={handleCancelCaptainOnCourt}
              style={{
                width: '100%',
                padding: '10px',
                fontSize: '13px',
                fontWeight: 600,
                background: 'rgba(255, 255, 255, 0.1)',
                color: 'var(--muted)',
                border: '1px solid rgba(255, 255, 255, 0.2)',
                borderRadius: '6px',
                cursor: 'pointer'
              }}
            >
              {t('common.cancel', 'Cancel')}
            </button>
          </div>
        </Modal>
      )}

      {/* Options in Menu Modal */}
      <ScoreboardOptionsModal
        open={showOptionsInMenu}
        onClose={() => setShowOptionsInMenu(false)}

        onOpenKeybindings={() => {
          setShowOptionsInMenu(false)
          setKeybindingsModalOpen(true)
        }}
        onOpenConnectionSetup={() => setConnectionSetupModal(true)}
        server={{
          isAvailable: typeof window !== 'undefined' && Boolean(window.electronAPI?.server),
          serverRunning,
          serverStatus,
          serverLoading,
          onStartServer: handleStartServer,
          onStopServer: handleStopServer
        }}
        matchOptions={{
          checkAccidentalRallyStart,
          setCheckAccidentalRallyStart,
          accidentalRallyStartDuration,
          setAccidentalRallyStartDuration,
          checkAccidentalPointAward,
          setCheckAccidentalPointAward,
          accidentalPointAwardDuration,
          setAccidentalPointAwardDuration,
          manageCaptainOnCourt: localManageCaptainOnCourt,
          setManageCaptainOnCourt: setLocalManageCaptainOnCourt,
          liberoExitConfirmation,
          setLiberoExitConfirmation,
          liberoEntrySuggestion,
          setLiberoEntrySuggestion,
          setIntervalDuration,
          setSetIntervalDuration,
          scoreFont,
          setScoreFont,
          keybindingsEnabled,
          setKeybindingsEnabled
        }}
        displayOptions={{
          displayMode,
          setDisplayMode,
          detectedDisplayMode,
          enterDisplayMode,
          exitDisplayMode,
          showNamesOnCourt,
          setShowNamesOnCourt,
          autoDownloadAtSetEnd,
          setAutoDownloadAtSetEnd
        }}
        matchId={matchId}
      />

      {/* Scoreboard Guide Modal */}


      {/* Connection Setup Modal */}
      <ConnectionSetupModal
        open={connectionSetupModal}
        onClose={() => setConnectionSetupModal(false)}
        matchId={matchId}
        refereePin={data?.match?.refereePin}
        homeTeamPin={data?.match?.homeTeamPin}
        awayTeamPin={data?.match?.awayTeamPin}
        gameNumber={data?.match?.gameNumber}
      />

      {/* Help & Video Guides Modal */}
      {showHelpModal && (
        <Modal
          title={t('scoreboard.menu.helpVideoGuides')}
          open={true}
          onClose={() => {
            setShowHelpModal(false)
            setSelectedHelpTopic(null)
          }}
          width={800}
        >
          <div style={{ padding: '24px' }}>
            {!selectedHelpTopic ? (
              <div>
                <p style={{ marginBottom: '24px', fontSize: '16px', color: 'var(--muted)' }}>
                  Select a topic to view video guides and explanations:
                </p>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '12px' }}>
                  {[
                    { id: 'recording-points', title: 'Recording Points', description: 'How to record points and update the score' },
                    { id: 'timeouts', title: 'Timeouts', description: 'How to request and manage timeouts' },
                    { id: 'substitutions', title: 'Substitutions', description: 'How to make player substitutions' },
                    { id: 'libero', title: 'Libero Substitutions', description: 'How to handle libero exchanges' },
                    { id: 'sanctions', title: 'Sanctions', description: 'How to record warnings, penalties, and expulsions' },
                    { id: 'ending-set', title: 'Ending a Set', description: 'What happens when you end a set' },
                    { id: 'match-end', title: 'Match End', description: 'What happens when the match ends' },
                    { id: 'undo', title: 'Undo Actions', description: 'How to undo mistakes' },
                    { id: 'lineup', title: 'Setting Lineup', description: 'How to set initial lineup' },
                    { id: 'set-5', title: 'Set 5 (Tie-break)', description: 'Special rules for the deciding set' }
                  ].map((topic) => (
                    <div
                      key={topic.id}
                      onClick={() => setSelectedHelpTopic(topic.id)}
                      style={{
                        background: 'rgba(255, 255, 255, 0.05)',
                        border: '1px solid rgba(255, 255, 255, 0.1)',
                        borderRadius: '8px',
                        padding: '16px',
                        cursor: 'pointer',
                        transition: 'all 0.2s'
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.background = 'rgba(255, 255, 255, 0.1)'
                        e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.2)'
                        e.currentTarget.style.transform = 'translateY(-2px)'
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                        e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                        e.currentTarget.style.transform = 'translateY(0)'
                      }}
                    >
                      <div style={{ fontSize: '18px', fontWeight: 600, marginBottom: '8px' }}>
                        {topic.title}
                      </div>
                      <div style={{ fontSize: '14px', color: 'var(--muted)' }}>
                        {topic.description}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            ) : (
              <div>
                <button
                  onClick={() => setSelectedHelpTopic(null)}
                  style={{
                    marginBottom: '20px',
                    padding: '8px 16px',
                    background: 'rgba(255, 255, 255, 0.1)',
                    color: 'var(--text)',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    borderRadius: '6px',
                    cursor: 'pointer',
                    fontSize: '14px'
                  }}
                >
                  ← Back to Topics
                </button>
                {getHelpContent(selectedHelpTopic)}
              </div>
            )}
          </div>
        </Modal>
      )}

      {/* Action Log Modal */}
      {showLogs && (
        <Modal
          title={t('scoreboard.menu.actionLog')}
          open={true}
          onClose={() => setShowLogs(false)}
          width={1200}
        >
          <div style={{ padding: '20px', maxHeight: '80vh', overflowY: 'auto' }}>
            <div style={{ marginBottom: '16px' }}>
              <input
                type="text"
                placeholder="Search events..."
                value={logSearchQuery}
                onChange={(e) => setLogSearchQuery(e.target.value)}
                style={{
                  padding: '8px 12px',
                  fontSize: '14px',
                  background: 'rgba(255, 255, 255, 0.1)',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '6px',
                  color: 'var(--text)',
                  width: '100%'
                }}
              />
            </div>
            {(() => {
              if (!data?.events || data.events.length === 0) {
                return <p>No events recorded yet.</p>
              }

              // Helper function to get set number (before set 1 is set 1, between sets is the next set)
              const getSetNumber = (event) => {
                const eventSetIndex = event.setIndex || 1
                if (eventSetIndex >= 1) return eventSetIndex
                // If setIndex is 0 or undefined, check if we're before set 1
                const allSets = data.sets || []
                const firstSet = allSets.find(s => s.index === 1)
                if (!firstSet) return 1
                // Check if event is before first set start
                const eventTime = typeof event.ts === 'number' ? event.ts : new Date(event.ts).getTime()
                const firstSetStart = firstSet.startTime ? new Date(firstSet.startTime).getTime() : 0
                if (eventTime < firstSetStart) return 1
                // Between sets - find the next set
                const sortedSets = [...allSets].sort((a, b) => a.index - b.index)
                for (let i = 0; i < sortedSets.length - 1; i++) {
                  const currentSet = sortedSets[i]
                  const nextSet = sortedSets[i + 1]
                  const currentEnd = currentSet.endTime ? new Date(currentSet.endTime).getTime() : 0
                  const nextStart = nextSet.startTime ? new Date(nextSet.startTime).getTime() : Infinity
                  if (eventTime >= currentEnd && eventTime < nextStart) {
                    return nextSet.index
                  }
                }
                return eventSetIndex || 1
              }

              // Helper function to get event type for Type column
              const getEventType = (event) => {
                switch (event.type) {
                  case 'point': return 'Point'
                  case 'timeout': return 'Timeout'
                  case 'substitution': return event.payload?.isExceptional ? 'Exc. Sub' : 'Substitution'
                  case 'set_start': return 'Set Start'
                  case 'set_end': return 'Set End'
                  case 'rally_start': return 'Rally'
                  case 'replay': return 'Replay'
                  case 'decision_change': return 'Decision'
                  case 'coin_toss': return 'Coin Toss'
                  case 'lineup': return event.payload?.isInitial ? 'Lineup' : 'Lineup Chg'
                  case 'libero_entry': return 'Libero In'
                  case 'libero_exit': return 'Libero Out'
                  case 'libero_exchange': return 'Libero Exch'
                  case 'libero_unable': return 'Libero Unable'
                  case 'libero_redesignation': return 'Libero Redes'
                  case 'sanction': {
                    const sanctionType = event.payload?.sanctionType
                    if (sanctionType === 'warning') return 'Warning'
                    if (sanctionType === 'penalty') return 'Penalty'
                    if (sanctionType === 'expulsion') return 'Expulsion'
                    if (sanctionType === 'disqualification') return 'Disqualif.'
                    return 'Sanction'
                  }
                  case 'remark': return 'Remark'
                  default: return event.type || 'Unknown'
                }
              }

              // Helper function to get score at time of event
              // Set 1, 3: A:B always
              // Set 2, 4: B:A always
              // Set 5: depends on which side Team A is on (switches at 8 points)
              const getScoreAtEvent = (event) => {
                const setIdx = event.setIndex || 1
                const setEvents = data.events?.filter(e => (e.setIndex || 1) === setIdx) || []
                const eventIndex = setEvents.findIndex(e => e.id === event.id)

                let homeScore = 0
                let awayScore = 0
                // Count points up to and including this event
                for (let i = 0; i <= eventIndex; i++) {
                  const e = setEvents[i]
                  if (e.type === 'point') {
                    if (e.payload?.team === 'home') homeScore++
                    else if (e.payload?.team === 'away') awayScore++
                  }
                }

                // Get Team A (coin toss winner) key
                const coinTossTeamA = data?.match?.coinTossTeamA || 'home'
                const scoreA = coinTossTeamA === 'home' ? homeScore : awayScore
                const scoreB = coinTossTeamA === 'home' ? awayScore : homeScore

                // Determine display order based on set number
                // Set 1, 3: A:B (Team A on left)
                // Set 2, 4: B:A (Team B on left)
                // Set 5: Depends on initial side from coin toss and switches at 8 points
                if (setIdx === 1 || setIdx === 3) {
                  // A:B always
                  return `${scoreA}:${scoreB}`
                } else if (setIdx === 2 || setIdx === 4) {
                  // B:A always
                  return `${scoreB}:${scoreA}`
                } else if (setIdx === 5) {
                  // Set 5: check if we've switched sides (at 8 points)
                  const totalPoints = homeScore + awayScore
                  const hasSwitched = totalPoints >= 8

                  // In set 5, Team A starts on same side as set 1 (left), so A:B initially
                  // After switch, it becomes B:A
                  if (hasSwitched) {
                    return `${scoreB}:${scoreA}`
                  } else {
                    return `${scoreA}:${scoreB}`
                  }
                }

                // Default to A:B
                return `${scoreA}:${scoreB}`
              }

              // Helper function to get simplified action description
              const getSimplifiedAction = (event) => {
                const coinTossTeamA = data?.match?.coinTossTeamA || 'home'
                // Get team short name for the event's team
                const getTeamShortName = (teamKey) => {
                  if (!teamKey) return ''
                  if (teamKey === 'home') {
                    return data?.homeTeam?.shortName || data?.homeTeam?.name || 'Home'
                  } else {
                    return data?.awayTeam?.shortName || data?.awayTeam?.name || 'Away'
                  }
                }
                const teamShortName = event.payload?.team ? getTeamShortName(event.payload.team) : ''

                switch (event.type) {
                  case 'point': {
                    const setIdx = event.setIndex || 1
                    const setEvents = data.events?.filter(e => (e.setIndex || 1) === setIdx) || []
                    const eventIndex = setEvents.findIndex(e => e.id === event.id)
                    let homeScore = 0, awayScore = 0
                    for (let i = 0; i <= eventIndex; i++) {
                      const e = setEvents[i]
                      if (e.type === 'point') {
                        if (e.payload?.team === 'home') homeScore++
                        else if (e.payload?.team === 'away') awayScore++
                      }
                    }
                    const scoreA = coinTossTeamA === 'home' ? homeScore : awayScore
                    const scoreB = coinTossTeamA === 'home' ? awayScore : homeScore
                    return `${teamShortName} (A ${scoreA}:${scoreB} B)`
                  }
                  case 'timeout':
                    return `${teamShortName} timeout`
                  case 'substitution': {
                    const playerOut = event.payload?.playerOut || '?'
                    const playerIn = event.payload?.playerIn || '?'
                    return `${teamShortName} OUT:${playerOut} IN:${playerIn}`
                  }
                  case 'set_start':
                    return `Set ${event.setIndex || event.payload?.setIndex || '?'} started`
                  case 'set_end': {
                    const winner = event.payload?.teamLabel || '?'
                    return `Set ${event.setIndex || '?'} won by ${winner}`
                  }
                  case 'rally_start':
                    return 'Rally started'
                  case 'replay':
                    return 'Rally replayed'
                  case 'decision_change': {
                    const fromName = getTeamShortName(event.payload?.fromTeam)
                    const toName = getTeamShortName(event.payload?.toTeam)
                    return `Point ${fromName}→${toName}`
                  }
                  case 'coin_toss':
                    return `First serve: ${event.payload?.firstServe === event.payload?.teamA ? 'A' : 'B'}`
                  case 'lineup':
                    return event.payload?.isInitial ? `${teamShortName} lineup set` : `${teamShortName} lineup changed`
                  case 'libero_entry': {
                    const liberoIn = event.payload?.liberoIn || '?'
                    const playerOut = event.payload?.playerOut || '?'
                    return `${teamShortName} L${event.payload?.liberoType === 'libero2' ? '2' : '1'} #${liberoIn} in for #${playerOut}`
                  }
                  case 'libero_exit': {
                    const liberoOut = event.payload?.liberoOut || '?'
                    const playerIn = event.payload?.playerIn || '?'
                    return `${teamShortName} L${event.payload?.liberoType === 'libero2' ? '2' : '1'} #${liberoOut} out, #${playerIn} in`
                  }
                  case 'libero_exchange': {
                    const liberoOut = event.payload?.liberoOut || '?'
                    const liberoIn = event.payload?.liberoIn || '?'
                    return `${teamShortName} L1↔L2 #${liberoOut}↔#${liberoIn}`
                  }
                  case 'libero_unable': {
                    const liberoNum = event.payload?.liberoNumber || '?'
                    const reason = event.payload?.reason || 'declared'
                    return `${teamShortName} L${event.payload?.liberoType === 'libero2' ? '2' : '1'} #${liberoNum} ${reason}`
                  }
                  case 'libero_redesignation': {
                    const oldNum = event.payload?.unableLiberoNumber || '?'
                    const newNum = event.payload?.newLiberoNumber || '?'
                    return `${teamShortName} #${oldNum}→R #${newNum}`
                  }
                  case 'sanction': {
                    const sanctionType = event.payload?.sanctionType || 'sanction'
                    const playerNum = event.payload?.playerNumber
                    const role = event.payload?.role
                    const target = playerNum ? `#${playerNum}` : (role || 'team')
                    return `${teamShortName} ${sanctionType} ${target}`
                  }
                  case 'remark':
                    return event.payload?.text || 'Remark added'
                  default:
                    return event.type || 'Unknown'
                }
              }

              // Helper function to get team label
              const getTeamLabel = (event) => {
                const team = event.payload?.team
                if (team === 'home' || team === 'away') {
                  const teamKey = team === 'home' ? teamAKey : teamBKey
                  return teamKey === teamAKey ? 'A' : 'B'
                }
                if (event.type === 'set_start' || event.type === 'set_end' || event.type === 'rally_start' || event.type === 'replay') {
                  return 'GAME'
                }
                if (event.type === 'remark') {
                  return 'GAME'
                }
                if (event.type === 'sanction' && event.payload?.role) {
                  return 'REF'
                }
                return 'GAME'
              }

              // Helper function to get participant
              const getParticipant = (event) => {
                const team = event.payload?.team
                const playerNumber = event.payload?.playerNumber
                const role = event.payload?.role
                const playerType = event.payload?.playerType

                if (event.type === 'set_start' || event.type === 'set_end' || event.type === 'rally_start' || event.type === 'replay') {
                  return 'GAME'
                }

                if (event.type === 'remark') {
                  return 'GAME'
                }

                // Sanction events with role (bench official)
                if (role) {
                  if (role === 'Coach') return 'C'
                  if (role === 'Assistant Coach 1') return 'AC1'
                  if (role === 'Assistant Coach 2') return 'AC2'
                  if (role === 'Physiotherapist') return 'P'
                  if (role === 'Medic') return 'M'
                  return role
                }

                // Sanction events with player number
                if (playerNumber !== undefined && playerNumber !== null) {
                  return String(playerNumber)
                }

                // For substitution events
                if (event.type === 'substitution') {
                  const playerOut = event.payload?.playerOut
                  const playerIn = event.payload?.playerIn
                  if (playerOut !== undefined && playerOut !== null) {
                    return `OUT:${playerOut}${playerIn !== undefined && playerIn !== null ? ` IN:${playerIn}` : ''}`
                  }
                  // Fall through to team
                }

                // For libero events
                if (event.type === 'libero_entry') {
                  const liberoIn = event.payload?.liberoIn
                  const playerOut = event.payload?.playerOut
                  if (liberoIn) return `L${event.payload?.liberoType === 'libero2' ? '2' : '1'} ${liberoIn}${playerOut ? ` (for ${playerOut})` : ''}`
                }
                if (event.type === 'libero_exit') {
                  const liberoOut = event.payload?.liberoOut
                  const playerIn = event.payload?.playerIn
                  if (liberoOut) return `L${event.payload?.liberoType === 'libero2' ? '2' : '1'} ${liberoOut}${playerIn ? ` (${playerIn} in)` : ''}`
                }
                if (event.type === 'libero_substitution') {
                  const liberoOut = event.payload?.liberoOut
                  const liberoIn = event.payload?.liberoIn
                  if (liberoOut && liberoIn) {
                    return `L${event.payload?.liberoOutType === 'libero2' ? '2' : '1'} ${liberoOut} ↔ L${event.payload?.liberoInType === 'libero2' ? '2' : '1'} ${liberoIn}`
                  }
                }
                if (event.type === 'libero_unable') {
                  const liberoNumber = event.payload?.liberoNumber
                  if (liberoNumber) return `L${event.payload?.liberoType === 'libero2' ? '2' : '1'} ${liberoNumber}`
                }

                // Default to team
                if (team === 'home' || team === 'away') {
                  const teamKey = team === 'home' ? teamAKey : teamBKey
                  return teamKey === teamAKey ? 'A' : 'B'
                }

                return 'GAME'
              }

              // Sort events by seq descending (most recent first)
              const sortedEvents = [...data.events].sort((a, b) => {
                const aSeq = a.seq || 0
                const bSeq = b.seq || 0
                if (aSeq !== 0 || bSeq !== 0) {
                  return bSeq - aSeq // Descending
                }
                const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
                const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
                return bTime - aTime // Descending
              })

              // Filter events
              const filteredEvents = sortedEvents.filter(event => {
                if (logSearchQuery.trim() === '') return true
                const searchLower = logSearchQuery.toLowerCase()
                const eventType = getEventType(event) || ''
                const simplifiedAction = getSimplifiedAction(event) || ''
                const setIndex = String(getSetNumber(event))
                const teamLabel = getTeamLabel(event)
                const participant = getParticipant(event)
                return eventType.toLowerCase().includes(searchLower) ||
                  simplifiedAction.toLowerCase().includes(searchLower) ||
                  setIndex.includes(searchLower) ||
                  teamLabel.toLowerCase().includes(searchLower) ||
                  participant.toLowerCase().includes(searchLower)
              })

              return (
                <div style={{ overflowX: 'auto' }}>
                  <table style={{
                    width: '100%',
                    borderCollapse: 'collapse',
                    fontSize: '12px',
                    userSelect: 'text'
                  }}>
                    <thead>
                      <tr style={{
                        borderBottom: '2px solid rgba(255,255,255,0.2)',
                        background: 'rgba(255,255,255,0.05)'
                      }}>
                        <th style={{ padding: '10px 8px', textAlign: 'left', fontWeight: 600, whiteSpace: 'nowrap' }}>ID</th>
                        <th style={{ padding: '10px 8px', textAlign: 'left', fontWeight: 600, whiteSpace: 'nowrap' }}>Time</th>
                        <th style={{ padding: '10px 8px', textAlign: 'center', fontWeight: 600, whiteSpace: 'nowrap' }}>Team</th>
                        <th style={{ padding: '10px 8px', textAlign: 'left', fontWeight: 600, whiteSpace: 'nowrap' }}>Participant</th>
                        <th style={{ padding: '10px 8px', textAlign: 'center', fontWeight: 600, whiteSpace: 'nowrap' }}>Set</th>
                        <th style={{ padding: '10px 8px', textAlign: 'center', fontWeight: 600, whiteSpace: 'nowrap' }}>Score</th>
                        <th style={{ padding: '10px 8px', textAlign: 'left', fontWeight: 600, whiteSpace: 'nowrap' }}>Type</th>
                        <th style={{ padding: '10px 8px', textAlign: 'left', fontWeight: 600, whiteSpace: 'nowrap' }}>Action</th>
                      </tr>
                    </thead>
                    <tbody>
                      {filteredEvents.length === 0 ? (
                        <tr>
                          <td colSpan="8" style={{ padding: '20px', textAlign: 'center', color: 'var(--muted)' }}>
                            No events found
                          </td>
                        </tr>
                      ) : (
                        filteredEvents
                          .filter(event => {
                            // Filter out sub-events (decimals) - only show main actions (integers)
                            const seq = event.seq || 0
                            return seq === Math.floor(seq) // Only show if it's an integer (no decimal part)
                          })
                          .map(event => {
                            const eventType = getEventType(event)
                            const simplifiedAction = getSimplifiedAction(event)
                            if (!eventType || eventType === 'Unknown') return null

                            const actionId = Math.floor(event.seq || 0) // Show only base integer ID
                            const eventTime = typeof event.ts === 'number' ? new Date(event.ts) : new Date(event.ts)
                            const timeStr = `${String(eventTime.getUTCHours()).padStart(2, '0')}:${String(eventTime.getUTCMinutes()).padStart(2, '0')}:${String(eventTime.getUTCSeconds()).padStart(2, '0')}`
                            const setNum = getSetNumber(event)
                            const score = getScoreAtEvent(event)
                            const team = getTeamLabel(event)
                            const participant = getParticipant(event)

                            return (
                              <tr
                                key={event.id}
                                style={{
                                  borderBottom: '1px solid rgba(255,255,255,0.1)',
                                  transition: 'background 0.2s'
                                }}
                                onMouseEnter={(e) => {
                                  e.currentTarget.style.background = 'rgba(255,255,255,0.05)'
                                }}
                                onMouseLeave={(e) => {
                                  e.currentTarget.style.background = 'transparent'
                                }}
                              >
                                <td style={{ padding: '8px', fontFamily: 'monospace', fontSize: '11px', whiteSpace: 'nowrap' }}>
                                  {actionId}
                                </td>
                                <td style={{ padding: '8px', whiteSpace: 'nowrap' }}>
                                  {timeStr}
                                </td>
                                <td style={{ padding: '8px', textAlign: 'center', fontWeight: 600, whiteSpace: 'nowrap' }}>
                                  {team}
                                </td>
                                <td style={{ padding: '8px', whiteSpace: 'nowrap' }}>
                                  {participant}
                                </td>
                                <td style={{ padding: '8px', textAlign: 'center', whiteSpace: 'nowrap' }}>
                                  {setNum}
                                </td>
                                <td style={{ padding: '8px', textAlign: 'center', fontFamily: 'monospace', whiteSpace: 'nowrap' }}>
                                  {score}
                                </td>
                                <td style={{ padding: '8px', fontWeight: 500, whiteSpace: 'nowrap' }}>
                                  {eventType}
                                </td>
                                <td style={{ padding: '8px', whiteSpace: 'nowrap' }}>
                                  {simplifiedAction}
                                </td>
                              </tr>
                            )
                          })
                      )}
                    </tbody>
                  </table>
                </div>
              )
            })()}
          </div>
        </Modal>
      )}

      {/* Manual Changes Modal */}
      {showManualPanel && (
        <Modal
          title={t('scoreboard.menu.manualChanges')}
          open={true}
          onClose={() => setShowManualPanel(false)}
          width={650}
        >
          <div style={{ padding: '16px', maxHeight: '80vh', overflowY: 'auto' }}>
            {/* Collapsible Section: Current Set */}
            <div style={{
              marginBottom: '12px',
              background: 'rgba(255,255,255,0.03)',
              borderRadius: '12px',
              border: '1px solid rgba(255,255,255,0.08)',
              overflow: 'hidden'
            }}>
              <button
                onClick={() => setManualPanelExpandedSections(prev => ({ ...prev, currentSet: !prev.currentSet }))}
                style={{
                  width: '100%',
                  padding: '14px 16px',
                  background: 'transparent',
                  border: 'none',
                  color: 'var(--text)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  cursor: 'pointer',
                  fontSize: '15px',
                  fontWeight: 600
                }}
              >
                <span style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                  <span style={{ fontSize: '18px' }}>⚡</span>
                  Current Set
                </span>
                <span style={{ fontSize: '12px', transform: manualPanelExpandedSections.currentSet ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
              </button>
              {manualPanelExpandedSections.currentSet && (
                <div style={{ padding: '0 16px 16px 16px' }}>
                  {data?.match && (() => {
                    // Calculate which team is on which side based on set index and overrides
                    const currentSetIndex = data.set?.index || 1
                    const setLeftTeamOverrides = data.match?.setLeftTeamOverrides || {}
                    const is5thSet = currentSetIndex === 5
                    const set5LeftTeam = data.match?.set5LeftTeam

                    let sideA // 'left' or 'right' for Team A
                    if (setLeftTeamOverrides[currentSetIndex] !== undefined) {
                      // Override stores 'A' or 'B' (not 'home'/'away')
                      sideA = setLeftTeamOverrides[currentSetIndex] === 'A' ? 'left' : 'right'
                    } else if (is5thSet && set5LeftTeam) {
                      // set5LeftTeam stores 'A' or 'B'
                      sideA = set5LeftTeam === 'A' ? 'left' : 'right'
                    } else {
                      // Default alternating pattern: odd sets = A on left, even sets = A on right
                      sideA = currentSetIndex % 2 === 1 ? 'left' : 'right'
                    }

                    // If Team A is on left, and Team A is home, then home is on left
                    const leftIsHome = sideA === 'left' ? (teamAKey === 'home') : (teamAKey !== 'home')
                    const rightIsHome = !leftIsHome

                    // Determine current serving team
                    const servingTeam = data.match.firstServe || 'home'
                    const leftTeamKey = leftIsHome ? 'home' : 'away'
                    const rightTeamKey = leftIsHome ? 'away' : 'home'
                    const leftTeamName = leftIsHome ? (data.homeTeam?.shortName || data.homeTeam?.name || 'Home') : (data.awayTeam?.shortName || data.awayTeam?.name || 'Away')
                    const rightTeamName = leftIsHome ? (data.awayTeam?.shortName || data.awayTeam?.name || 'Away') : (data.homeTeam?.shortName || data.homeTeam?.name || 'Home')
                    const leftTeamColor = leftIsHome ? (data.homeTeam?.color || '#3b82f6') : (data.awayTeam?.color || '#ef4444')
                    const rightTeamColor = leftIsHome ? (data.awayTeam?.color || '#ef4444') : (data.homeTeam?.color || '#3b82f6')
                    const leftIsServing = servingTeam === leftTeamKey
                    const rightIsServing = servingTeam === rightTeamKey

                    return (
                      <>
                        <div
                          className="manual-item"
                          style={{
                            display: 'flex',
                            flexDirection: 'column',
                            gap: '12px',
                            paddingBottom: '16px',
                            borderBottom: '1px solid rgba(255,255,255,0.08)'
                          }}
                        >
                          <div style={{ fontWeight: 600, marginBottom: '4px' }}>Teams Setup</div>
                          <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '8px' }}>
                            Current court positions and serving team
                          </div>

                          {/* Visual Court Representation */}
                          <div style={{
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: '8px',
                            padding: '16px',
                            background: 'rgba(255,255,255,0.03)',
                            borderRadius: '12px',
                            border: '1px solid rgba(255,255,255,0.08)'
                          }}>
                            {/* Left Team */}
                            <div style={{
                              flex: 1,
                              display: 'flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              gap: '8px',
                              padding: '12px',
                              background: leftTeamColor,
                              borderRadius: '8px',
                              color: isBrightColor(leftTeamColor) ? '#000' : '#fff'
                            }}>
                              {leftIsServing && <span style={{ fontSize: '20px' }}>🏐</span>}
                              <div style={{ textAlign: 'center' }}>
                                <div style={{ fontWeight: 700, fontSize: '14px' }}>{leftTeamName}</div>
                                <div style={{ fontSize: '10px', opacity: 0.8 }}>{leftIsHome ? 'HOME' : 'AWAY'}</div>
                              </div>
                            </div>

                            {/* Net divider */}
                            <div style={{
                              width: '4px',
                              height: '60px',
                              background: 'rgba(255,255,255,0.3)',
                              borderRadius: '2px'
                            }} />

                            {/* Right Team */}
                            <div style={{
                              flex: 1,
                              display: 'flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              gap: '8px',
                              padding: '12px',
                              background: rightTeamColor,
                              borderRadius: '8px',
                              color: isBrightColor(rightTeamColor) ? '#000' : '#fff'
                            }}>
                              <div style={{ textAlign: 'center' }}>
                                <div style={{ fontWeight: 700, fontSize: '14px' }}>{rightTeamName}</div>
                                <div style={{ fontSize: '10px', opacity: 0.8 }}>{rightIsHome ? 'HOME' : 'AWAY'}</div>
                              </div>
                              {rightIsServing && <span style={{ fontSize: '20px' }}>🏐</span>}
                            </div>
                          </div>

                          {/* Action Buttons */}
                          <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                            <button
                              className="secondary"
                              onClick={async () => {
                                // For sets 1-4, update the override for current set
                                const setIdx = data.set?.index || 1

                                // Helper to convert A/B to Home/Away for logging
                                const getTeamLabel = (ab) => ab === 'A' ? (teamAKey === 'home' ? 'Home' : 'Away') : (teamAKey === 'home' ? 'Away' : 'Home')

                                console.log('[SwitchSides] Current state:', {
                                  setIdx,
                                  teamAKey,
                                  leftIsHome,
                                  rightIsHome,
                                  servingTeam,
                                  leftTeamName,
                                  rightTeamName,
                                  currentOverrides: data.match?.setLeftTeamOverrides,
                                  set5LeftTeam: data.match?.set5LeftTeam
                                })

                                if (setIdx === 5) {
                                  const automatic5 = teamAKey === 'home' ? 'A' : 'B'
                                  const currentLeftTeam = data.match.set5LeftTeam || automatic5
                                  const newLeftTeam = currentLeftTeam === 'A' ? 'B' : 'A'
                                  const oldLeft = getTeamLabel(currentLeftTeam)
                                  const newLeft = getTeamLabel(newLeftTeam)
                                  console.log('[SwitchSides] Set 5:', { automatic5, currentLeftTeam, newLeftTeam, oldLeft, newLeft })
                                  await db.matches.update(matchId, { set5LeftTeam: newLeftTeam })
                                  // Sync to Supabase
                                  if (data.match?.seed_key) {
                                    db.sync_queue.add({
                                      resource: 'match',
                                      action: 'update',
                                      payload: { id: data.match.seed_key, set5LeftTeam: newLeftTeam },
                                      createdAt: new Date().toISOString()
                                    })
                                  }
                                  logManualChange('Teams Setup', 'Court Sides', `${oldLeft} on left`, `${newLeft} on left`, `Switched court sides (Set 5)`)
                                  // Sync updated side to Supabase live state
                                  syncLiveStateToSupabase('manual_side_change', null, { oldSide: oldLeft, newSide: newLeft })
                                } else {
                                  // Sets 1-4: Swap coinTossTeamA (A ALWAYS on left in Set 1)
                                  // Swapping which team is "A" effectively swaps the teams on court
                                  const currentTeamA = data.match.coinTossTeamA || 'home'
                                  const newTeamA = currentTeamA === 'home' ? 'away' : 'home'
                                  const newTeamB = newTeamA === 'home' ? 'away' : 'home'
                                  const oldLeft = leftIsHome ? 'Home' : 'Away'
                                  const newLeft = leftIsHome ? 'Away' : 'Home'
                                  console.log('[SwitchSides] Sets 1-4:', { currentTeamA, newTeamA, oldLeft, newLeft, setIdx })

                                  // Update local IndexedDB
                                  await db.matches.update(matchId, { coinTossTeamA: newTeamA })

                                  // Sync coin_toss JSONB to Supabase
                                  if (data.match?.seed_key) {
                                    const currentServeA = data.match.coinTossServeA ?? true
                                    const firstServeTeam = currentServeA ? newTeamA : newTeamB
                                    await db.sync_queue.add({
                                      resource: 'match',
                                      action: 'update',
                                      payload: {
                                        id: data.match.seed_key,
                                        coin_toss: {
                                          team_a: newTeamA,
                                          team_b: newTeamB,
                                          serve_a: currentServeA,
                                          confirmed: true,
                                          first_serve: firstServeTeam
                                        }
                                      },
                                      createdAt: new Date().toISOString()
                                    })
                                    console.log('[SwitchSides] Queued coin_toss sync:', { newTeamA, newTeamB, firstServeTeam })
                                  }

                                  logManualChange('Teams Setup', 'Court Sides', `${oldLeft} on left`, `${newLeft} on left`, `Switched court sides (Set ${setIdx})`)
                                  // Sync updated side to Supabase live state
                                  syncLiveStateToSupabase('manual_side_change', null, { oldSide: oldLeft, newSide: newLeft })
                                }
                              }}
                              style={{
                                flex: 1,
                                padding: '10px 16px',
                                fontSize: '13px',
                                borderRadius: '8px',
                                fontWeight: 600
                              }}
                            >
                              ↔️ Switch Sides
                            </button>
                            <button
                              className="secondary"
                              onClick={async () => {
                                const oldServing = servingTeam === 'home' ? 'Home' : 'Away'
                                const newServe = servingTeam === 'home' ? 'away' : 'home'
                                const newServing = newServe === 'home' ? 'Home' : 'Away'

                                if (data.set?.index === 5) {
                                  const currentSet5Serve = data.match.set5FirstServe || 'A'
                                  const newSet5Serve = currentSet5Serve === 'A' ? 'B' : 'A'
                                  await db.matches.update(matchId, { set5FirstServe: newSet5Serve })
                                  // Sync to Supabase
                                  if (data.match?.seed_key) {
                                    db.sync_queue.add({
                                      resource: 'match',
                                      action: 'update',
                                      payload: { id: data.match.seed_key, set5FirstServe: newSet5Serve },
                                      createdAt: new Date().toISOString()
                                    })
                                  }
                                } else {
                                  const coinTossTeamA = data.match.coinTossTeamA || 'home'
                                  const coinTossTeamB = coinTossTeamA === 'home' ? 'away' : 'home'
                                  const coinTossServeA = newServe === coinTossTeamA
                                  await db.matches.update(matchId, { firstServe: newServe, coinTossServeA })

                                  // Sync coin_toss JSONB to Supabase
                                  if (data.match?.seed_key) {
                                    await db.sync_queue.add({
                                      resource: 'match',
                                      action: 'update',
                                      payload: {
                                        id: data.match.seed_key,
                                        coin_toss: {
                                          team_a: coinTossTeamA,
                                          team_b: coinTossTeamB,
                                          serve_a: coinTossServeA,
                                          confirmed: true,
                                          first_serve: newServe
                                        }
                                      },
                                      createdAt: new Date().toISOString()
                                    })
                                    console.log('[SwitchServe] Queued coin_toss sync:', { coinTossTeamA, coinTossServeA, firstServe: newServe })
                                  }
                                }
                                logManualChange('Teams Setup', 'First Serve', oldServing, newServing, `Changed first serve from ${oldServing} to ${newServing}`)
                                // Sync updated serve to Supabase live state
                                syncLiveStateToSupabase('manual_serve_change', null, { oldServe: oldServing, newServe: newServing })
                              }}
                              style={{
                                flex: 1,
                                padding: '10px 16px',
                                fontSize: '13px',
                                borderRadius: '8px',
                                fontWeight: 600
                              }}
                            >
                              🏐 Switch Serve
                            </button>
                          </div>
                        </div>

                        {/* Edit Lineup */}
                        <div
                          className="manual-item"
                          style={{
                            display: 'flex',
                            flexDirection: 'column',
                            gap: '8px',
                            paddingTop: '16px',
                            borderTop: '1px solid rgba(255,255,255,0.08)'
                          }}
                        >
                          <div style={{ fontWeight: 600, marginBottom: '8px' }}>{t('scoreboard.edit.changeCurrentLineup')}</div>
                          <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                            {t('scoreboard.edit.overrideLineupDesc')}
                          </div>
                          <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                            {/* LEFT BUTTON */}
                            <button
                              className="secondary"
                              disabled={!data?.set}
                              onClick={() => openManualLineup(leftTeamKey)}
                              style={{
                                flex: 1,
                                minWidth: '120px',
                                padding: '12px 16px',
                                background: leftTeamColor,
                                color: isBrightColor(leftTeamColor) ? '#000' : '#fff',
                                borderRadius: '8px',
                                fontWeight: 600
                              }}
                            >
                              {t('scoreboard.edit.editTeamLeft', { team: leftTeamKey === teamAKey ? 'A' : 'B' })}
                            </button>
                            {/* RIGHT BUTTON */}
                            <button
                              className="secondary"
                              disabled={!data?.set}
                              onClick={() => openManualLineup(rightTeamKey)}
                              style={{
                                flex: 1,
                                minWidth: '120px',
                                padding: '12px 16px',
                                background: rightTeamColor,
                                color: isBrightColor(rightTeamColor) ? '#000' : '#fff',
                                borderRadius: '8px',
                                fontWeight: 600
                              }}
                            >
                              {t('scoreboard.edit.editTeamRight', { team: rightTeamKey === teamAKey ? 'A' : 'B' })}
                            </button>
                          </div>
                        </div>

                        {/* Edit Current Set Score */}
                        {data?.set && (
                          <div
                            className="manual-item"
                            style={{
                              display: 'flex',
                              flexDirection: 'column',
                              gap: '8px',
                              paddingTop: '16px',
                              borderTop: '1px solid rgba(255,255,255,0.08)'
                            }}
                          >
                            <div style={{ fontWeight: 600, marginBottom: '8px' }}>{t('scoreboard.edit.editCurrentSetScore')}</div>
                            <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                              {t('scoreboard.edit.editCurrentSetScoreDesc')}
                            </div>
                            <div style={{ display: 'flex', gap: '16px', alignItems: 'center', flexWrap: 'wrap' }}>
                              {/* LEFT TEAM Score */}
                              <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                <label style={{ fontSize: '12px', minWidth: '60px' }}>
                                  {leftIsHome ? t('common.home') : t('common.away')}:
                                </label>
                                <input
                                  type="number"
                                  min="0"
                                  max="99"
                                  value={(leftIsHome ? data.set.homePoints : data.set.awayPoints) || 0}
                                  onChange={async (e) => {
                                    const newPoints = Math.max(0, Math.min(99, parseInt(e.target.value) || 0))
                                    const update = leftIsHome ? { homePoints: newPoints } : { awayPoints: newPoints }
                                    await db.sets.update(data.set.id, update)

                                    // Sync to Supabase
                                    if (supabase && data.match?.seed_key) {
                                      try {
                                        const sbUpdate = leftIsHome ? { home_points: newPoints } : { away_points: newPoints }
                                        await supabase.from('sets').update(sbUpdate).eq('external_id', String(data.set.id))
                                      } catch (err) { /* ignore */ }
                                    }

                                    // Update Live State immediately
                                    syncLiveStateToSupabase('manual_score_update')
                                  }}
                                  style={{
                                    width: '60px',
                                    padding: '6px 8px',
                                    fontSize: '14px',
                                    background: 'var(--bg-secondary)',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)'
                                  }}
                                />
                              </div>
                              {/* RIGHT TEAM Score */}
                              <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                <label style={{ fontSize: '12px', minWidth: '60px' }}>
                                  {rightIsHome ? t('common.home') : t('common.away')}:
                                </label>
                                <input
                                  type="number"
                                  min="0"
                                  max="99"
                                  value={(rightIsHome ? data.set.homePoints : data.set.awayPoints) || 0}
                                  onChange={async (e) => {
                                    const newPoints = Math.max(0, Math.min(99, parseInt(e.target.value) || 0))
                                    const update = rightIsHome ? { homePoints: newPoints } : { awayPoints: newPoints }
                                    await db.sets.update(data.set.id, update)

                                    // Sync to Supabase
                                    if (supabase && data.match?.seed_key) {
                                      try {
                                        const sbUpdate = rightIsHome ? { home_points: newPoints } : { away_points: newPoints }
                                        await supabase.from('sets').update(sbUpdate).eq('external_id', String(data.set.id))
                                      } catch (err) { /* ignore */ }
                                    }

                                    // Update Live State immediately
                                    syncLiveStateToSupabase('manual_score_update')
                                  }}
                                  style={{
                                    width: '60px',
                                    padding: '6px 8px',
                                    fontSize: '14px',
                                    background: 'var(--bg-secondary)',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)'
                                  }}
                                />
                              </div>
                            </div>
                          </div>
                        )}
                      </>
                    )
                  })()}
                </div>
              )}
            </div>

            {/* Collapsible Section: Score & Sets */}
            <div style={{
              marginBottom: '12px',
              background: 'rgba(255,255,255,0.03)',
              borderRadius: '12px',
              border: '1px solid rgba(255,255,255,0.08)',
              overflow: 'hidden'
            }}>
              <button
                onClick={() => setManualPanelExpandedSections(prev => ({ ...prev, scores: !prev.scores }))}
                style={{
                  width: '100%',
                  padding: '14px 16px',
                  background: 'transparent',
                  border: 'none',
                  color: 'var(--text)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  cursor: 'pointer',
                  fontSize: '15px',
                  fontWeight: 600
                }}
              >
                <span style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                  <span style={{ fontSize: '18px' }}>📊</span>
                  Score &amp; Sets
                </span>
                <span style={{ fontSize: '12px', transform: manualPanelExpandedSections.scores ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
              </button>
              {manualPanelExpandedSections.scores && (
                <div style={{ padding: '0 16px 16px 16px' }}>
                  <div className="manual-list">

                    {/* Reopen completed sets */}
                    {data?.sets && (() => {
                      // Filter out the current set - only show finished sets that are not the current set
                      const currentSetIndex = data?.set?.index
                      const completedSets = data.sets
                        .filter(s => s.finished && s.index !== currentSetIndex)
                        .sort((a, b) => b.index - a.index)
                      if (completedSets.length === 0) return null

                      return (
                        <div
                          className="manual-item"
                          style={{
                            display: 'flex',
                            flexDirection: 'column',
                            gap: '8px',
                            paddingTop: '16px'
                          }}
                        >
                          <div style={{ fontWeight: 600, marginBottom: '8px' }}>{t('scoreboard.edit.reopenCompletedSets')}</div>
                          <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                            {t('scoreboard.edit.reopenCompletedSetsDesc')}
                          </div>
                          <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                            {completedSets.map(set => (
                              <button
                                key={set.id}
                                className="secondary"
                                onClick={() => setReopenSetConfirm({ setId: set.id, setIndex: set.index })}
                                style={{ textAlign: 'left', padding: '10px 16px' }}
                              >
                                {t('scoreboard.edit.reopenSetWithScore', { setIndex: set.index, homePoints: set.homePoints, awayPoints: set.awayPoints })}
                              </button>
                            ))}
                          </div>
                        </div>
                      )
                    })()}



                    {/* Edit All Sets */}
                    {data?.sets && data.sets.length > 0 && (
                      <div
                        className="manual-item"
                        style={{
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '8px',
                          paddingTop: '16px',
                          borderTop: '1px solid rgba(255,255,255,0.08)'
                        }}
                      >
                        <div style={{ fontWeight: 600, marginBottom: '8px' }}>{t('scoreboard.edit.editAllSets')}</div>
                        <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                          {t('scoreboard.edit.editAllSetsDesc')}
                        </div>
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                          {data.sets.sort((a, b) => a.index - b.index).map(set => (
                            <div key={set.id} style={{
                              display: 'flex',
                              alignItems: 'center',
                              gap: '12px',
                              padding: '8px',
                              background: 'rgba(255,255,255,0.03)',
                              borderRadius: '6px'
                            }}>
                              <div style={{ fontWeight: 600, minWidth: '60px' }}>{t('scoreboard.edit.setNumber', { number: set.index })}</div>
                              <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                <label style={{ fontSize: '11px' }}>{t('common.home')}:</label>
                                <input
                                  type="number"
                                  min="0"
                                  max="99"
                                  value={set.homePoints || 0}
                                  onChange={async (e) => {
                                    const newPoints = Math.max(0, Math.min(99, parseInt(e.target.value) || 0))
                                    await db.sets.update(set.id, { homePoints: newPoints })
                                    // Sync to Supabase
                                    if (supabase && data.match?.seed_key) {
                                      try {
                                        await supabase.from('sets').update({ home_points: newPoints }).eq('external_id', String(set.id))
                                      } catch (err) { /* ignore */ }
                                    }
                                  }}
                                  style={{
                                    width: '50px',
                                    padding: '4px 6px',
                                    fontSize: '12px',
                                    background: 'var(--bg-secondary)',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)'
                                  }}
                                />
                              </div>
                              <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                <label style={{ fontSize: '11px' }}>{t('common.away')}:</label>
                                <input
                                  type="number"
                                  min="0"
                                  max="99"
                                  value={set.awayPoints || 0}
                                  onChange={async (e) => {
                                    const newPoints = Math.max(0, Math.min(99, parseInt(e.target.value) || 0))
                                    await db.sets.update(set.id, { awayPoints: newPoints })
                                    // Sync to Supabase
                                    if (supabase && data.match?.seed_key) {
                                      try {
                                        await supabase.from('sets').update({ away_points: newPoints }).eq('external_id', String(set.id))
                                      } catch (err) { /* ignore */ }
                                    }
                                  }}
                                  style={{
                                    width: '50px',
                                    padding: '4px 6px',
                                    fontSize: '12px',
                                    background: 'var(--bg-secondary)',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)'
                                  }}
                                />
                              </div>
                              <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginLeft: 'auto' }}>
                                <label style={{ fontSize: '11px' }}>{t('scoreboard.edit.finished')}</label>
                                <input
                                  type="checkbox"
                                  checked={set.finished || false}
                                  onChange={async (e) => {
                                    await db.sets.update(set.id, { finished: e.target.checked })
                                    // Sync to Supabase
                                    if (supabase && data.match?.seed_key) {
                                      try {
                                        await supabase.from('sets').update({ finished: e.target.checked }).eq('external_id', String(set.id))
                                      } catch (err) { /* ignore */ }
                                    }
                                  }}
                                  style={{
                                    width: '18px',
                                    height: '18px',
                                    cursor: 'pointer'
                                  }}
                                />
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                </div>
              )}
            </div>

            {/* Collapsible Section: Match Settings */}
            <div style={{
              marginBottom: '12px',
              background: 'rgba(255,255,255,0.03)',
              borderRadius: '12px',
              border: '1px solid rgba(255,255,255,0.08)',
              overflow: 'hidden'
            }}>
              <button
                onClick={() => setManualPanelExpandedSections(prev => ({ ...prev, matchSettings: !prev.matchSettings }))}
                style={{
                  width: '100%',
                  padding: '14px 16px',
                  background: 'transparent',
                  border: 'none',
                  color: 'var(--text)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  cursor: 'pointer',
                  fontSize: '15px',
                  fontWeight: 600
                }}
              >
                <span style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                  <span style={{ fontSize: '18px' }}>⚙️</span>
                  Match Settings
                </span>
                <span style={{ fontSize: '12px', transform: manualPanelExpandedSections.matchSettings ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
              </button>
              {manualPanelExpandedSections.matchSettings && (
                <div style={{ padding: '0 16px 16px 16px' }}>



                  {/* Edit Match Information */}
                  {data?.match && (
                    <div
                      className="manual-item"
                      style={{
                        display: 'flex',
                        flexDirection: 'column',
                        gap: '8px',
                        paddingTop: '16px',
                        borderTop: '1px solid rgba(255,255,255,0.08)'
                      }}
                    >
                      <div style={{ fontWeight: 600, marginBottom: '8px' }}>{t('scoreboard.edit.editMatchInfo')}</div>
                      <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                        {t('scoreboard.edit.editMatchInfoDesc')}
                      </div>
                      <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                          <label style={{ fontSize: '12px', minWidth: '120px' }}>{t('scoreboard.edit.matchStatus')}</label>
                          <select
                            value={data.match.status || 'live'}
                            onChange={async (e) => {
                              const newStatus = e.target.value
                              // Update local IndexedDB
                              await db.matches.update(matchId, { status: newStatus })

                              // Also sync to Supabase if match has seed_key
                              if (supabase && data.match?.seed_key) {
                                try {
                                  await supabase
                                    .from('matches')
                                    .update({ status: newStatus })
                                    .eq('external_id', data.match.seed_key)
                                } catch (err) {
                                  // Failed to sync status to Supabase
                                }
                              }
                            }}
                            style={{
                              flex: 1,
                              padding: '6px 8px',
                              fontSize: '12px',
                              background: '#1e293b',
                              border: '1px solid rgba(255,255,255,0.2)',
                              borderRadius: '4px',
                              color: 'var(--text)'
                            }}
                          >
                            <option value="setup" style={{ background: '#1e293b', color: 'var(--text)' }}>{t('scoreboard.edit.setup')}</option>
                            <option value="live" style={{ background: '#1e293b', color: 'var(--text)' }}>{t('scoreboard.edit.live')}</option>
                            <option value="final" style={{ background: '#1e293b', color: 'var(--text)' }}>{t('scoreboard.edit.final')}</option>
                            <option value="paused" style={{ background: '#1e293b', color: 'var(--text)' }}>{t('scoreboard.edit.paused')}</option>
                          </select>
                        </div>
                        {data?.set?.index === 5 && (
                          <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                            <label style={{ fontSize: '12px', minWidth: '120px' }}>{t('scoreboard.edit.set5FirstServe')}</label>
                            <select
                              value={data.match.set5FirstServe || 'A'}
                              onChange={async (e) => {
                                await db.matches.update(matchId, { set5FirstServe: e.target.value })
                              }}
                              style={{
                                flex: 1,
                                padding: '6px 8px',
                                fontSize: '12px',
                                background: '#1e293b',
                                border: '1px solid rgba(255,255,255,0.2)',
                                borderRadius: '4px',
                                color: 'var(--text)'
                              }}
                            >
                              <option value="A" style={{ background: '#1e293b', color: 'var(--text)' }}>{t('scoreboard.edit.teamA')}</option>
                              <option value="B" style={{ background: '#1e293b', color: 'var(--text)' }}>{t('scoreboard.edit.teamB')}</option>
                            </select>
                          </div>
                        )}
                      </div>
                    </div>
                  )}


                </div>
              )}
            </div>

            {/* Collapsible Section: Event History */}
            <div style={{
              marginBottom: '12px',
              background: 'rgba(255,255,255,0.03)',
              borderRadius: '12px',
              border: '1px solid rgba(255,255,255,0.08)',
              overflow: 'hidden'
            }}>
              <button
                onClick={() => setManualPanelExpandedSections(prev => ({ ...prev, events: !prev.events }))}
                style={{
                  width: '100%',
                  padding: '14px 16px',
                  background: 'transparent',
                  border: 'none',
                  color: 'var(--text)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  cursor: 'pointer',
                  fontSize: '15px',
                  fontWeight: 600
                }}
              >
                <span style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                  <span style={{ fontSize: '18px' }}>📝</span>
                  Event History
                </span>
                <span style={{ fontSize: '12px', transform: manualPanelExpandedSections.events ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
              </button>
              {manualPanelExpandedSections.events && (
                <div style={{ padding: '0 16px 16px 16px' }}>

                  {/* Edit Points */}
                  {data?.events && (() => {
                    const pointEvents = data.events.filter(e => e.type === 'point').sort((a, b) => (b.seq || 0) - (a.seq || 0)).slice(0, 20)
                    if (pointEvents.length === 0) return null

                    return (
                      <div
                        className="manual-item"
                        style={{
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '8px',
                          paddingBottom: '16px',
                          borderBottom: '1px solid rgba(255,255,255,0.08)'
                        }}
                      >
                        <div style={{ fontWeight: 600, marginBottom: '8px' }}>Edit Points ({pointEvents.length} most recent)</div>
                        <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                          Edit or delete point events. Score shown is at time of point.
                        </div>
                        <div style={{
                          maxHeight: '300px',
                          overflowY: 'auto',
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '6px'
                        }}>
                          {pointEvents.map(event => {
                            const setIndex = event.setIndex || 1
                            const team = event.payload?.team
                            const teamLabel = team === teamAKey ? 'A' : (team === teamBKey ? 'B' : '')

                            // Calculate score at time of this point
                            const setEvents = data.events.filter(e => e.setIndex === setIndex)
                            const eventIndex = setEvents.findIndex(e => e.id === event.id)
                            let homeScore = 0
                            let awayScore = 0
                            for (let i = 0; i <= eventIndex; i++) {
                              const e = setEvents[i]
                              if (e.type === 'point') {
                                if (e.payload?.team === 'home') homeScore++
                                else if (e.payload?.team === 'away') awayScore++
                              }
                            }

                            return (
                              <div key={event.id} style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: '8px',
                                padding: '8px',
                                background: 'rgba(255,255,255,0.03)',
                                borderRadius: '4px',
                                fontSize: '11px'
                              }}>
                                <span style={{ minWidth: '60px' }}>Set {setIndex}</span>
                                <select
                                  value={team || 'home'}
                                  onChange={async (e) => {
                                    await db.events.update(event.id, {
                                      payload: { ...event.payload, team: e.target.value }
                                    })
                                  }}
                                  style={{
                                    padding: '4px 6px',
                                    fontSize: '11px',
                                    background: '#1e293b',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)',
                                    minWidth: '80px'
                                  }}
                                >
                                  <option value="home" style={{ background: '#1e293b', color: 'var(--text)' }}>Home</option>
                                  <option value="away" style={{ background: '#1e293b', color: 'var(--text)' }}>Away</option>
                                </select>
                                <span style={{ minWidth: '50px' }}>Score: {homeScore}-{awayScore}</span>
                                <button
                                  className="danger"
                                  onClick={async () => {
                                    if (confirm(`Delete this point event?`)) {
                                      await db.events.delete(event.id)
                                    }
                                  }}
                                  style={{
                                    padding: '4px 8px',
                                    fontSize: '10px',
                                    marginLeft: 'auto'
                                  }}
                                >
                                  Delete
                                </button>
                              </div>
                            )
                          })}
                        </div>
                      </div>
                    )
                  })()}

                  {/* Edit Timeouts */}
                  {data?.events && (() => {
                    const timeoutEvents = data.events.filter(e => e.type === 'timeout').sort((a, b) => (b.seq || 0) - (a.seq || 0)).slice(0, 20)
                    if (timeoutEvents.length === 0) return null

                    return (
                      <div
                        className="manual-item"
                        style={{
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '8px',
                          paddingTop: '16px',
                          borderTop: '1px solid rgba(255,255,255,0.08)'
                        }}
                      >
                        <div style={{ fontWeight: 600, marginBottom: '8px' }}>Edit Timeouts ({timeoutEvents.length} most recent)</div>
                        <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                          Edit or delete timeout events. Score shown is at time of timeout.
                        </div>
                        <div style={{
                          maxHeight: '300px',
                          overflowY: 'auto',
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '6px'
                        }}>
                          {timeoutEvents.map(event => {
                            const setIndex = event.setIndex || 1
                            const team = event.payload?.team
                            const teamLabel = team === teamAKey ? 'A' : (team === teamBKey ? 'B' : '')

                            // Calculate score at time of this timeout
                            const setEvents = data.events.filter(e => e.setIndex === setIndex)
                            const eventIndex = setEvents.findIndex(e => e.id === event.id)
                            let homeScore = 0
                            let awayScore = 0
                            for (let i = 0; i < eventIndex; i++) {
                              const e = setEvents[i]
                              if (e.type === 'point') {
                                if (e.payload?.team === 'home') homeScore++
                                else if (e.payload?.team === 'away') awayScore++
                              }
                            }

                            return (
                              <div key={event.id} style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: '8px',
                                padding: '8px',
                                background: 'rgba(255,255,255,0.03)',
                                borderRadius: '4px',
                                fontSize: '11px',
                                flexWrap: 'wrap'
                              }}>
                                <span style={{ minWidth: '40px' }}>Set {setIndex}</span>
                                <select
                                  value={team || 'home'}
                                  onChange={async (e) => {
                                    await db.events.update(event.id, {
                                      payload: { ...event.payload, team: e.target.value }
                                    })
                                  }}
                                  style={{
                                    padding: '4px 6px',
                                    fontSize: '11px',
                                    background: '#1e293b',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)',
                                    minWidth: '70px'
                                  }}
                                >
                                  <option value="home" style={{ background: '#1e293b', color: '#fff' }}>Home</option>
                                  <option value="away" style={{ background: '#1e293b', color: '#fff' }}>Away</option>
                                </select>
                                <span style={{ fontSize: '10px', color: 'var(--muted)' }}>{homeScore}-{awayScore}</span>
                                <button
                                  className="danger"
                                  onClick={async () => {
                                    if (confirm(`Delete this timeout event?`)) {
                                      await db.events.delete(event.id)
                                    }
                                  }}
                                  style={{
                                    padding: '4px 8px',
                                    fontSize: '10px',
                                    marginLeft: 'auto'
                                  }}
                                >
                                  Delete
                                </button>
                              </div>
                            )
                          })}
                        </div>
                      </div>
                    )
                  })()}

                  {/* Edit Substitutions */}
                  {data?.events && (() => {
                    const substitutionEvents = data.events.filter(e => e.type === 'substitution').sort((a, b) => (b.seq || 0) - (a.seq || 0)).slice(0, 20)
                    if (substitutionEvents.length === 0) return null

                    return (
                      <div
                        className="manual-item"
                        style={{
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '8px',
                          paddingTop: '16px',
                          borderTop: '1px solid rgba(255,255,255,0.08)'
                        }}
                      >
                        <div style={{ fontWeight: 600, marginBottom: '8px' }}>Edit Substitutions ({substitutionEvents.length} most recent)</div>
                        <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                          Edit or delete substitution events. Score shown is at time of substitution.
                        </div>
                        <div style={{
                          maxHeight: '300px',
                          overflowY: 'auto',
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '6px'
                        }}>
                          {substitutionEvents.map(event => {
                            const setIndex = event.setIndex || 1
                            const team = event.payload?.team
                            const teamLabel = team === teamAKey ? 'A' : (team === teamBKey ? 'B' : '')
                            const playerOut = event.payload?.playerOut
                            const playerIn = event.payload?.playerIn
                            const position = event.payload?.position

                            // Calculate score at time of this substitution
                            const setEvents = data.events.filter(e => e.setIndex === setIndex)
                            const eventIndex = setEvents.findIndex(e => e.id === event.id)
                            let homeScore = 0
                            let awayScore = 0
                            for (let i = 0; i < eventIndex; i++) {
                              const e = setEvents[i]
                              if (e.type === 'point') {
                                if (e.payload?.team === 'home') homeScore++
                                else if (e.payload?.team === 'away') awayScore++
                              }
                            }

                            return (
                              <div key={event.id} style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: '8px',
                                padding: '8px',
                                background: 'rgba(255,255,255,0.03)',
                                borderRadius: '4px',
                                fontSize: '11px',
                                flexWrap: 'wrap'
                              }}>
                                <span style={{ minWidth: '40px' }}>Set {setIndex}</span>
                                <select
                                  value={team || 'home'}
                                  onChange={async (e) => {
                                    await db.events.update(event.id, {
                                      payload: { ...event.payload, team: e.target.value }
                                    })
                                  }}
                                  style={{
                                    padding: '4px 6px',
                                    fontSize: '11px',
                                    background: '#1e293b',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)',
                                    minWidth: '70px'
                                  }}
                                >
                                  <option value="home" style={{ background: '#1e293b', color: '#fff' }}>Home</option>
                                  <option value="away" style={{ background: '#1e293b', color: '#fff' }}>Away</option>
                                </select>
                                <span style={{ fontSize: '10px', color: 'var(--muted)' }}>{homeScore}-{awayScore}</span>
                                <select
                                  value={position || 'I'}
                                  onChange={async (e) => {
                                    await db.events.update(event.id, {
                                      payload: { ...event.payload, position: e.target.value }
                                    })
                                  }}
                                  style={{
                                    padding: '4px 6px',
                                    fontSize: '11px',
                                    background: '#1e293b',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)',
                                    width: '45px'
                                  }}
                                >
                                  {['I', 'II', 'III', 'IV', 'V', 'VI'].map(pos => (
                                    <option key={pos} value={pos} style={{ background: '#1e293b', color: '#fff' }}>{pos}</option>
                                  ))}
                                </select>
                                <span style={{ fontSize: '10px' }}>Out:</span>
                                <input
                                  type="number"
                                  min="1"
                                  max="99"
                                  value={playerOut || ''}
                                  onChange={async (e) => {
                                    const val = parseInt(e.target.value) || null
                                    await db.events.update(event.id, {
                                      payload: { ...event.payload, playerOut: val }
                                    })
                                  }}
                                  style={{
                                    width: '40px',
                                    padding: '4px',
                                    fontSize: '11px',
                                    background: '#1e293b',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)'
                                  }}
                                />
                                <span style={{ fontSize: '10px' }}>In:</span>
                                <input
                                  type="number"
                                  min="1"
                                  max="99"
                                  value={playerIn || ''}
                                  onChange={async (e) => {
                                    const val = parseInt(e.target.value) || null
                                    await db.events.update(event.id, {
                                      payload: { ...event.payload, playerIn: val }
                                    })
                                  }}
                                  style={{
                                    width: '40px',
                                    padding: '4px',
                                    fontSize: '11px',
                                    background: '#1e293b',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)'
                                  }}
                                />
                                <label style={{ fontSize: '9px', display: 'flex', alignItems: 'center', gap: '2px' }}>
                                  <input
                                    type="checkbox"
                                    checked={event.payload?.isInjury || false}
                                    onChange={async (e) => {
                                      await db.events.update(event.id, {
                                        payload: { ...event.payload, isInjury: e.target.checked }
                                      })
                                    }}
                                    style={{ width: '12px', height: '12px', cursor: 'pointer' }}
                                  />
                                  Inj
                                </label>
                                <label style={{ fontSize: '9px', display: 'flex', alignItems: 'center', gap: '2px' }}>
                                  <input
                                    type="checkbox"
                                    checked={event.payload?.isExceptional || false}
                                    onChange={async (e) => {
                                      await db.events.update(event.id, {
                                        payload: { ...event.payload, isExceptional: e.target.checked }
                                      })
                                    }}
                                    style={{ width: '12px', height: '12px', cursor: 'pointer' }}
                                  />
                                  Exc
                                </label>
                                <label style={{ fontSize: '9px', display: 'flex', alignItems: 'center', gap: '2px' }}>
                                  <input
                                    type="checkbox"
                                    checked={event.payload?.isExpelled || false}
                                    onChange={async (e) => {
                                      await db.events.update(event.id, {
                                        payload: { ...event.payload, isExpelled: e.target.checked }
                                      })
                                    }}
                                    style={{ width: '12px', height: '12px', cursor: 'pointer' }}
                                  />
                                  Exp
                                </label>
                                <label style={{ fontSize: '9px', display: 'flex', alignItems: 'center', gap: '2px' }}>
                                  <input
                                    type="checkbox"
                                    checked={event.payload?.isDisqualified || false}
                                    onChange={async (e) => {
                                      await db.events.update(event.id, {
                                        payload: { ...event.payload, isDisqualified: e.target.checked }
                                      })
                                    }}
                                    style={{ width: '12px', height: '12px', cursor: 'pointer' }}
                                  />
                                  Dsq
                                </label>
                                <button
                                  className="danger"
                                  onClick={async () => {
                                    if (confirm(`Delete this substitution event? The lineup will be restored (player OUT returns to court).`)) {
                                      const subTeam = event.payload?.team
                                      const subPosition = event.payload?.position
                                      const subPlayerOut = event.payload?.playerOut
                                      const subSetIndex = event.setIndex

                                      // Delete the substitution event
                                      await db.events.delete(event.id)

                                      // Find and delete the lineup event created by this substitution
                                      // Then restore the previous lineup with the original player
                                      if (subTeam && subPosition && subPlayerOut) {
                                        const allEvents = await db.events.where('matchId').equals(matchId).toArray()
                                        const lineupEvents = allEvents
                                          .filter(e => e.type === 'lineup' && e.payload?.team === subTeam && e.setIndex === subSetIndex)
                                          .sort((a, b) => new Date(b.ts) - new Date(a.ts)) // Most recent first

                                        if (lineupEvents.length > 1) {
                                          // Delete the most recent lineup (created by the substitution)
                                          const mostRecentLineup = lineupEvents[0]
                                          // Preserve liberoSubstitution from the lineup we're deleting
                                          const existingLiberoSub = mostRecentLineup.payload?.liberoSubstitution || null
                                          await db.events.delete(mostRecentLineup.id)

                                          // Get the previous lineup and restore it with the original player
                                          const previousLineup = lineupEvents[1]?.payload?.lineup || {}
                                          const restoredLineup = { ...previousLineup }
                                          restoredLineup[subPosition] = String(subPlayerOut)

                                          // Get next sequence number
                                          const maxSeq = allEvents.reduce((max, e) => Math.max(max, e.seq || 0), 0)
                                          const nextSeq = Math.floor(maxSeq) + 1

                                          // Create restored lineup event
                                          const restoredPayload = { team: subTeam, lineup: restoredLineup, fromSubstitution: true }
                                          if (existingLiberoSub) {
                                            restoredPayload.liberoSubstitution = existingLiberoSub
                                          }
                                          await db.events.add({
                                            matchId,
                                            setIndex: subSetIndex,
                                            type: 'lineup',
                                            payload: restoredPayload,
                                            ts: new Date().toISOString(),
                                            seq: nextSeq
                                          })
                                        } else if (lineupEvents.length === 1) {
                                          // Only one lineup - just update it to restore the original player
                                          const currentLineup = lineupEvents[0]
                                          const restoredLineup = { ...currentLineup.payload?.lineup }
                                          restoredLineup[subPosition] = String(subPlayerOut)
                                          await db.events.update(currentLineup.id, {
                                            payload: { ...currentLineup.payload, lineup: restoredLineup }
                                          })
                                        }
                                      }
                                    }
                                  }}
                                  style={{
                                    padding: '4px 8px',
                                    fontSize: '10px',
                                    marginLeft: 'auto'
                                  }}
                                >
                                  Delete
                                </button>
                              </div>
                            )
                          })}
                        </div>
                      </div>
                    )
                  })()}

                  {/* Edit Sanctions */}
                  {data?.events && (() => {
                    const sanctionEvents = data.events.filter(e => e.type === 'sanction').sort((a, b) => (b.seq || 0) - (a.seq || 0)).slice(0, 20)
                    if (sanctionEvents.length === 0) return null

                    return (
                      <div
                        className="manual-item"
                        style={{
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '8px',
                          paddingTop: '16px',
                          borderTop: '1px solid rgba(255,255,255,0.08)'
                        }}
                      >
                        <div style={{ fontWeight: 600, marginBottom: '8px' }}>Edit Sanctions ({sanctionEvents.length} most recent)</div>
                        <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                          Edit or delete sanction events. Score shown is at time of sanction.
                        </div>
                        <div style={{
                          maxHeight: '300px',
                          overflowY: 'auto',
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '6px'
                        }}>
                          {sanctionEvents.map(event => {
                            const setIndex = event.setIndex || 1
                            const team = event.payload?.team
                            const teamLabel = team === teamAKey ? 'A' : (team === teamBKey ? 'B' : '')
                            const sanctionType = event.payload?.type
                            const playerNumber = event.payload?.playerNumber
                            const position = event.payload?.position
                            const role = event.payload?.role

                            // Calculate score at time of this sanction
                            const setEvents = data.events.filter(e => e.setIndex === setIndex)
                            const eventIndex = setEvents.findIndex(e => e.id === event.id)
                            let homeScore = 0
                            let awayScore = 0
                            for (let i = 0; i < eventIndex; i++) {
                              const e = setEvents[i]
                              if (e.type === 'point') {
                                if (e.payload?.team === 'home') homeScore++
                                else if (e.payload?.team === 'away') awayScore++
                              }
                            }

                            return (
                              <div key={event.id} style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: '8px',
                                padding: '8px',
                                background: 'rgba(255,255,255,0.03)',
                                borderRadius: '4px',
                                fontSize: '11px',
                                flexWrap: 'wrap'
                              }}>
                                <span style={{ minWidth: '40px' }}>Set {setIndex}</span>
                                <select
                                  value={team || 'home'}
                                  onChange={async (e) => {
                                    await db.events.update(event.id, {
                                      payload: { ...event.payload, team: e.target.value }
                                    })
                                  }}
                                  style={{
                                    padding: '4px 6px',
                                    fontSize: '11px',
                                    background: '#1e293b',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)',
                                    minWidth: '70px'
                                  }}
                                >
                                  <option value="home" style={{ background: '#1e293b', color: '#fff' }}>Home</option>
                                  <option value="away" style={{ background: '#1e293b', color: '#fff' }}>Away</option>
                                </select>
                                <select
                                  value={sanctionType || 'warning'}
                                  onChange={async (e) => {
                                    await db.events.update(event.id, {
                                      payload: { ...event.payload, type: e.target.value }
                                    })
                                  }}
                                  style={{
                                    padding: '4px 6px',
                                    fontSize: '11px',
                                    background: '#1e293b',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)',
                                    minWidth: '90px'
                                  }}
                                >
                                  <option value="warning" style={{ background: '#1e293b', color: '#fff' }}>Warning</option>
                                  <option value="penalty" style={{ background: '#1e293b', color: '#fff' }}>Penalty</option>
                                  <option value="expulsion" style={{ background: '#1e293b', color: '#fff' }}>Expulsion</option>
                                  <option value="disqualification" style={{ background: '#1e293b', color: '#fff' }}>Disqualif.</option>
                                  <option value="improper_request" style={{ background: '#1e293b', color: '#fff' }}>Improper Req</option>
                                  <option value="delay_warning" style={{ background: '#1e293b', color: '#fff' }}>Delay Warn</option>
                                  <option value="delay_penalty" style={{ background: '#1e293b', color: '#fff' }}>Delay Pen</option>
                                </select>
                                <span style={{ fontSize: '10px', color: 'var(--muted)' }}>{homeScore}-{awayScore}</span>
                                {playerNumber !== undefined && playerNumber !== null && (
                                  <>
                                    <span style={{ fontSize: '10px' }}>#</span>
                                    <input
                                      type="number"
                                      min="1"
                                      max="99"
                                      value={playerNumber || ''}
                                      onChange={async (e) => {
                                        const val = parseInt(e.target.value) || null
                                        await db.events.update(event.id, {
                                          payload: { ...event.payload, playerNumber: val }
                                        })
                                      }}
                                      style={{
                                        width: '40px',
                                        padding: '4px',
                                        fontSize: '11px',
                                        background: '#1e293b',
                                        border: '1px solid rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        color: 'var(--text)'
                                      }}
                                    />
                                  </>
                                )}
                                {position && (
                                  <select
                                    value={position || 'I'}
                                    onChange={async (e) => {
                                      await db.events.update(event.id, {
                                        payload: { ...event.payload, position: e.target.value }
                                      })
                                    }}
                                    style={{
                                      padding: '4px',
                                      fontSize: '11px',
                                      background: '#1e293b',
                                      border: '1px solid rgba(255,255,255,0.2)',
                                      borderRadius: '4px',
                                      color: 'var(--text)',
                                      width: '45px'
                                    }}
                                  >
                                    {['I', 'II', 'III', 'IV', 'V', 'VI'].map(pos => (
                                      <option key={pos} value={pos} style={{ background: '#1e293b', color: '#fff' }}>{pos}</option>
                                    ))}
                                  </select>
                                )}
                                {role && (
                                  <select
                                    value={role || 'Coach'}
                                    onChange={async (e) => {
                                      await db.events.update(event.id, {
                                        payload: { ...event.payload, role: e.target.value }
                                      })
                                    }}
                                    style={{
                                      padding: '4px',
                                      fontSize: '11px',
                                      background: '#1e293b',
                                      border: '1px solid rgba(255,255,255,0.2)',
                                      borderRadius: '4px',
                                      color: 'var(--text)',
                                      minWidth: '70px'
                                    }}
                                  >
                                    <option value="Coach" style={{ background: '#1e293b', color: '#fff' }}>Coach</option>
                                    <option value="Assistant Coach 1" style={{ background: '#1e293b', color: '#fff' }}>Asst 1</option>
                                    <option value="Assistant Coach 2" style={{ background: '#1e293b', color: '#fff' }}>Asst 2</option>
                                    <option value="Physiotherapist" style={{ background: '#1e293b', color: '#fff' }}>Physio</option>
                                    <option value="Medic" style={{ background: '#1e293b', color: '#fff' }}>Medic</option>
                                  </select>
                                )}
                                <button
                                  className="danger"
                                  onClick={async () => {
                                    if (confirm(`Delete this sanction event?`)) {
                                      await db.events.delete(event.id)
                                    }
                                  }}
                                  style={{
                                    padding: '4px 8px',
                                    fontSize: '10px',
                                    marginLeft: 'auto'
                                  }}
                                >
                                  Delete
                                </button>
                              </div>
                            )
                          })}
                        </div>
                      </div>
                    )
                  })()}

                  {/* Edit Libero Actions */}
                  {data?.events && (() => {
                    const liberoEvents = data.events.filter(e =>
                      e.type === 'libero_entry' ||
                      e.type === 'libero_exit' ||
                      e.type === 'libero_substitution' ||
                      e.type === 'libero_unable' ||
                      e.type === 'libero_redesignation'
                    ).sort((a, b) => (b.seq || 0) - (a.seq || 0)).slice(0, 20)
                    if (liberoEvents.length === 0) return null

                    return (
                      <div
                        className="manual-item"
                        style={{
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '8px',
                          paddingTop: '16px',
                          borderTop: '1px solid rgba(255,255,255,0.08)'
                        }}
                      >
                        <div style={{ fontWeight: 600, marginBottom: '8px' }}>Edit Libero Actions ({liberoEvents.length} most recent)</div>
                        <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                          Edit or delete libero-related events.
                        </div>
                        <div style={{
                          maxHeight: '300px',
                          overflowY: 'auto',
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '6px'
                        }}>
                          {liberoEvents.map(event => {
                            const setIndex = event.setIndex || 1
                            const team = event.payload?.team
                            const teamLabel = team === teamAKey ? 'A' : (team === teamBKey ? 'B' : '')
                            const eventType = event.type

                            // Calculate score at time of this event
                            const setEvents = data.events.filter(e => e.setIndex === setIndex)
                            const eventIndex = setEvents.findIndex(e => e.id === event.id)
                            let homeScore = 0
                            let awayScore = 0
                            for (let i = 0; i < eventIndex; i++) {
                              const e = setEvents[i]
                              if (e.type === 'point') {
                                if (e.payload?.team === 'home') homeScore++
                                else if (e.payload?.team === 'away') awayScore++
                              }
                            }

                            return (
                              <div key={event.id} style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: '8px',
                                padding: '8px',
                                background: 'rgba(255,255,255,0.03)',
                                borderRadius: '4px',
                                fontSize: '11px',
                                flexWrap: 'wrap'
                              }}>
                                <span style={{ minWidth: '40px' }}>Set {setIndex}</span>
                                <span style={{ fontSize: '9px', fontWeight: 600, minWidth: '70px' }}>
                                  {eventType === 'libero_entry' ? 'Libero Entry' : eventType === 'libero_exit' ? 'Libero Exit' : 'Libero Unable'}
                                </span>
                                <select
                                  value={team || 'home'}
                                  onChange={async (e) => {
                                    await db.events.update(event.id, {
                                      payload: { ...event.payload, team: e.target.value }
                                    })
                                  }}
                                  style={{
                                    padding: '4px 6px',
                                    fontSize: '11px',
                                    background: '#1e293b',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)',
                                    minWidth: '70px'
                                  }}
                                >
                                  <option value="home" style={{ background: '#1e293b', color: '#fff' }}>Home</option>
                                  <option value="away" style={{ background: '#1e293b', color: '#fff' }}>Away</option>
                                </select>
                                <span style={{ fontSize: '10px', color: 'var(--muted)' }}>{homeScore}-{awayScore}</span>
                                {eventType === 'libero_entry' && (
                                  <>
                                    <span style={{ fontSize: '10px' }}>L#:</span>
                                    <input
                                      type="number"
                                      min="1"
                                      max="99"
                                      value={event.payload?.liberoIn || ''}
                                      onChange={async (e) => {
                                        const val = parseInt(e.target.value) || null
                                        await db.events.update(event.id, {
                                          payload: { ...event.payload, liberoIn: val }
                                        })
                                      }}
                                      style={{
                                        width: '40px',
                                        padding: '4px',
                                        fontSize: '11px',
                                        background: '#1e293b',
                                        border: '1px solid rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        color: 'var(--text)'
                                      }}
                                    />
                                    <span style={{ fontSize: '10px' }}>Out:</span>
                                    <input
                                      type="number"
                                      min="1"
                                      max="99"
                                      value={event.payload?.playerOut || ''}
                                      onChange={async (e) => {
                                        const val = parseInt(e.target.value) || null
                                        await db.events.update(event.id, {
                                          payload: { ...event.payload, playerOut: val }
                                        })
                                      }}
                                      style={{
                                        width: '40px',
                                        padding: '4px',
                                        fontSize: '11px',
                                        background: '#1e293b',
                                        border: '1px solid rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        color: 'var(--text)'
                                      }}
                                    />
                                    <select
                                      value={event.payload?.liberoType || 'libero1'}
                                      onChange={async (e) => {
                                        await db.events.update(event.id, {
                                          payload: { ...event.payload, liberoType: e.target.value }
                                        })
                                      }}
                                      style={{
                                        padding: '4px',
                                        fontSize: '11px',
                                        background: '#1e293b',
                                        border: '1px solid rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        color: 'var(--text)',
                                        minWidth: '45px'
                                      }}
                                    >
                                      <option value="libero1" style={{ background: '#1e293b', color: '#fff' }}>L1</option>
                                      <option value="libero2" style={{ background: '#1e293b', color: '#fff' }}>L2</option>
                                    </select>
                                  </>
                                )}
                                {eventType === 'libero_exit' && (
                                  <>
                                    <span style={{ fontSize: '10px' }}>L Out:</span>
                                    <input
                                      type="number"
                                      min="1"
                                      max="99"
                                      value={event.payload?.liberoOut || ''}
                                      onChange={async (e) => {
                                        const val = parseInt(e.target.value) || null
                                        await db.events.update(event.id, {
                                          payload: { ...event.payload, liberoOut: val }
                                        })
                                      }}
                                      style={{
                                        width: '40px',
                                        padding: '4px',
                                        fontSize: '11px',
                                        background: '#1e293b',
                                        border: '1px solid rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        color: 'var(--text)'
                                      }}
                                    />
                                    <span style={{ fontSize: '10px' }}>P In:</span>
                                    <input
                                      type="number"
                                      min="1"
                                      max="99"
                                      value={event.payload?.playerIn || ''}
                                      onChange={async (e) => {
                                        const val = parseInt(e.target.value) || null
                                        await db.events.update(event.id, {
                                          payload: { ...event.payload, playerIn: val }
                                        })
                                      }}
                                      style={{
                                        width: '40px',
                                        padding: '4px',
                                        fontSize: '11px',
                                        background: '#1e293b',
                                        border: '1px solid rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        color: 'var(--text)'
                                      }}
                                    />
                                  </>
                                )}
                                {eventType === 'libero_unable' && (
                                  <>
                                    <span style={{ fontSize: '10px' }}>L#:</span>
                                    <input
                                      type="number"
                                      min="1"
                                      max="99"
                                      value={event.payload?.liberoNumber || ''}
                                      onChange={async (e) => {
                                        const val = parseInt(e.target.value) || null
                                        await db.events.update(event.id, {
                                          payload: { ...event.payload, liberoNumber: val }
                                        })
                                      }}
                                      style={{
                                        width: '40px',
                                        padding: '4px',
                                        fontSize: '11px',
                                        background: '#1e293b',
                                        border: '1px solid rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        color: 'var(--text)'
                                      }}
                                    />
                                    <select
                                      value={event.payload?.reason || 'injury'}
                                      onChange={async (e) => {
                                        await db.events.update(event.id, {
                                          payload: { ...event.payload, reason: e.target.value }
                                        })
                                      }}
                                      style={{
                                        padding: '4px 6px',
                                        fontSize: '11px',
                                        background: '#1e293b',
                                        border: '1px solid rgba(255,255,255,0.2)',
                                        borderRadius: '4px',
                                        color: 'var(--text)',
                                        minWidth: '120px'
                                      }}
                                    >
                                      <option value="injury" style={{ background: '#1e293b', color: '#fff' }}>Injury</option>
                                      <option value="expulsion" style={{ background: '#1e293b', color: '#fff' }}>Expulsion</option>
                                      <option value="disqualification" style={{ background: '#1e293b', color: '#fff' }}>Disqualification</option>
                                    </select>
                                  </>
                                )}
                                <button
                                  className="danger"
                                  onClick={async () => {
                                    if (confirm(`Delete this ${eventType} event?`)) {
                                      await db.events.delete(event.id)
                                    }
                                  }}
                                  style={{
                                    padding: '4px 8px',
                                    fontSize: '10px',
                                    marginLeft: 'auto'
                                  }}
                                >
                                  Delete
                                </button>
                              </div>
                            )
                          })}
                        </div>
                      </div>
                    )
                  })()}

                  {/* Edit Lineups */}
                  {data?.events && (() => {
                    const lineupEvents = data.events.filter(e => e.type === 'lineup' && e.payload?.isInitial).sort((a, b) => (b.seq || 0) - (a.seq || 0)).slice(0, 10)
                    if (lineupEvents.length === 0) return null

                    return (
                      <div
                        className="manual-item"
                        style={{
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '8px',
                          paddingTop: '16px',
                          borderTop: '1px solid rgba(255,255,255,0.08)'
                        }}
                      >
                        <div style={{ fontWeight: 600, marginBottom: '8px' }}>Edit Initial Lineups ({lineupEvents.length} most recent)</div>
                        <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                          Edit or delete initial lineup events.
                        </div>
                        <div style={{
                          maxHeight: '300px',
                          overflowY: 'auto',
                          display: 'flex',
                          flexDirection: 'column',
                          gap: '6px'
                        }}>
                          {lineupEvents.map(event => {
                            const setIndex = event.setIndex || 1
                            const team = event.payload?.team
                            const teamLabel = team === teamAKey ? 'A' : (team === teamBKey ? 'B' : '')
                            const lineup = event.payload?.lineup || {}

                            return (
                              <div key={event.id} style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: '8px',
                                padding: '8px',
                                background: 'rgba(255,255,255,0.03)',
                                borderRadius: '4px',
                                fontSize: '11px',
                                flexWrap: 'wrap'
                              }}>
                                <span style={{ minWidth: '40px' }}>Set {setIndex}</span>
                                <select
                                  value={team || 'home'}
                                  onChange={async (e) => {
                                    await db.events.update(event.id, {
                                      payload: { ...event.payload, team: e.target.value }
                                    })
                                  }}
                                  style={{
                                    padding: '4px 6px',
                                    fontSize: '11px',
                                    background: '#1e293b',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)',
                                    minWidth: '70px'
                                  }}
                                >
                                  <option value="home" style={{ background: '#1e293b', color: '#fff' }}>Home</option>
                                  <option value="away" style={{ background: '#1e293b', color: '#fff' }}>Away</option>
                                </select>
                                <span style={{ fontSize: '10px', color: 'var(--muted)' }}>
                                  {lineup.I || '-'}/{lineup.II || '-'}/{lineup.III || '-'}/{lineup.IV || '-'}/{lineup.V || '-'}/{lineup.VI || '-'}
                                </span>
                                <button
                                  className="secondary"
                                  onClick={() => {
                                    setLineupModal({ team, mode: 'manual', lineup })
                                    setShowManualPanel(false)
                                  }}
                                  style={{
                                    padding: '4px 8px',
                                    fontSize: '10px'
                                  }}
                                >
                                  Edit
                                </button>
                                <button
                                  className="danger"
                                  onClick={async () => {
                                    if (confirm(`Delete this lineup event?`)) {
                                      await db.events.delete(event.id)
                                    }
                                  }}
                                  style={{
                                    padding: '4px 8px',
                                    fontSize: '10px',
                                    marginLeft: 'auto'
                                  }}
                                >
                                  Delete
                                </button>
                              </div>
                            )
                          })}
                        </div>
                      </div>
                    )
                  })()}
                </div>
              )}
            </div>

            {/* Collapsible Section: Advanced */}
            <div style={{
              marginBottom: '12px',
              background: 'rgba(255,255,255,0.03)',
              borderRadius: '12px',
              border: '1px solid rgba(255,255,255,0.08)',
              overflow: 'hidden'
            }}>
              <button
                onClick={() => setManualPanelExpandedSections(prev => ({ ...prev, advanced: !prev.advanced }))}
                style={{
                  width: '100%',
                  padding: '14px 16px',
                  background: 'transparent',
                  border: 'none',
                  color: 'var(--text)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  cursor: 'pointer',
                  fontSize: '15px',
                  fontWeight: 600
                }}
              >
                <span style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                  <span style={{ fontSize: '18px' }}>🔧</span>
                  Advanced
                </span>
                <span style={{ fontSize: '12px', transform: manualPanelExpandedSections.advanced ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
              </button>
              {manualPanelExpandedSections.advanced && (
                <div style={{ padding: '0 16px 16px 16px' }}>

                  {/* Edit Set Times */}
                  {data?.sets && data.sets.length > 0 && (
                    <div
                      className="manual-item"
                      style={{
                        display: 'flex',
                        flexDirection: 'column',
                        gap: '8px',
                        paddingBottom: '16px',
                        borderBottom: '1px solid rgba(255,255,255,0.08)'
                      }}
                    >
                      <div style={{ fontWeight: 600, marginBottom: '8px' }}>Edit Set Times</div>
                      <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                        Edit start and end times for sets.
                      </div>
                      <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                        {data.sets.sort((a, b) => a.index - b.index).map(set => (
                          <div key={set.id} style={{
                            display: 'flex',
                            flexDirection: 'column',
                            gap: '8px',
                            padding: '8px',
                            background: 'rgba(255,255,255,0.03)',
                            borderRadius: '6px'
                          }}>
                            <div style={{ fontWeight: 600, fontSize: '12px' }}>Set {set.index}</div>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '12px', flexWrap: 'wrap' }}>
                              <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                                <label style={{ fontSize: '11px', minWidth: '80px' }}>Start Time:</label>
                                <input
                                  type="datetime-local"
                                  defaultValue={(() => {
                                    if (!set.startTime) return ''
                                    const d = new Date(set.startTime)
                                    // Format as local datetime for datetime-local input
                                    const year = d.getFullYear()
                                    const month = String(d.getMonth() + 1).padStart(2, '0')
                                    const day = String(d.getDate()).padStart(2, '0')
                                    const hours = String(d.getHours()).padStart(2, '0')
                                    const minutes = String(d.getMinutes()).padStart(2, '0')
                                    return `${year}-${month}-${day}T${hours}:${minutes}`
                                  })()}
                                  onBlur={async (e) => {
                                    const newTime = e.target.value ? new Date(e.target.value).toISOString() : null
                                    await db.sets.update(set.id, { startTime: newTime })
                                  }}
                                  style={{
                                    padding: '4px 6px',
                                    fontSize: '11px',
                                    background: 'var(--bg-secondary)',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)'
                                  }}
                                />
                              </div>
                              <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                                <label style={{ fontSize: '11px', minWidth: '80px' }}>End Time:</label>
                                <input
                                  type="datetime-local"
                                  defaultValue={(() => {
                                    if (!set.endTime) return ''
                                    const d = new Date(set.endTime)
                                    // Format as local datetime for datetime-local input
                                    const year = d.getFullYear()
                                    const month = String(d.getMonth() + 1).padStart(2, '0')
                                    const day = String(d.getDate()).padStart(2, '0')
                                    const hours = String(d.getHours()).padStart(2, '0')
                                    const minutes = String(d.getMinutes()).padStart(2, '0')
                                    return `${year}-${month}-${day}T${hours}:${minutes}`
                                  })()}
                                  onBlur={async (e) => {
                                    const newTime = e.target.value ? new Date(e.target.value).toISOString() : null
                                    await db.sets.update(set.id, { endTime: newTime })
                                  }}
                                  style={{
                                    padding: '4px 6px',
                                    fontSize: '11px',
                                    background: 'var(--bg-secondary)',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)'
                                  }}
                                />
                              </div>
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {/* Add New Event */}
                  <div
                    className="manual-item"
                    style={{
                      display: 'flex',
                      flexDirection: 'column',
                      gap: '8px',
                      paddingTop: '16px',
                      borderTop: '1px solid rgba(255,255,255,0.08)'
                    }}
                  >
                    <div style={{ fontWeight: 600, marginBottom: '8px' }}>Add New Event</div>
                    <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                      Manually add a new event to the match history.
                    </div>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                        <label style={{ fontSize: '12px', minWidth: '100px' }}>Event Type:</label>
                        <select
                          id="newEventType"
                          style={{
                            flex: 1,
                            padding: '6px 8px',
                            fontSize: '12px',
                            background: '#1e293b',
                            border: '1px solid rgba(255,255,255,0.2)',
                            borderRadius: '4px',
                            color: 'var(--text)'
                          }}
                        >
                          <option value="point" style={{ background: '#1e293b', color: 'var(--text)' }}>Point</option>
                          <option value="timeout" style={{ background: '#1e293b', color: 'var(--text)' }}>Timeout</option>
                          <option value="substitution" style={{ background: '#1e293b', color: 'var(--text)' }}>Substitution</option>
                          <option value="sanction" style={{ background: '#1e293b', color: 'var(--text)' }}>Sanction</option>
                          <option value="lineup" style={{ background: '#1e293b', color: 'var(--text)' }}>Lineup</option>
                          <option value="libero_entry" style={{ background: '#1e293b', color: 'var(--text)' }}>Libero Entry</option>
                          <option value="libero_exit" style={{ background: '#1e293b', color: 'var(--text)' }}>Libero Exit</option>
                          <option value="libero_substitution" style={{ background: '#1e293b', color: 'var(--text)' }}>Libero Substitution</option>
                          <option value="libero_unable" style={{ background: '#1e293b', color: 'var(--text)' }}>Libero Unable</option>
                          <option value="replay" style={{ background: '#1e293b', color: 'var(--text)' }}>Replay</option>
                          <option value="rally_start" style={{ background: '#1e293b', color: 'var(--text)' }}>Rally Start</option>
                          <option value="set_start" style={{ background: '#1e293b', color: 'var(--text)' }}>Set Start</option>
                          <option value="set_end" style={{ background: '#1e293b', color: 'var(--text)' }}>Set End</option>
                        </select>
                      </div>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                        <label style={{ fontSize: '12px', minWidth: '100px' }}>Set:</label>
                        <select
                          id="newEventSet"
                          style={{
                            flex: 1,
                            padding: '6px 8px',
                            fontSize: '12px',
                            background: '#1e293b',
                            border: '1px solid rgba(255,255,255,0.2)',
                            borderRadius: '4px',
                            color: 'var(--text)'
                          }}
                        >
                          {data?.sets?.sort((a, b) => a.index - b.index).map(set => (
                            <option key={set.id} value={set.index} style={{ background: '#1e293b', color: 'var(--text)' }}>Set {set.index}</option>
                          ))}
                        </select>
                      </div>
                      <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                        <label style={{ fontSize: '12px', minWidth: '100px' }}>Team:</label>
                        <select
                          id="newEventTeam"
                          style={{
                            flex: 1,
                            padding: '6px 8px',
                            fontSize: '12px',
                            background: '#1e293b',
                            border: '1px solid rgba(255,255,255,0.2)',
                            borderRadius: '4px',
                            color: 'var(--text)'
                          }}
                        >
                          <option value="home" style={{ background: '#1e293b', color: 'var(--text)' }}>Home</option>
                          <option value="away" style={{ background: '#1e293b', color: 'var(--text)' }}>Away</option>
                        </select>
                      </div>
                      <button
                        className="secondary"
                        onClick={async () => {
                          const eventType = document.getElementById('newEventType')?.value
                          const setIndex = parseInt(document.getElementById('newEventSet')?.value || '1')
                          const team = document.getElementById('newEventTeam')?.value

                          if (!eventType || !setIndex || !team) {
                            showAlert('Please fill in all fields', 'warning')
                            return
                          }

                          // Get next sequence number
                          const allEvents = await db.events.where('matchId').equals(matchId).toArray()
                          const maxSeq = allEvents.reduce((max, e) => Math.max(max, e.seq || 0), 0)

                          const payload = { team }

                          // Add type-specific fields
                          if (eventType === 'substitution') {
                            payload.position = 'I'
                            payload.playerOut = null
                            payload.playerIn = null
                          } else if (eventType === 'sanction') {
                            payload.type = 'warning'
                          } else if (eventType === 'lineup') {
                            payload.lineup = { I: null, II: null, III: null, IV: null, V: null, VI: null }
                            payload.isInitial = true
                          } else if (eventType === 'libero_entry') {
                            payload.liberoIn = null
                            payload.playerOut = null
                            payload.liberoType = 'libero1'
                          } else if (eventType === 'libero_exit') {
                            payload.liberoOut = null
                            payload.playerIn = null
                          } else if (eventType === 'libero_unable') {
                            payload.liberoNumber = null
                            payload.liberoType = 'libero1'
                            payload.reason = 'injury'
                          }

                          const debugSeq = maxSeq + 1
                          const debugEventId = await db.events.add({
                            matchId,
                            setIndex,
                            type: eventType,
                            payload,
                            ts: new Date().toISOString(),
                            seq: debugSeq
                          })

                          showAlert('Event added. You can now edit it in the sections above.', 'success')
                        }}
                        style={{
                          padding: '8px 16px',
                          fontSize: '12px'
                        }}
                      >
                        Add Event
                      </button>
                    </div>
                  </div>

                  {/* Delete Events (Simple List) */}
                  {data?.events && data.events.length > 0 && (
                    <div
                      className="manual-item"
                      style={{
                        display: 'flex',
                        flexDirection: 'column',
                        gap: '8px',
                        paddingTop: '16px',
                        borderTop: '1px solid rgba(255,255,255,0.08)'
                      }}
                    >
                      <div style={{ fontWeight: 600, marginBottom: '8px' }}>Delete Events (Quick)</div>
                      <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '12px' }}>
                        Quick delete for any event. Use with caution.
                      </div>
                      <div style={{
                        maxHeight: '200px',
                        overflowY: 'auto',
                        display: 'flex',
                        flexDirection: 'column',
                        gap: '4px'
                      }}>
                        {data.events
                          .sort((a, b) => {
                            const aTime = typeof a.ts === 'number' ? a.ts : new Date(a.ts).getTime()
                            const bTime = typeof b.ts === 'number' ? b.ts : new Date(b.ts).getTime()
                            return bTime - aTime
                          })
                          .slice(0, 30)
                          .map(event => {
                            const eventType = event.type
                            const setIndex = event.setIndex || 1
                            const team = event.payload?.team
                            const teamLabel = team === teamAKey ? 'A' : (team === teamBKey ? 'B' : '')
                            const description = eventType === 'point' ? `Point ${teamLabel}` :
                              eventType === 'timeout' ? `Timeout ${teamLabel}` :
                                eventType === 'substitution' ? `Substitution ${teamLabel}` :
                                  eventType === 'lineup' ? `Lineup ${teamLabel}` :
                                    eventType === 'sanction' ? `Sanction ${teamLabel}` :
                                      eventType === 'libero_entry' ? `Libero Entry ${teamLabel}` :
                                        eventType === 'libero_exit' ? `Libero Exit ${teamLabel}` :
                                          eventType === 'libero_substitution' ? `Libero Sub ${teamLabel}` :
                                            eventType === 'libero_unable' ? `Libero Unable ${teamLabel}` :
                                              eventType

                            return (
                              <div key={event.id} style={{
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'space-between',
                                padding: '6px 8px',
                                background: 'rgba(255,255,255,0.03)',
                                borderRadius: '4px',
                                fontSize: '11px'
                              }}>
                                <span>
                                  Set {setIndex} - {description}
                                </span>
                                <button
                                  className="danger"
                                  onClick={async () => {
                                    if (confirm(`Delete this ${eventType} event?`)) {
                                      await db.events.delete(event.id)
                                    }
                                  }}
                                  style={{
                                    padding: '4px 8px',
                                    fontSize: '10px'
                                  }}
                                >
                                  Delete
                                </button>
                              </div>
                            )
                          })}
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Collapsible Section: Manual Changes Summary */}
            <div style={{
              marginBottom: '12px',
              background: 'rgba(255,255,255,0.03)',
              borderRadius: '12px',
              border: '1px solid rgba(255,255,255,0.08)',
              overflow: 'hidden'
            }}>
              <button
                onClick={() => setManualPanelExpandedSections(prev => ({ ...prev, summary: !prev.summary }))}
                style={{
                  width: '100%',
                  padding: '14px 16px',
                  background: 'transparent',
                  border: 'none',
                  color: 'var(--text)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  cursor: 'pointer',
                  fontSize: '15px',
                  fontWeight: 600
                }}
              >
                <span style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                  <span style={{ fontSize: '18px' }}>📋</span>
                  Manual Changes Summary
                  {manualChangesLog.length > 0 && (
                    <span style={{
                      background: 'var(--primary)',
                      color: '#fff',
                      fontSize: '11px',
                      padding: '2px 8px',
                      borderRadius: '10px',
                      marginLeft: '4px'
                    }}>
                      {manualChangesLog.length}
                    </span>
                  )}
                </span>
                <span style={{ fontSize: '12px', transform: manualPanelExpandedSections.summary ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
              </button>
              {manualPanelExpandedSections.summary && (
                <div style={{ padding: '0 16px 16px 16px' }}>
                  {manualChangesLog.length === 0 ? (
                    <div style={{
                      fontSize: '12px',
                      color: 'var(--muted)',
                      textAlign: 'center',
                      padding: '24px 0'
                    }}>
                      No manual changes recorded yet.
                      <br />
                      <span style={{ fontSize: '11px' }}>
                        Changes made via this panel will be logged here.
                      </span>
                    </div>
                  ) : (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                      <div style={{ fontSize: '12px', color: 'var(--muted)', marginBottom: '4px' }}>
                        All manual modifications made during this match session:
                      </div>
                      <div style={{
                        maxHeight: '400px',
                        overflowY: 'auto',
                        display: 'flex',
                        flexDirection: 'column',
                        gap: '6px'
                      }}>
                        {manualChangesLog.slice().reverse().map((change, idx) => {
                          const time = new Date(change.ts)
                          const timeStr = `${String(time.getHours()).padStart(2, '0')}:${String(time.getMinutes()).padStart(2, '0')}:${String(time.getSeconds()).padStart(2, '0')}`

                          return (
                            <div key={idx} style={{
                              padding: '10px 12px',
                              background: 'rgba(255,255,255,0.03)',
                              borderRadius: '6px',
                              border: '1px solid rgba(255,255,255,0.06)',
                              fontSize: '12px'
                            }}>
                              <div style={{
                                display: 'flex',
                                justifyContent: 'space-between',
                                alignItems: 'center',
                                marginBottom: '6px'
                              }}>
                                <span style={{
                                  fontWeight: 600,
                                  color: 'var(--primary)',
                                  fontSize: '11px',
                                  textTransform: 'uppercase'
                                }}>
                                  {change.category}
                                </span>
                                <span style={{
                                  fontSize: '10px',
                                  color: 'var(--muted)',
                                  fontFamily: 'monospace'
                                }}>
                                  {timeStr}
                                </span>
                              </div>
                              <div style={{ marginBottom: '4px', color: 'var(--text)' }}>
                                {change.description}
                              </div>
                              <div style={{
                                display: 'flex',
                                gap: '12px',
                                fontSize: '11px',
                                color: 'var(--muted)'
                              }}>
                                <span>
                                  <strong>Before:</strong> {String(change.before)}
                                </span>
                                <span>→</span>
                                <span>
                                  <strong>After:</strong> {String(change.after)}
                                </span>
                              </div>
                            </div>
                          )
                        })}
                      </div>

                      {/* Export/Copy Log */}
                      <div style={{
                        marginTop: '8px',
                        paddingTop: '12px',
                        borderTop: '1px solid rgba(255,255,255,0.08)'
                      }}>
                        <button
                          className="secondary"
                          onClick={() => {
                            const logText = manualChangesLog.map(c => {
                              const time = new Date(c.ts).toLocaleTimeString()
                              return `[${time}] ${c.category} - ${c.field}: "${c.before}" → "${c.after}"`
                            }).join('\n')
                            navigator.clipboard.writeText(logText)
                            showAlert('Manual changes log copied to clipboard!', 'success')
                          }}
                          style={{
                            padding: '8px 16px',
                            fontSize: '12px',
                            width: '100%'
                          }}
                        >
                          📋 Copy Log
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>

          </div>
        </Modal>
      )}

      {/* Remarks Modal */}
      {showRemarks && (
        <Modal
          title={t('scoreboard.modals.remarksRecording')}
          open={true}
          onClose={() => {
            setShowRemarks(false)
            setRemarksText('')
          }}
          width={600}
        >
          <div style={{ padding: '20px', maxHeight: '80vh', overflowY: 'auto' }}>
            <section className="panel">
              <h3>Remarks</h3>
              <textarea
                ref={remarksTextareaRef}
                className="remarks-area"
                placeholder="Record match remarks…"
                value={remarksText}
                onChange={e => {
                  setRemarksText(e.target.value)
                }}
                onBlur={async () => {
                  // When user finishes editing, save and log as event
                  const oldRemarks = data?.match?.remarks || ''
                  const newRemarks = remarksText.trim()

                  if (newRemarks !== oldRemarks) {
                    // Save the new remarks
                    await db.matches.update(matchId, { remarks: newRemarks })

                    // Log remark insertion as an event if new text was added
                    if (data?.set && newRemarks) {
                      // Get the added text (what's new compared to old)
                      const oldLines = oldRemarks.split('\n')
                      const newLines = newRemarks.split('\n')

                      // Find what was added (new lines that weren't in old)
                      const addedLines = newLines.filter((line, idx) => {
                        // If old remarks is empty, all new lines are added
                        if (!oldRemarks) return line.trim()
                        // Check if this line is new (not in old remarks)
                        return idx >= oldLines.length || line !== oldLines[idx]
                      }).filter(line => line.trim())

                      if (addedLines.length > 0) {
                        const addedText = addedLines.join('\n')
                        await logEvent('remark', {
                          text: addedText,
                          fullRemarks: newRemarks
                        })
                      }
                    }
                  }
                }}
                style={{
                  width: '95%',
                  minHeight: '300px',
                  fontSize: '14px',
                  fontFamily: 'monospace',
                  background: 'var(--bg-secondary)',
                  border: '1px solid rgba(255,255,255,0.2)',
                  borderRadius: '6px',
                  color: 'var(--text)',
                  resize: 'vertical'
                }}
              />
              <div style={{ marginTop: '12px', fontSize: '12px', color: 'var(--muted)' }}>
                <div>• Existing remarks are shown above</div>
                <div>• Add new remarks on a new line</div>
                <div>• Changes are saved automatically when you click outside the text area</div>
              </div>
            </section>
          </div>
        </Modal>
      )}

      {/* Stop Match Modal - Choose between Forfeit or Impossibility */}
      {stopMatchModal === 'select' && (
        <Modal
          title={t('scoreboard.stopMatch.title', 'Stop the Match')}
          open={true}
          onClose={() => setStopMatchModal(null)}
          width={400}
        >
          <div style={{ padding: '20px', display: 'flex', flexDirection: 'column', gap: '16px' }}>
            <button
              className="secondary"
              onClick={() => {
                setStopMatchModal(null)
                setStopMatchTeamSelect({ pendingAction: 'forfeit' })
              }}
              style={{ padding: '16px', fontSize: '16px' }}
            >
              {t('scoreboard.stopMatch.teamForfeits', 'A team forfeits')}
            </button>
            <button
              className="secondary"
              onClick={() => {
                setStopMatchModal(null)
                setStopMatchConfirm({ type: 'impossibility' })
              }}
              style={{ padding: '16px', fontSize: '16px' }}
            >
              {t('scoreboard.stopMatch.impossibilityToResume', 'Impossibility to resume')}
            </button>
          </div>
        </Modal>
      )}

      {/* Stop Match - Team Selection (for Forfeit) */}
      {stopMatchTeamSelect && (
        <Modal
          title={t('scoreboard.stopMatch.selectForfeitingTeam', 'Select Forfeiting Team')}
          open={true}
          onClose={() => setStopMatchTeamSelect(null)}
          width={400}
        >
          <div style={{ padding: '20px', display: 'flex', flexDirection: 'column', gap: '16px' }}>
            <div style={{ marginBottom: '12px', color: 'var(--muted)' }}>
              {t('scoreboard.stopMatch.selectTeamPrompt', 'Which team is forfeiting?')}
            </div>
            <button
              onClick={() => {
                setStopMatchTeamSelect(null)
                setStopMatchConfirm({ type: 'forfeit', team: 'home' })
              }}
              style={{
                padding: '16px',
                fontSize: '16px',
                background: data?.homeTeam?.color || '#3b82f6',
                color: '#fff',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer'
              }}
            >
              {data?.homeTeam?.name || t('common.home', 'Home')} ({homeLabel})
            </button>
            <button
              onClick={() => {
                setStopMatchTeamSelect(null)
                setStopMatchConfirm({ type: 'forfeit', team: 'away' })
              }}
              style={{
                padding: '16px',
                fontSize: '16px',
                background: data?.awayTeam?.color || '#ef4444',
                color: '#fff',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer'
              }}
            >
              {data?.awayTeam?.name || t('common.away', 'Away')} ({awayLabel})
            </button>
          </div>
        </Modal>
      )}

      {/* Stop Match - Confirmation */}
      {stopMatchConfirm && (
        <Modal
          title={stopMatchConfirm.type === 'forfeit'
            ? t('scoreboard.stopMatch.confirmForfeitTitle', 'Confirm Forfeit')
            : t('scoreboard.stopMatch.confirmImpossibilityTitle', 'Impossibility to Resume')}
          open={true}
          onClose={() => setStopMatchConfirm(null)}
          width={500}
        >
          <div style={{ padding: '20px' }}>
            {stopMatchConfirm.type === 'forfeit' ? (
              <>
                <div style={{ marginBottom: '16px', fontSize: '16px' }}>
                  {t('scoreboard.stopMatch.confirmForfeitMessage',
                    '{{team}} will forfeit. The opponent will be awarded all remaining points and sets to win the match.', {
                    team: stopMatchConfirm.team === 'home'
                      ? (data?.homeTeam?.name || t('common.home', 'Home'))
                      : (data?.awayTeam?.name || t('common.away', 'Away'))
                  })}
                </div>
              </>
            ) : (
              <>
                <div style={{ marginBottom: '16px', fontSize: '16px' }}>
                  {t('scoreboard.stopMatch.confirmImpossibilityMessage',
                    'The match will end with current scores. No winner will be declared. Match data will be downloaded.')}
                </div>
              </>
            )}
            <div style={{ marginBottom: '16px', fontSize: '14px', color: 'var(--muted)' }}>
              {t('scoreboard.stopMatch.addRemarksPrompt', 'Please record remarks explaining the match stoppage.')}
            </div>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
              <button className="secondary" onClick={() => setStopMatchConfirm(null)}>
                {t('common.cancel', 'Cancel')}
              </button>
              <button
                onClick={() => {
                  // Move to remarks step
                  setStopMatchRemarksStep({
                    type: stopMatchConfirm.type,
                    team: stopMatchConfirm.team
                  })
                  setStopMatchConfirm(null)
                  setShowRemarks(true) // Open the existing remarks modal
                }}
                style={{ background: '#ef4444', color: '#fff', border: 'none' }}
              >
                {t('scoreboard.stopMatch.continueToRemarks', 'Continue to Remarks')}
              </button>
            </div>
          </div>
        </Modal>
      )}

      {/* Stop Match - Final step after remarks (shown when remarks modal closes) */}
      {stopMatchRemarksStep && !showRemarks && (
        <Modal
          title={t('scoreboard.stopMatch.finalConfirmTitle', 'End Match')}
          open={true}
          onClose={() => setStopMatchRemarksStep(null)}
          width={400}
        >
          <div style={{ padding: '20px' }}>
            <div style={{ marginBottom: '16px', fontSize: '16px' }}>
              {stopMatchRemarksStep.type === 'forfeit'
                ? t('scoreboard.stopMatch.finalConfirmForfeit', 'End match with {{winner}} as winner?', {
                  winner: stopMatchRemarksStep.team === 'home'
                    ? (data?.awayTeam?.name || t('common.away', 'Away'))
                    : (data?.homeTeam?.name || t('common.home', 'Home'))
                })
                : t('scoreboard.stopMatch.finalConfirmImpossibility', 'End match without a winner?')}
            </div>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
              <button className="secondary" onClick={() => setStopMatchRemarksStep(null)}>
                {t('common.cancel', 'Cancel')}
              </button>
              <button
                onClick={completeStopMatchFlow}
                style={{ background: '#ef4444', color: '#fff', border: 'none' }}
              >
                {t('scoreboard.stopMatch.endMatch', 'End Match')}
              </button>
            </div>
          </div>
        </Modal>
      )}

      {/* Sanctions and Results Modal */}
      {showSanctions && (
        <Modal
          title={t('scoreboard.modals.sanctionsAndResults')}
          open={true}
          onClose={() => setShowSanctions(false)}
          width={1000}
        >
          <div style={{ padding: '20px', maxHeight: '80vh', overflowY: 'auto' }}>
            <section className="panel">
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '32px', overflowX: 'auto' }}>
                {/* Left half: Sanctions */}
                <div>
                  <h4 style={{ marginBottom: '16px', fontSize: '14px', fontWeight: 600 }}>Sanctions</h4>
                  {/* Improper Request Row */}
                  <div style={{ marginBottom: '16px', display: 'flex', alignItems: 'center', gap: '12px' }}>
                    <div style={{ fontWeight: 600, fontSize: '12px', minWidth: '100px' }}>Improper Request:</div>
                    <div style={{ display: 'flex', gap: '8px' }}>
                      {['A', 'B'].map(team => {
                        const teamKey = team === 'A' ? teamAKey : teamBKey
                        const teamKeyCapitalized = teamKey === 'home' ? 'Home' : 'Away'
                        const hasImproperRequest = data?.match?.sanctions?.[`improperRequest${teamKeyCapitalized}`]

                        return (
                          <div key={team} style={{
                            width: '28px',
                            height: '28px',
                            borderRadius: '50%',
                            border: '2px solid rgba(255,255,255,0.3)',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontSize: '12px',
                            fontWeight: 700,
                            position: 'relative'
                          }}>
                            {team}
                            {hasImproperRequest && (
                              <div style={{
                                position: 'absolute',
                                inset: 0,
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                fontSize: '20px',
                                color: '#ef4444',
                                fontWeight: 900
                              }}>
                                ✕
                              </div>
                            )}
                          </div>
                        )
                      })}
                    </div>
                  </div>

                  {/* Sanctions Table */}
                  <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '11px' }}>
                    <thead>
                      <tr style={{ borderBottom: '2px solid rgba(255,255,255,0.2)' }}>
                        <th style={{ padding: '6px 4px', textAlign: 'center', fontWeight: 600 }}>Warn</th>
                        <th style={{ padding: '6px 4px', textAlign: 'center', fontWeight: 600 }}>Pen</th>
                        <th style={{ padding: '6px 4px', textAlign: 'center', fontWeight: 600 }}>Exp</th>
                        <th style={{ padding: '6px 4px', textAlign: 'center', fontWeight: 600 }}>Disq</th>
                        <th style={{ padding: '6px 4px', textAlign: 'center', fontWeight: 600 }}>Team</th>
                        <th style={{ padding: '6px 4px', textAlign: 'center', fontWeight: 600 }}>Set</th>
                        <th style={{ padding: '6px 4px', textAlign: 'center', fontWeight: 600 }}>Score</th>
                      </tr>
                    </thead>
                    <tbody>
                      {(() => {
                        // Get all sanction events except improper_request (already shown in box above)
                        const sanctionEvents = (data?.events || []).filter(e =>
                          e.type === 'sanction' && e.payload?.type !== 'improper_request'
                        )

                        if (sanctionEvents.length === 0) {
                          return (
                            <tr>
                              <td colSpan="7" style={{ padding: '12px', textAlign: 'center', color: 'var(--muted)', fontSize: '11px' }}>
                                No sanctions recorded
                              </td>
                            </tr>
                          )
                        }

                        return sanctionEvents.map((event, idx) => {
                          const sanctionType = event.payload?.type
                          const team = event.payload?.team
                          const teamLabel = team === teamAKey ? 'A' : 'B'
                          const setIndex = event.setIndex || 1
                          const playerType = event.payload?.playerType
                          const playerNumber = event.payload?.playerNumber
                          const role = event.payload?.role

                          // Get the identifier to display (player number or role abbreviation)
                          let identifier = null
                          if (role) {
                            identifier = role === 'Coach' ? 'C' :
                              role === 'Assistant Coach 1' ? 'AC1' :
                                role === 'Assistant Coach 2' ? 'AC2' :
                                  role === 'Physiotherapist' ? 'P' :
                                    role === 'Medic' ? 'M' : role
                          } else if (playerNumber !== undefined && playerNumber !== null) {
                            identifier = String(playerNumber)
                          }

                          // Calculate score at time of sanction
                          const setEvents = (data?.events || []).filter(e => e.setIndex === setIndex)
                          const eventIndex = setEvents.findIndex(e => e.id === event.id)
                          let homeScore = 0
                          let awayScore = 0
                          for (let i = 0; i <= eventIndex; i++) {
                            const e = setEvents[i]
                            if (e.type === 'point') {
                              if (e.payload?.team === 'home') homeScore++
                              else if (e.payload?.team === 'away') awayScore++
                            }
                          }

                          const sanctionedTeamScore = team === 'home' ? homeScore : awayScore
                          const otherTeamScore = team === 'home' ? awayScore : homeScore
                          const scoreDisplay = `${sanctionedTeamScore}:${otherTeamScore}`

                          return (
                            <tr key={event.id || idx} style={{ borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
                              <td style={{ padding: '6px 4px', textAlign: 'center' }}>
                                {sanctionType === 'warning' && identifier}
                                {sanctionType === 'delay_warning' && !identifier && 'D'}
                              </td>
                              <td style={{ padding: '6px 4px', textAlign: 'center' }}>
                                {sanctionType === 'penalty' && identifier}
                                {sanctionType === 'delay_penalty' && !identifier && 'D'}
                              </td>
                              <td style={{ padding: '6px 4px', textAlign: 'center' }}>
                                {sanctionType === 'expulsion' && identifier}
                              </td>
                              <td style={{ padding: '6px 4px', textAlign: 'center' }}>
                                {sanctionType === 'disqualification' && identifier}
                              </td>
                              <td style={{ padding: '6px 4px', textAlign: 'center', fontWeight: 600 }}>{teamLabel}</td>
                              <td style={{ padding: '6px 4px', textAlign: 'center' }}>{setIndex}</td>
                              <td style={{ padding: '6px 4px', textAlign: 'center' }}>{scoreDisplay}</td>
                            </tr>
                          )
                        })
                      })()}
                    </tbody>
                  </table>
                </div>

                {/* Right half: Results */}
                <div>
                  <h4 style={{ marginBottom: '16px', fontSize: '14px', fontWeight: 600 }}>Results</h4>
                  {(() => {
                    // Get current left and right teams
                    const currentLeftTeamKey = leftIsHome ? 'home' : 'away'
                    const currentRightTeamKey = leftIsHome ? 'away' : 'home'
                    const leftTeamData = currentLeftTeamKey === 'home' ? data?.homeTeam : data?.awayTeam
                    const rightTeamData = currentRightTeamKey === 'home' ? data?.homeTeam : data?.awayTeam
                    const leftTeamColor = leftTeamData?.color || (currentLeftTeamKey === 'home' ? '#ef4444' : '#3b82f6')
                    const rightTeamColor = rightTeamData?.color || (currentRightTeamKey === 'home' ? '#ef4444' : '#3b82f6')
                    const leftTeamName = leftTeamData?.name || 'Left Team'
                    const rightTeamName = rightTeamData?.name || 'Right Team'
                    const leftTeamLabel = currentLeftTeamKey === teamAKey ? 'A' : 'B'
                    const rightTeamLabel = currentRightTeamKey === teamAKey ? 'A' : 'B'

                    // Get all sets including current
                    const allSets = (data?.sets || []).sort((a, b) => a.index - b.index)
                    const finishedSets = allSets.filter(s => s.finished)

                    // Check if match is final
                    const isMatchFinal = data?.match?.status === 'final'

                    // If match is final, show match results table
                    if (isMatchFinal) {
                      // Calculate totals for each team
                      const leftTotalTimeouts = finishedSets.reduce((sum, set) => {
                        return sum + (data?.events || []).filter(e =>
                          e.type === 'timeout' && e.setIndex === set.index && e.payload?.team === currentLeftTeamKey
                        ).length
                      }, 0)
                      const rightTotalTimeouts = finishedSets.reduce((sum, set) => {
                        return sum + (data?.events || []).filter(e =>
                          e.type === 'timeout' && e.setIndex === set.index && e.payload?.team === currentRightTeamKey
                        ).length
                      }, 0)

                      const leftTotalSubs = finishedSets.reduce((sum, set) => {
                        return sum + (data?.events || []).filter(e =>
                          e.type === 'substitution' && e.setIndex === set.index && e.payload?.team === currentLeftTeamKey
                        ).length
                      }, 0)
                      const rightTotalSubs = finishedSets.reduce((sum, set) => {
                        return sum + (data?.events || []).filter(e =>
                          e.type === 'substitution' && e.setIndex === set.index && e.payload?.team === currentRightTeamKey
                        ).length
                      }, 0)

                      const leftTotalWins = finishedSets.filter(s => {
                        const leftPoints = currentLeftTeamKey === 'home' ? s.homePoints : s.awayPoints
                        const rightPoints = currentRightTeamKey === 'home' ? s.homePoints : s.awayPoints
                        return leftPoints > rightPoints
                      }).length
                      const rightTotalWins = finishedSets.filter(s => {
                        const leftPoints = currentLeftTeamKey === 'home' ? s.homePoints : s.awayPoints
                        const rightPoints = currentRightTeamKey === 'home' ? s.homePoints : s.awayPoints
                        return rightPoints > leftPoints
                      }).length

                      const leftTotalPoints = finishedSets.reduce((sum, set) => {
                        return sum + (currentLeftTeamKey === 'home' ? set.homePoints : set.awayPoints)
                      }, 0)
                      const rightTotalPoints = finishedSets.reduce((sum, set) => {
                        return sum + (currentRightTeamKey === 'home' ? set.homePoints : set.awayPoints)
                      }, 0)

                      // Calculate total match duration
                      let totalDurationMin = 0
                      finishedSets.forEach(set => {
                        if (set.startTime && set.endTime) {
                          const start = new Date(set.startTime)
                          const end = new Date(set.endTime)
                          const durationMs = end - start
                          totalDurationMin += Math.floor(durationMs / 60000)
                        }
                      })

                      // Find match start time (first set_start event or first set startTime)
                      const firstSetStartEvent = (data?.events || []).find(e => e.type === 'set_start' && e.setIndex === 1)
                      const matchStartTime = firstSetStartEvent ? new Date(firstSetStartEvent.ts) : (finishedSets[0]?.startTime ? new Date(finishedSets[0].startTime) : null)

                      // Find match end time (last set endTime)
                      const matchEndTime = finishedSets.length > 0 && finishedSets[finishedSets.length - 1]?.endTime
                        ? new Date(finishedSets[finishedSets.length - 1].endTime)
                        : null

                      // Calculate match duration
                      let matchDurationMin = 0
                      if (matchStartTime && matchEndTime) {
                        const durationMs = matchEndTime - matchStartTime
                        matchDurationMin = Math.floor(durationMs / 60000)
                      }

                      // Determine winner
                      const winnerTeamKey = leftTotalWins > rightTotalWins ? currentLeftTeamKey : currentRightTeamKey
                      const winnerTeamData = winnerTeamKey === 'home' ? data?.homeTeam : data?.awayTeam
                      const winnerTeamName = winnerTeamData?.name || (winnerTeamKey === 'home' ? 'Home' : 'Away')
                      const winnerScore = `${leftTotalWins}-${rightTotalWins}`

                      // Get captain signatures
                      const homeCaptainSignature = data?.match?.homePostGameCaptainSignature || null
                      const awayCaptainSignature = data?.match?.awayPostGameCaptainSignature || null

                      return (
                        <div>
                          <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '9px' }}>
                            <thead>
                              <tr>
                                <th colSpan="4" style={{ padding: '4px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.2)', width: '42%' }}>
                                  <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px', flexWrap: 'wrap' }}>
                                    <span style={{ fontSize: '10px', wordBreak: 'break-word' }}>{leftTeamName}</span>
                                    <span style={{
                                      padding: '1px 6px',
                                      borderRadius: '3px',
                                      fontSize: '9px',
                                      fontWeight: 700,
                                      background: leftTeamColor,
                                      color: isBrightColor(leftTeamColor) ? '#000' : '#fff'
                                    }}>{leftTeamLabel}</span>
                                  </div>
                                </th>
                                <th style={{ padding: '4px', fontSize: '8px', width: '16%' }}>Dur</th>
                                <th colSpan="4" style={{ padding: '4px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.2)', width: '42%' }}>
                                  <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px', flexWrap: 'wrap' }}>
                                    <span style={{ fontSize: '10px', wordBreak: 'break-word' }}>{rightTeamName}</span>
                                    <span style={{
                                      padding: '1px 6px',
                                      borderRadius: '3px',
                                      fontSize: '9px',
                                      fontWeight: 700,
                                      background: rightTeamColor,
                                      color: isBrightColor(rightTeamColor) ? '#000' : '#fff'
                                    }}>{rightTeamLabel}</span>
                                  </div>
                                </th>
                              </tr>
                              <tr style={{ borderBottom: '2px solid rgba(255,255,255,0.2)' }}>
                                <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>T</th>
                                <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>S</th>
                                <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>W</th>
                                <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>P</th>
                                <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}></th>
                                <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>P</th>
                                <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>W</th>
                                <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>S</th>
                                <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>T</th>
                              </tr>
                            </thead>
                            <tbody>
                              <tr style={{ borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
                                <td style={{ padding: '4px 2px', textAlign: 'center' }}>{leftTotalTimeouts}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center' }}>{leftTotalSubs}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center' }}>{leftTotalWins}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center' }}>{leftTotalPoints}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center', fontSize: '8px', color: 'var(--muted)' }}>{totalDurationMin}'</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center' }}>{rightTotalPoints}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center' }}>{rightTotalWins}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center' }}>{rightTotalSubs}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center' }}>{rightTotalTimeouts}</td>
                              </tr>
                            </tbody>
                          </table>

                          {/* Match time information */}
                          <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '9px', marginTop: '12px' }}>
                            <tbody>
                              <tr style={{ borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
                                <td style={{ padding: '4px 2px', textAlign: 'left', fontWeight: 600, fontSize: '8px' }}>Match start time:</td>
                                <td style={{ padding: '4px 2px', textAlign: 'left', fontSize: '8px' }}>
                                  {matchStartTime ? `${String(matchStartTime.getUTCHours()).padStart(2, '0')}:${String(matchStartTime.getUTCMinutes()).padStart(2, '0')}:${String(matchStartTime.getUTCSeconds()).padStart(2, '0')}` : '—'}
                                </td>
                                <td style={{ padding: '4px 2px', textAlign: 'left', fontWeight: 600, fontSize: '8px' }}>Match end time:</td>
                                <td style={{ padding: '4px 2px', textAlign: 'left', fontSize: '8px' }}>
                                  {matchEndTime ? `${String(matchEndTime.getUTCHours()).padStart(2, '0')}:${String(matchEndTime.getUTCMinutes()).padStart(2, '0')}:${String(matchEndTime.getUTCSeconds()).padStart(2, '0')}` : '—'}
                                </td>
                                <td style={{ padding: '4px 2px', textAlign: 'left', fontWeight: 600, fontSize: '8px' }}>Match duration:</td>
                                <td style={{ padding: '4px 2px', textAlign: 'left', fontSize: '8px' }}>
                                  {matchDurationMin > 0 ? `${matchDurationMin} min` : '—'}
                                </td>
                              </tr>
                              <tr>
                                <td style={{ padding: '4px 2px', textAlign: 'left', fontWeight: 600, fontSize: '8px' }}>Winner:</td>
                                <td colSpan="5" style={{ padding: '4px 2px', textAlign: 'left', fontSize: '8px' }}>
                                  {winnerTeamName} ({winnerScore})
                                </td>
                              </tr>
                            </tbody>
                          </table>

                          {/* Post-match signatures */}
                          <div style={{ marginTop: '16px', display: 'flex', gap: '16px', justifyContent: 'space-around' }}>
                            <div style={{ flex: 1 }}>
                              <div style={{ fontSize: '9px', fontWeight: 600, marginBottom: '4px' }}>
                                {data?.homeTeam?.name || 'Home'} Captain
                              </div>
                              {homeCaptainSignature ? (
                                <div style={{ border: '1px solid rgba(255,255,255,0.2)', borderRadius: '4px', padding: '4px', minHeight: '40px', background: 'rgba(255,255,255,0.05)' }}>
                                  <img src={homeCaptainSignature} alt="Signature" style={{ maxWidth: '100%', maxHeight: '40px', objectFit: 'contain' }} />
                                </div>
                              ) : (
                                <button
                                  onClick={() => setPostMatchSignature('home-captain')}
                                  style={{
                                    width: '100%',
                                    padding: '8px',
                                    fontSize: '9px',
                                    background: 'rgba(255,255,255,0.1)',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)',
                                    cursor: 'pointer'
                                  }}
                                >
                                  Sign
                                </button>
                              )}
                            </div>
                            <div style={{ flex: 1 }}>
                              <div style={{ fontSize: '9px', fontWeight: 600, marginBottom: '4px' }}>
                                {data?.awayTeam?.name || 'Away'} Captain
                              </div>
                              {awayCaptainSignature ? (
                                <div style={{ border: '1px solid rgba(255,255,255,0.2)', borderRadius: '4px', padding: '4px', minHeight: '40px', background: 'rgba(255,255,255,0.05)' }}>
                                  <img src={awayCaptainSignature} alt="Signature" style={{ maxWidth: '100%', maxHeight: '40px', objectFit: 'contain' }} />
                                </div>
                              ) : (
                                <button
                                  onClick={() => setPostMatchSignature('away-captain')}
                                  style={{
                                    width: '100%',
                                    padding: '8px',
                                    fontSize: '9px',
                                    background: 'rgba(255,255,255,0.1)',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '4px',
                                    color: 'var(--text)',
                                    cursor: 'pointer'
                                  }}
                                >
                                  Sign
                                </button>
                              )}
                            </div>
                          </div>
                        </div>
                      )
                    }

                    // Otherwise show set breakdown
                    // Helper to convert set number to Roman numeral
                    const toRoman = (num) => {
                      const romanNumerals = ['I', 'II', 'III', 'IV', 'V']
                      return romanNumerals[num - 1] || num.toString()
                    }

                    // Only show sets that have been played (started or have points)
                    const playedSets = allSets.filter(s => s.homePoints > 0 || s.awayPoints > 0 || s.finished || s.startTime)

                    return (
                      <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '9px' }}>
                        <thead>
                          <tr>
                            <th style={{ padding: '4px 2px', textAlign: 'center', width: '8%' }}></th>
                            <th colSpan="4" style={{ padding: '4px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.2)', width: '38%' }}>
                              <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px', flexWrap: 'wrap' }}>
                                <span style={{ fontSize: '10px', wordBreak: 'break-word' }}>{leftTeamName}</span>
                                <span style={{
                                  padding: '1px 6px',
                                  borderRadius: '3px',
                                  fontSize: '9px',
                                  fontWeight: 700,
                                  background: leftTeamColor,
                                  color: isBrightColor(leftTeamColor) ? '#000' : '#fff'
                                }}>{leftTeamLabel}</span>
                              </div>
                            </th>
                            <th style={{ padding: '4px 2px', fontSize: '8px', width: '8%' }}>Dur</th>
                            <th colSpan="4" style={{ padding: '4px', textAlign: 'center', borderBottom: '1px solid rgba(255,255,255,0.2)', width: '38%' }}>
                              <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '6px', flexWrap: 'wrap' }}>
                                <span style={{ fontSize: '10px', wordBreak: 'break-word' }}>{rightTeamName}</span>
                                <span style={{
                                  padding: '1px 6px',
                                  borderRadius: '3px',
                                  fontSize: '9px',
                                  fontWeight: 700,
                                  background: rightTeamColor,
                                  color: isBrightColor(rightTeamColor) ? '#000' : '#fff'
                                }}>{rightTeamLabel}</span>
                              </div>
                            </th>
                          </tr>
                          <tr style={{ borderBottom: '2px solid rgba(255,255,255,0.2)' }}>
                            <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>Set</th>
                            <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>T</th>
                            <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>S</th>
                            <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>W</th>
                            <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>P</th>
                            <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}></th>
                            <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>P</th>
                            <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>W</th>
                            <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>S</th>
                            <th style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>T</th>
                          </tr>
                        </thead>
                        <tbody>
                          {playedSets.map(set => {
                            // Always show from CURRENT left/right perspective
                            const leftPoints = currentLeftTeamKey === 'home' ? set.homePoints : set.awayPoints
                            const rightPoints = currentRightTeamKey === 'home' ? set.homePoints : set.awayPoints

                            // Calculate timeouts for current left/right teams
                            const leftTimeouts = (data?.events || []).filter(e =>
                              e.type === 'timeout' && e.setIndex === set.index && e.payload?.team === currentLeftTeamKey
                            ).length
                            const rightTimeouts = (data?.events || []).filter(e =>
                              e.type === 'timeout' && e.setIndex === set.index && e.payload?.team === currentRightTeamKey
                            ).length

                            // Calculate substitutions for current left/right teams
                            const leftSubs = (data?.events || []).filter(e =>
                              e.type === 'substitution' && e.setIndex === set.index && e.payload?.team === currentLeftTeamKey
                            ).length
                            const rightSubs = (data?.events || []).filter(e =>
                              e.type === 'substitution' && e.setIndex === set.index && e.payload?.team === currentRightTeamKey
                            ).length

                            // Determine winner for current left/right teams
                            const leftWon = leftPoints > rightPoints ? 1 : 0
                            const rightWon = rightPoints > leftPoints ? 1 : 0

                            // Calculate set duration
                            let duration = ''
                            if (set.startTime && set.endTime) {
                              const start = new Date(set.startTime)
                              const end = new Date(set.endTime)
                              const durationMs = end - start
                              const durationMin = Math.floor(durationMs / 60000)
                              duration = `${durationMin}'`
                            }

                            return (
                              <tr key={set.id} style={{ borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
                                <td style={{ padding: '4px 2px', textAlign: 'center', fontWeight: 600, fontSize: '8px' }}>{toRoman(set.index)}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center', fontSize: '8px' }}>{leftTimeouts || 0}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center', fontSize: '8px' }}>{leftSubs || 0}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center', fontSize: '8px' }}>{leftWon}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center', fontSize: '8px' }}>{leftPoints}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center', fontSize: '8px', color: 'var(--muted)' }}>{duration}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center', fontSize: '8px' }}>{rightPoints}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center', fontSize: '8px' }}>{rightWon}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center', fontSize: '8px' }}>{rightSubs || 0}</td>
                                <td style={{ padding: '4px 2px', textAlign: 'center', fontSize: '8px' }}>{rightTimeouts || 0}</td>
                              </tr>
                            )
                          })}
                        </tbody>
                      </table>
                    )
                  })()}
                </div>
              </div>

              {/* Remarks section */}
              {data?.match?.remarks && (
                <div style={{ marginTop: '24px' }}>
                  <h4 style={{ marginBottom: '12px', fontSize: '14px', fontWeight: 600 }}>Remarks</h4>
                  <div style={{
                    background: 'rgba(255,255,255,0.05)',
                    border: '1px solid rgba(255,255,255,0.2)',
                    borderRadius: '8px',
                    padding: '12px',
                    fontSize: '12px',
                    whiteSpace: 'pre-wrap',
                    maxHeight: '200px',
                    overflowY: 'auto'
                  }}>
                    {data.match.remarks}
                  </div>
                </div>
              )}
            </section>
          </div>
        </Modal>
      )}

      {/* Timeout confirmation modal - only show before timeout starts, not during countdown */}
      {timeoutModal && !timeoutModal.started && (
        <Modal
          title={`Time-out — ${timeoutModal.team === 'home' ? (data?.homeTeam?.name || 'Home') : (data?.awayTeam?.name || 'Away')}`}
          open={true}
          onClose={cancelTimeout}
          width={400}
        >
          <div style={{ textAlign: 'center', padding: '24px', fontSize: '16px' }}>
            {/* Display current score - requesting team on left */}
            {(() => {
              const requestingTeamData = timeoutModal.team === 'home' ? data?.homeTeam : data?.awayTeam
              const otherTeamData = timeoutModal.team === 'home' ? data?.awayTeam : data?.homeTeam
              const requestingTeamScore = timeoutModal.team === 'home' ? (data?.set?.homePoints || 0) : (data?.set?.awayPoints || 0)
              const otherTeamScore = timeoutModal.team === 'home' ? (data?.set?.awayPoints || 0) : (data?.set?.homePoints || 0)
              const requestingTeamLabel = timeoutModal.team === teamAKey ? 'A' : 'B'
              const otherTeamLabel = timeoutModal.team === teamAKey ? 'B' : 'A'
              const requestingTeamColor = requestingTeamData?.color || (timeoutModal.team === 'home' ? '#ef4444' : '#3b82f6')
              const otherTeamColor = otherTeamData?.color || (timeoutModal.team === 'home' ? '#3b82f6' : '#ef4444')
              const isRequestingBright = isBrightColor(requestingTeamColor)
              const isOtherBright = isBrightColor(otherTeamColor)
              const currentTimeouts = timeoutsUsed[timeoutModal.team] || 0
              const isSecondTimeout = currentTimeouts === 1
              return (
                <div style={{ marginBottom: '16px', fontSize: '24px', fontWeight: 700, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '10px' }}>
                  <span style={{
                    fontSize: '16px',
                    fontWeight: 700,
                    padding: '4px 10px',
                    borderRadius: '6px',
                    background: requestingTeamColor,
                    color: isRequestingBright ? '#000' : '#fff'
                  }}>{requestingTeamLabel}</span>
                  <span>{requestingTeamScore}</span>
                  <span>:</span>
                  <span>{otherTeamScore}</span>
                  <span style={{
                    fontSize: '16px',
                    fontWeight: 700,
                    padding: '4px 10px',
                    borderRadius: '6px',
                    background: otherTeamColor,
                    color: isOtherBright ? '#000' : '#fff'
                  }}>{otherTeamLabel}</span>
                </div>
              )
            })()}
            <p style={{ marginBottom: '24px', color: 'var(--muted)', fontSize: '16px' }}>
              Confirm {(timeoutsUsed[timeoutModal.team] || 0) === 1 && <><span style={{ color: '#ef4444', fontWeight: 700 }}>2nd</span>{' '}</>}time-out request?
            </p>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
              <button onClick={confirmTimeout} style={{ fontSize: '16px' }}>
                Confirm time-out
              </button>
              <button className="secondary" onClick={cancelTimeout} style={{ fontSize: '16px' }}>
                Cancel
              </button>
            </div>
          </div>
        </Modal>
      )}

      {lineupModal && <LineupModal
        team={lineupModal.team}
        teamData={
          lineupModal.team === 'home'
            ? data?.homeTeam
            : data?.awayTeam
        }
        players={
          lineupModal.team === 'home'
            ? data?.homePlayers
            : data?.awayPlayers
        }
        matchId={matchId}
        setIndex={data?.set?.index}
        mode={lineupModal.mode || 'initial'}
        lineup={lineupModal.lineup}
        teamAKey={teamAKey}
        teamBKey={teamBKey}
        onClose={() => setLineupModal(null)}
        onSave={async () => {
          const teamKey = lineupModal.team
          setLineupModal(null)
          // Check if captain is on court after lineup is saved
          // Use timeout to allow data to update from database (increased to 300ms for reliability)
          setTimeout(() => {
            checkAndRequestCaptainOnCourtRef.current?.(teamKey)
          }, 300)
        }}
        onLineupSaved={() => {
          syncToReferee()
          // Also sync to Supabase match_live_state
          syncLiveStateToSupabase('lineup', lineupModal?.team || null, null)
        }}
      />}

      {playerActionMenu && (() => {
        // Get element position - use stored coordinates if available
        // For left side teams, menu opens to the right (use left CSS)
        // For right side teams, menu opens to the left (use right CSS)
        const isRightSide = playerActionMenu.side === 'right'
        let menuStyle
        if (playerActionMenu.x !== undefined && playerActionMenu.y !== undefined) {
          menuStyle = {
            position: 'fixed',
            left: isRightSide ? undefined : `${playerActionMenu.x}px`,
            right: isRightSide ? `${window.innerWidth - playerActionMenu.x}px` : undefined,
            top: `${playerActionMenu.y}px`,
            transform: 'translateY(-50%)',
            zIndex: 1000
          }
        } else {
          const rect = playerActionMenu.element?.getBoundingClientRect?.()
          menuStyle = rect ? {
            position: 'fixed',
            left: isRightSide ? undefined : `${rect.right + 30}px`,
            right: isRightSide ? `${window.innerWidth - rect.left + 30}px` : undefined,
            top: `${rect.top + rect.height / 2}px`,
            transform: 'translateY(-50%)',
            zIndex: 1000
          } : {
            position: 'absolute',
            left: '50%',
            top: '50%',
            transform: 'translate(-50%, -50%)',
            zIndex: 1000
          }
        }

        // Get available substitutes for this player
        const { team, position, playerNumber } = playerActionMenu
        const availableSubs = playerActionMenu.canSubstitute ? getAvailableSubstitutes(team, playerNumber) : []

        // Get sanction availability
        const teamWarning = teamHasFormalWarning(team)
        const hasWarning = playerHasSanctionType(team, playerNumber, 'warning')
        const hasPenalty = playerHasSanctionType(team, playerNumber, 'penalty')
        const hasExpulsion = playerHasSanctionType(team, playerNumber, 'expulsion')
        const canGetWarning = !hasWarning && !teamWarning
        const canGetPenalty = !hasPenalty
        const canGetExpulsion = !hasExpulsion

        const showSanctionConfirmFromMenu = (sanctionType) => {
          setPlayerActionMenu(null)
          setCourtSubExpanded(false)
          setCourtSanctionExpanded(false)
          setSanctionConfirmModal({
            team,
            type: 'player',
            playerNumber,
            position,
            sanctionType
          })
        }

        const handleSubFromMenu = (subPlayer) => {
          setPlayerActionMenu(null)
          setCourtSubExpanded(false)
          setCourtSanctionExpanded(false)
          // Open substitution confirmation modal (which properly creates both lineup and substitution events)
          setSubstitutionConfirm({
            team,
            position,
            playerOut: playerNumber,
            playerIn: subPlayer.number
          })
        }

        return (
          <>
            {/* Backdrop to close menu on click outside */}
            <div
              style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                zIndex: 999,
                background: 'transparent'
              }}
              onClick={() => { setPlayerActionMenu(null); setCourtSubExpanded(false); setCourtLiberoExpanded(false); setCourtSanctionExpanded(false); setCourtLiberoUnableExpanded(false) }}
            />
            {/* Action Menu */}
            <div style={menuStyle} className="modal-wrapper-roll-down">
              <div
                data-player-action-menu
                style={{
                  background: 'rgba(15, 23, 42, 0.95)',
                  border: '2px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '8px',
                  padding: '8px',
                  minWidth: '140px',
                  boxShadow: '0 8px 24px rgba(0, 0, 0, 0.5)',
                  display: 'flex',
                  flexDirection: 'column',
                  gap: '6px'
                }}
              >
                <div style={{ fontSize: '11px', fontWeight: 600, color: 'var(--muted)', textAlign: 'center', marginBottom: '4px' }}>
                  # {playerNumber}
                </div>
                {/* Substitution - auto-fire if only 1 legal substitute, otherwise expandable */}
                {playerActionMenu.canSubstitute && availableSubs.length > 0 && (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                    <button
                      onClick={() => {
                        // If only 1 legal substitute, go directly to confirmation
                        if (availableSubs.length === 1) {
                          handleSubFromMenu(availableSubs[0])
                        } else {
                          setCourtSubExpanded(!courtSubExpanded)
                        }
                      }}
                      style={{
                        padding: '8px 12px',
                        fontSize: '12px',
                        fontWeight: 600,
                        background: 'linear-gradient(135deg, #22c55e, #16a34a)',
                        color: '#000',
                        border: '1px solid rgba(0, 0, 0, 0.2)',
                        borderRadius: '6px',
                        cursor: 'pointer',
                        textAlign: 'left',
                        transition: 'all 0.2s',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        gap: '6px',
                        width: '100%'
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.background = 'linear-gradient(135deg, #4ade80, #22c55e)'
                        e.currentTarget.style.transform = 'scale(1.02)'
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.background = 'linear-gradient(135deg, #22c55e, #16a34a)'
                        e.currentTarget.style.transform = 'scale(1)'
                      }}
                    >
                      <span>Substitution</span>
                      {/* Only show arrow if more than 1 substitute available */}
                      {availableSubs.length > 1 && (
                        <span style={{ fontSize: '14px', lineHeight: '1', transform: courtSubExpanded ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
                      )}
                    </button>
                    {courtSubExpanded && availableSubs.length > 1 && (
                      <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px', marginTop: '4px' }}>
                        {availableSubs.map(sub => (
                          <button
                            key={sub.number}
                            onClick={() => handleSubFromMenu(sub)}
                            style={{
                              padding: '6px 10px',
                              fontSize: '12px',
                              fontWeight: 700,
                              background: 'rgba(34, 197, 94, 0.2)',
                              color: '#22c55e',
                              border: '1px solid rgba(34, 197, 94, 0.4)',
                              borderRadius: '4px',
                              cursor: 'pointer',
                              transition: 'all 0.2s',
                              minWidth: '40px'
                            }}
                            onMouseEnter={(e) => {
                              e.currentTarget.style.background = 'rgba(34, 197, 94, 0.4)'
                              e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.6)'
                            }}
                            onMouseLeave={(e) => {
                              e.currentTarget.style.background = 'rgba(34, 197, 94, 0.2)'
                              e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.4)'
                            }}
                          >
                            {sub.number}
                          </button>
                        ))}
                      </div>
                    )}
                  </div>
                )}
                {/* Libero - expandable */}
                {playerActionMenu.canEnterLibero && (() => {
                  // Get available liberos for this team
                  const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
                  const availableLiberos = (teamPlayers || [])
                    .filter(p => p.libero && p.libero !== '' && !isLiberoUnable(team, p.number))
                    .map(p => ({
                      number: p.number,
                      type: p.libero,
                      label: p.libero === 'libero1' ? 'L1' : p.libero === 'redesignated' ? 'LR' : 'L2'
                    }))

                  const handleLiberoSelect = async (libero) => {
                    // Close menus first
                    setPlayerActionMenu(null)
                    setCourtSubExpanded(false)
                    setCourtLiberoExpanded(false)
                    setCourtSanctionExpanded(false)

                    // Directly execute libero substitution
                    const liberoType = libero.type
                    const liberoPlayer = teamPlayers?.find(p => p.libero === liberoType)
                    if (!liberoPlayer || !data?.set) return

                    // Get current lineup
                    const lineupEvents = data.events?.filter(e =>
                      e.type === 'lineup' &&
                      e.payload?.team === team &&
                      e.setIndex === data.set.index
                    ) || []
                    const lineupEvent = lineupEvents.length > 0 ? lineupEvents[lineupEvents.length - 1] : null
                    const currentLineup = lineupEvent?.payload?.lineup || {}

                    // Create new lineup with libero entry
                    const validPositions = ['I', 'II', 'III', 'IV', 'V', 'VI']
                    const cleanedCurrentLineup = {}
                    for (const pos of validPositions) {
                      if (currentLineup[pos] !== undefined) {
                        cleanedCurrentLineup[pos] = currentLineup[pos]
                      }
                    }

                    const newLineup = { ...cleanedCurrentLineup }
                    newLineup[position] = String(liberoPlayer.number)

                    const finalLineup = {}
                    for (const pos of validPositions) {
                      if (newLineup[pos] !== undefined) {
                        finalLineup[pos] = newLineup[pos]
                      }
                    }

                    // Log the libero entry event FIRST (main event)
                    await logEvent('libero_entry', {
                      team,
                      position,
                      playerOut: playerNumber,
                      liberoIn: liberoPlayer.number,
                      liberoType
                    })

                    // Save the updated lineup as a SUB-EVENT (seq N.1) so it's deleted together with libero_entry on undo
                    const allEvents = await db.events.where({ matchId }).toArray()
                    const maxSeq = allEvents.length > 0 ? Math.max(...allEvents.map(e => e.seq || 0)) : 0
                    const subEventSeq = Math.floor(maxSeq) + 0.1 // Sub-event of the libero_entry

                    await db.events.add({
                      matchId,
                      setIndex: data.set.index,
                      type: 'lineup',
                      payload: {
                        team,
                        lineup: finalLineup,
                        liberoSubstitution: {
                          position,
                          liberoNumber: liberoPlayer.number,
                          playerNumber,
                          liberoType
                        }
                      },
                      ts: new Date().toISOString(),
                      seq: subEventSeq
                    })
                  }

                  return (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                      <button
                        onClick={() => setCourtLiberoExpanded(!courtLiberoExpanded)}
                        style={{
                          padding: '8px 12px',
                          fontSize: '12px',
                          fontWeight: 600,
                          background: '#FFF8E7',
                          color: '#000',
                          border: '1px solid rgba(0, 0, 0, 0.2)',
                          borderRadius: '6px',
                          cursor: 'pointer',
                          textAlign: 'left',
                          transition: 'all 0.2s',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'space-between',
                          gap: '6px',
                          width: '100%'
                        }}
                        onMouseEnter={(e) => {
                          e.currentTarget.style.background = '#fff4d6'
                          e.currentTarget.style.transform = 'scale(1.02)'
                        }}
                        onMouseLeave={(e) => {
                          e.currentTarget.style.background = '#FFF8E7'
                          e.currentTarget.style.transform = 'scale(1)'
                        }}
                      >
                        <span>Libero</span>
                        <span style={{ fontSize: '14px', lineHeight: '1', transform: courtLiberoExpanded ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
                      </button>
                      {courtLiberoExpanded && (
                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px', marginTop: '4px' }}>
                          {availableLiberos.map(libero => (
                            <button
                              key={libero.number}
                              onClick={() => handleLiberoSelect(libero)}
                              style={{
                                padding: '6px 10px',
                                fontSize: '12px',
                                fontWeight: 700,
                                background: '#fff',
                                color: '#000',
                                border: '1px solid rgba(0, 0, 0, 0.3)',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                transition: 'all 0.2s',
                                minWidth: '50px',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '4px'
                              }}
                              onMouseEnter={(e) => {
                                e.currentTarget.style.background = '#f3f4f6'
                                e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.5)'
                              }}
                              onMouseLeave={(e) => {
                                e.currentTarget.style.background = '#fff'
                                e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.3)'
                              }}
                            >
                              <span>{libero.number}</span>
                              <span style={{ fontSize: '10px', fontWeight: 600, color: '#000' }}>({libero.label})</span>
                            </button>
                          ))}
                        </div>
                      )}
                    </div>
                  )
                })()}
                {/* Libero on court controls - Libero Out and Exchange */}
                {playerActionMenu.isLiberoOnCourt && (() => {
                  const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
                  const liberos = teamPlayers?.filter(p => p.libero && p.libero !== '') || []
                  const hasPointSinceLibero = hasPointSinceLastLiberoExchange(team)
                  const side = (team === 'home' && leftIsHome) || (team === 'away' && !leftIsHome) ? 'left' : 'right'

                  // Libero out disabled if no point since libero exchange
                  const liberoOutDisabled = !hasPointSinceLibero

                  // Exchange libero disabled if only 1 libero or the other libero is unable
                  const liberoOnCourt = playerActionMenu.liberoOnCourt
                  const liberoOnCourtUnable = liberoOnCourt && isLiberoUnable(team, liberoOnCourt.liberoNumber)
                  const otherLibero = liberos.find(p =>
                    String(p.number) !== String(liberoOnCourt?.liberoNumber) &&
                    p.libero !== 'unable' &&
                    (p.libero === 'libero1' || p.libero === 'libero2' || p.libero === 'redesignated')
                  )
                  const otherLiberoUnable = otherLibero && isLiberoUnable(team, otherLibero.number)
                  const exchangeLiberoDisabled = !hasPointSinceLibero || liberos.length < 2 || liberoOnCourtUnable || otherLiberoUnable

                  return (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                      {/* Libero Out button */}
                      <button
                        onClick={() => {
                          setPlayerActionMenu(null)
                          setCourtSubExpanded(false)
                          setCourtLiberoExpanded(false)
                          setCourtSanctionExpanded(false)
                          handleLiberoOut(side)
                        }}
                        disabled={liberoOutDisabled}
                        style={{
                          padding: '8px 12px',
                          fontSize: '12px',
                          fontWeight: 600,
                          background: liberoOutDisabled ? '#888' : '#FFF8E7',
                          color: '#000',
                          border: '1px solid rgba(0, 0, 0, 0.2)',
                          borderRadius: '6px',
                          cursor: liberoOutDisabled ? 'not-allowed' : 'pointer',
                          textAlign: 'center',
                          transition: 'all 0.2s',
                          width: '100%',
                          opacity: liberoOutDisabled ? 0.5 : 1
                        }}
                        onMouseEnter={(e) => {
                          if (!liberoOutDisabled) {
                            e.currentTarget.style.background = '#FFF0C0'
                            e.currentTarget.style.transform = 'scale(1.02)'
                          }
                        }}
                        onMouseLeave={(e) => {
                          if (!liberoOutDisabled) {
                            e.currentTarget.style.background = '#FFF8E7'
                            e.currentTarget.style.transform = 'scale(1)'
                          }
                        }}
                      >
                        Libero Out
                      </button>
                      {/* Exchange Libero button - only if 2 liberos */}
                      {liberos.length >= 2 && (
                        <button
                          onClick={() => {
                            setPlayerActionMenu(null)
                            setCourtSubExpanded(false)
                            setCourtLiberoExpanded(false)
                            setCourtSanctionExpanded(false)
                            handleExchangeLibero(side)
                          }}
                          disabled={exchangeLiberoDisabled}
                          style={{
                            padding: '8px 12px',
                            fontSize: '12px',
                            fontWeight: 600,
                            background: exchangeLiberoDisabled ? '#888' : '#FFF8E7',
                            color: '#000',
                            border: '1px solid rgba(0, 0, 0, 0.2)',
                            borderRadius: '6px',
                            cursor: exchangeLiberoDisabled ? 'not-allowed' : 'pointer',
                            textAlign: 'center',
                            transition: 'all 0.2s',
                            width: '100%',
                            opacity: exchangeLiberoDisabled ? 0.5 : 1
                          }}
                          onMouseEnter={(e) => {
                            if (!exchangeLiberoDisabled) {
                              e.currentTarget.style.background = '#FFF0C0'
                              e.currentTarget.style.transform = 'scale(1.02)'
                            }
                          }}
                          onMouseLeave={(e) => {
                            if (!exchangeLiberoDisabled) {
                              e.currentTarget.style.background = '#FFF8E7'
                              e.currentTarget.style.transform = 'scale(1)'
                            }
                          }}
                        >
                          Exchange Libero
                        </button>
                      )}
                      {/* Unable to play - expandable */}
                      <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                        <button
                          onClick={() => setCourtLiberoUnableExpanded(!courtLiberoUnableExpanded)}
                          style={{
                            padding: '8px 12px',
                            fontSize: '12px',
                            fontWeight: 600,
                            background: '#ef4444',
                            color: '#fff',
                            border: '1px solid rgba(255, 255, 255, 0.2)',
                            borderRadius: '6px',
                            cursor: 'pointer',
                            textAlign: 'left',
                            transition: 'all 0.2s',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'space-between',
                            gap: '6px',
                            width: '100%'
                          }}
                          onMouseEnter={(e) => {
                            e.currentTarget.style.background = '#dc2626'
                            e.currentTarget.style.transform = 'scale(1.02)'
                          }}
                          onMouseLeave={(e) => {
                            e.currentTarget.style.background = '#ef4444'
                            e.currentTarget.style.transform = 'scale(1)'
                          }}
                        >
                          <span>Unable to play</span>
                          <span style={{ fontSize: '14px', lineHeight: '1', transform: courtLiberoUnableExpanded ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
                        </button>
                        {courtLiberoUnableExpanded && (
                          <div style={{ display: 'flex', flexDirection: 'column', gap: '4px', marginTop: '4px' }}>
                            <button
                              onClick={() => {
                                setPlayerActionMenu(null)
                                setCourtSubExpanded(false)
                                setCourtLiberoExpanded(false)
                                setCourtSanctionExpanded(false)
                                setCourtLiberoUnableExpanded(false)
                                setLiberoUnableModal({
                                  team,
                                  liberoNumber: liberoOnCourt.liberoNumber,
                                  liberoType: liberoOnCourt.liberoType,
                                  reason: 'declared',
                                  isOnCourt: true
                                })
                              }}
                              style={{
                                padding: '6px 10px',
                                fontSize: '11px',
                                fontWeight: 600,
                                background: '#f97316',
                                color: '#000',
                                border: '1px solid rgba(0, 0, 0, 0.2)',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'space-between',
                                gap: '8px'
                              }}
                            >
                              <span>Declared unable</span>
                              <span style={{ fontSize: '14px' }}>🗣️</span>
                            </button>
                            <button
                              onClick={() => {
                                setPlayerActionMenu(null)
                                setCourtSubExpanded(false)
                                setCourtLiberoExpanded(false)
                                setCourtSanctionExpanded(false)
                                setCourtLiberoUnableExpanded(false)
                                setLiberoUnableModal({
                                  team,
                                  liberoNumber: liberoOnCourt.liberoNumber,
                                  liberoType: liberoOnCourt.liberoType,
                                  reason: 'injury',
                                  isOnCourt: true
                                })
                              }}
                              style={{
                                padding: '6px 10px',
                                fontSize: '11px',
                                fontWeight: 600,
                                background: 'rgba(239, 68, 68,1)',
                                color: '#ffff',
                                border: '1px solid rgba(239, 68, 68, 0.3)',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'space-between',
                                gap: '8px'
                              }}
                            >
                              <span>Injury / Illness</span>
                              <span style={{ fontSize: '14px' }}>✚</span>
                            </button>
                          </div>
                        )}
                      </div>
                    </div>
                  )
                })()}
                {/* Sanction - expandable */}
                <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                  <button
                    onClick={() => setCourtSanctionExpanded(!courtSanctionExpanded)}
                    style={{
                      padding: '8px 12px',
                      fontSize: '12px',
                      fontWeight: 600,
                      background: '#000',
                      color: '#fff',
                      border: '1px solid rgba(255, 255, 255, 0.2)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      textAlign: 'left',
                      transition: 'all 0.2s',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between',
                      gap: '6px',
                      width: '100%'
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.background = '#1a1a1a'
                      e.currentTarget.style.transform = 'scale(1.02)'
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.background = '#000'
                      e.currentTarget.style.transform = 'scale(1)'
                    }}
                  >
                    <span>Sanction</span>
                    <span style={{ fontSize: '14px', lineHeight: '1', transform: courtSanctionExpanded ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
                  </button>
                  {courtSanctionExpanded && (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px', marginTop: '4px' }}>
                      <button
                        onClick={() => showSanctionConfirmFromMenu('warning')}
                        disabled={!canGetWarning}
                        style={{
                          padding: '6px 10px',
                          fontSize: '11px',
                          fontWeight: 600,
                          background: canGetWarning ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.02)',
                          color: canGetWarning ? 'var(--text)' : 'var(--muted)',
                          border: '1px solid rgba(255, 255, 255, 0.1)',
                          borderRadius: '4px',
                          cursor: canGetWarning ? 'pointer' : 'not-allowed',
                          textAlign: 'left',
                          display: 'flex',
                          alignItems: 'center',
                          gap: '8px',
                          opacity: canGetWarning ? 1 : 0.5
                        }}
                      >
                        <div className="sanction-card yellow" style={{ flexShrink: 0, width: '20px', height: '26px' }}></div>
                        <span>Warning</span>
                      </button>
                      <button
                        onClick={() => showSanctionConfirmFromMenu('penalty')}
                        disabled={!canGetPenalty}
                        style={{
                          padding: '6px 10px',
                          fontSize: '11px',
                          fontWeight: 600,
                          background: canGetPenalty ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.02)',
                          color: canGetPenalty ? 'var(--text)' : 'var(--muted)',
                          border: '1px solid rgba(255, 255, 255, 0.1)',
                          borderRadius: '4px',
                          cursor: canGetPenalty ? 'pointer' : 'not-allowed',
                          textAlign: 'left',
                          display: 'flex',
                          alignItems: 'center',
                          gap: '8px',
                          opacity: canGetPenalty ? 1 : 0.5
                        }}
                      >
                        <div className="sanction-card red" style={{ flexShrink: 0, width: '20px', height: '26px' }}></div>
                        <span>Penalty</span>
                      </button>
                      <button
                        onClick={() => showSanctionConfirmFromMenu('expulsion')}
                        disabled={!canGetExpulsion}
                        style={{
                          padding: '6px 10px',
                          fontSize: '11px',
                          fontWeight: 600,
                          background: canGetExpulsion ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.02)',
                          color: canGetExpulsion ? 'var(--text)' : 'var(--muted)',
                          border: '1px solid rgba(255, 255, 255, 0.1)',
                          borderRadius: '4px',
                          cursor: canGetExpulsion ? 'pointer' : 'not-allowed',
                          textAlign: 'left',
                          display: 'flex',
                          alignItems: 'center',
                          gap: '8px',
                          opacity: canGetExpulsion ? 1 : 0.5
                        }}
                      >
                        <div className="sanction-card combo" style={{ flexShrink: 0, width: '24px', height: '26px' }}></div>
                        <span>Expulsion</span>
                      </button>
                      <button
                        onClick={() => showSanctionConfirmFromMenu('disqualification')}
                        style={{
                          padding: '6px 10px',
                          fontSize: '11px',
                          fontWeight: 600,
                          background: 'rgba(255, 255, 255, 0.05)',
                          color: 'var(--text)',
                          border: '1px solid rgba(255, 255, 255, 0.1)',
                          borderRadius: '4px',
                          cursor: 'pointer',
                          textAlign: 'left',
                          display: 'flex',
                          alignItems: 'center',
                          gap: '8px'
                        }}
                      >
                        <div className="sanction-cards-separate" style={{ flexShrink: 0, display: 'flex', gap: '2px' }}>
                          <div className="sanction-card yellow" style={{ width: '16px', height: '22px' }}></div>
                          <div className="sanction-card red" style={{ width: '16px', height: '22px' }}></div>
                        </div>
                        <span>Disqualification</span>
                      </button>
                    </div>
                  )}
                </div>
                {/* Injury - direct button (NOT shown for liberos on court - they have "Unable to play" menu) */}
                {!playerActionMenu.isLiberoOnCourt && (
                  <button
                    onClick={openInjuryFromMenu}
                    style={{
                      padding: '8px 12px',
                      fontSize: '12px',
                      fontWeight: 600,
                      background: '#dc2626',
                      color: '#fff',
                      border: '1px solid rgba(255, 255, 255, 0.2)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      textAlign: 'left',
                      transition: 'all 0.2s',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between',
                      gap: '6px',
                      width: '100%'
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.background = '#ef4444'
                      e.currentTarget.style.transform = 'scale(1.02)'
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.background = '#dc2626'
                      e.currentTarget.style.transform = 'scale(1)'
                    }}
                  >
                    <span>Injury</span>
                    <span style={{ fontSize: '14px', lineHeight: '1' }}>✚</span>
                  </button>
                )}
              </div>
            </div>
          </>
        )
      })()}

      {substitutionDropdown && (() => {
        const teamKey = substitutionDropdown.team
        const teamData = teamKey === 'home' ? data?.homeTeam : data?.awayTeam

        // Check if substitution is legal
        const isLegal = isSubstitutionLegal(teamKey, substitutionDropdown.playerNumber)

        // Get available substitutes - use exceptional if flagged, otherwise check legal status
        const isExceptional = substitutionDropdown.isExceptional === true
        const availableSubstitutes = isExceptional
          ? getAvailableExceptionalSubstitutes(teamKey, substitutionDropdown.playerNumber)
          : getAvailableSubstitutes(teamKey, substitutionDropdown.playerNumber, !isLegal)

        // Check if player is expelled or disqualified - use stored flags or query events
        const isExpelled = substitutionDropdown.isExpelled || data?.events?.some(e =>
          e.type === 'sanction' &&
          e.payload?.team === teamKey &&
          e.payload?.playerNumber === substitutionDropdown.playerNumber &&
          e.payload?.type === 'expulsion'
        )
        const isDisqualified = substitutionDropdown.isDisqualified || data?.events?.some(e =>
          e.type === 'sanction' &&
          e.payload?.team === teamKey &&
          e.payload?.playerNumber === substitutionDropdown.playerNumber &&
          e.payload?.type === 'disqualification'
        )

        // Get element position - use stored coordinates if available, otherwise try to find element
        // For left side teams, menu opens to the right (use left CSS)
        // For right side teams, menu opens to the left (use right CSS)
        const isRightSide = substitutionDropdown.side === 'right'
        let dropdownStyle
        if (substitutionDropdown.x !== undefined && substitutionDropdown.y !== undefined) {
          dropdownStyle = {
            position: 'fixed',
            left: isRightSide ? undefined : `${substitutionDropdown.x}px`,
            right: isRightSide ? `${window.innerWidth - substitutionDropdown.x}px` : undefined,
            top: `${substitutionDropdown.y}px`,
            transform: 'translateY(-50%)',
            zIndex: 1000
          }
        } else {
          // Fallback: try to find element
          let element = substitutionDropdown.element
          if (!element || !element.getBoundingClientRect) {
            const playerElements = document.querySelectorAll(`.court-player`)
            element = Array.from(playerElements).find(el => {
              const position = el.querySelector('.court-player-position')?.textContent
              return position === substitutionDropdown.position
            })
          }
          const rect = element?.getBoundingClientRect?.()
          dropdownStyle = rect ? {
            position: 'fixed',
            left: isRightSide ? undefined : `${rect.right + 30}px`,
            right: isRightSide ? `${window.innerWidth - rect.left + 30}px` : undefined,
            top: `${rect.top + rect.height / 2}px`,
            transform: 'translateY(-50%)',
            zIndex: 1000
          } : {
            position: 'absolute',
            left: '50%',
            top: '50%',
            transform: 'translate(-50%, -50%)',
            zIndex: 1000
          }
        }

        // Block closing if player is expelled or disqualified - they MUST substitute
        const mustSubstitute = isExpelled || isDisqualified

        return (
          <>
            {/* Backdrop to close dropdown on click outside - disabled if player must substitute */}
            <div
              style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                zIndex: 999,
                background: mustSubstitute ? 'rgba(0, 0, 0, 0.3)' : 'transparent',
                cursor: mustSubstitute ? 'not-allowed' : 'default'
              }}
              onClick={() => {
                if (mustSubstitute) return // Block closing for expelled/disqualified players
                setSubstitutionDropdown(null)
                setLiberoDropdown(null)
                setLiberoInDropdown(null)
                setSanctionDropdown(null)
                setInjuryDropdown(null)
                setPlayerActionMenu(null)
              }}
            />
            {/* Dropdown */}
            <div style={dropdownStyle} className="modal-wrapper-roll-down">
              <div
                data-substitution-dropdown
                style={{
                  background: 'rgba(15, 23, 42, 0.95)',
                  border: '2px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '8px',
                  padding: '8px',
                  minWidth: '80px',
                  maxWidth: '100px',
                  boxShadow: '0 8px 24px rgba(0, 0, 0, 0.5)'
                }}
              >
                <div style={{ marginBottom: '8px', fontSize: '12px', fontWeight: 600, color: 'var(--text)', textAlign: 'center', borderBottom: '1px solid rgba(255, 255, 255, 0.1)', paddingBottom: '8px' }}>
                  {isExceptional ? 'Exceptional Substitution' : 'Substitution'}
                </div>
                <div style={{ marginBottom: '8px', fontSize: '11px', color: 'var(--muted)', textAlign: 'center' }}>
                  # {substitutionDropdown.playerNumber} out
                </div>
                {isExceptional && availableSubstitutes.length > 0 && (
                  <div style={{ marginBottom: '8px', padding: '4px', textAlign: 'center', color: '#facc15', fontSize: '10px', fontWeight: 600, background: 'rgba(234, 179, 8, 0.15)', border: '1px solid rgba(234, 179, 8, 0.3)', borderRadius: '4px' }}>
                    Exceptional
                  </div>
                )}
                {availableSubstitutes.length === 0 ? (
                  <div style={{ padding: '8px', textAlign: 'center', color: 'var(--muted)', fontSize: '11px' }}>
                    No substitutes
                  </div>
                ) : (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                    {availableSubstitutes.map(player => (
                      <button
                        key={player.id}
                        onClick={() => showSubstitutionConfirm(player.number)}
                        style={{
                          padding: '4px 6px',
                          fontSize: '13px',
                          fontWeight: 700,
                          background: 'rgba(255, 255, 255, 0.05)',
                          color: 'var(--accent)',
                          border: '1px solid rgba(255, 255, 255, 0.1)',
                          borderRadius: '6px',
                          cursor: 'pointer',
                          textAlign: 'center',
                          transition: 'all 0.2s',
                          width: '100%',
                          minHeight: '28px',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center'
                        }}
                        onMouseEnter={(e) => {
                          e.currentTarget.style.background = 'rgba(255, 255, 255, 0.15)'
                          e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.3)'
                          e.currentTarget.style.transform = 'scale(1.05)'
                        }}
                        onMouseLeave={(e) => {
                          e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                          e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                          e.currentTarget.style.transform = 'scale(1)'
                        }}
                      >
                        # {player.number}
                      </button>
                    ))}
                  </div>
                )}
                {/* Cancel Sanction button - only shown when player must substitute due to expulsion/disqualification */}
                {mustSubstitute && (
                  <button
                    onClick={async () => {
                      // Find and delete the most recent sanction event for this player
                      const sanctionEvent = data?.events?.filter(e =>
                        e.type === 'sanction' &&
                        e.payload?.team === teamKey &&
                        e.payload?.playerNumber === substitutionDropdown.playerNumber &&
                        (e.payload?.type === 'expulsion' || e.payload?.type === 'disqualification')
                      ).sort((a, b) => b.id - a.id)[0]

                      if (sanctionEvent) {
                        await db.events.delete(sanctionEvent.id)
                      }
                      setSubstitutionDropdown(null)
                    }}
                    style={{
                      marginTop: '8px',
                      padding: '6px 8px',
                      fontSize: '11px',
                      fontWeight: 600,
                      background: 'rgba(239, 68, 68, 0.15)',
                      color: '#ef4444',
                      border: '1px solid rgba(239, 68, 68, 0.3)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      textAlign: 'center',
                      transition: 'all 0.2s',
                      width: '100%'
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.background = 'rgba(239, 68, 68, 0.25)'
                      e.currentTarget.style.borderColor = 'rgba(239, 68, 68, 0.5)'
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.background = 'rgba(239, 68, 68, 0.15)'
                      e.currentTarget.style.borderColor = 'rgba(239, 68, 68, 0.3)'
                    }}
                  >
                    Cancel Sanction
                  </button>
                )}
              </div>
            </div>
          </>
        )
      })()}

      {liberoDropdown && (() => {
        const teamKey = liberoDropdown.team
        const teamPlayers = teamKey === 'home' ? data?.homePlayers : data?.awayPlayers
        const allLiberos = teamPlayers?.filter(p => p.libero && p.libero !== '') || []

        // Check if a libero is already on court
        const liberoOnCourt = getLiberoOnCourt(teamKey)
        // If a libero is already on court, filter out all liberos (can't have two liberos on court)
        // Also filter out liberos that are unable to play
        const liberos = liberoOnCourt ? [] : allLiberos.filter(libero => {
          return !isLiberoUnable(teamKey, libero.number)
        })

        // Get element position - use stored coordinates if available, otherwise try to find element
        // For left side teams, menu opens to the right (use left CSS)
        // For right side teams, menu opens to the left (use right CSS)
        const isRightSide = liberoDropdown.side === 'right'
        let dropdownStyle
        if (liberoDropdown.x !== undefined && liberoDropdown.y !== undefined) {
          dropdownStyle = {
            position: 'fixed',
            left: isRightSide ? undefined : `${liberoDropdown.x}px`,
            right: isRightSide ? `${window.innerWidth - liberoDropdown.x}px` : undefined,
            top: `${liberoDropdown.y}px`,
            transform: 'translateY(-50%)',
            zIndex: 1000
          }
        } else {
          // Fallback: try to find element
          let element = liberoDropdown.element
          if (!element || !element.getBoundingClientRect) {
            const playerElements = document.querySelectorAll(`.court-player`)
            element = Array.from(playerElements).find(el => {
              const position = el.querySelector('.court-player-position')?.textContent
              return position === liberoDropdown.position
            })
          }
          const rect = element?.getBoundingClientRect?.()
          dropdownStyle = rect ? {
            position: 'fixed',
            left: isRightSide ? undefined : `${rect.right + 30}px`,
            right: isRightSide ? `${window.innerWidth - rect.left + 30}px` : undefined,
            top: `${rect.top + rect.height / 2}px`,
            transform: 'translateY(-50%)',
            zIndex: 1000
          } : {
            position: 'absolute',
            left: '50%',
            top: '50%',
            transform: 'translate(-50%, -50%)',
            zIndex: 1000
          }
        }

        return (
          <>
            {/* Backdrop to close dropdown on click outside */}
            <div
              style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                zIndex: 999,
                background: 'transparent'
              }}
              onClick={() => {
                setSubstitutionDropdown(null)
                setLiberoDropdown(null)
                setLiberoInDropdown(null)
                setSanctionDropdown(null)
                setInjuryDropdown(null)
                setPlayerActionMenu(null)
              }}
            />
            {/* Dropdown */}
            <div style={dropdownStyle} className="modal-wrapper-roll-down">
              <div
                data-libero-dropdown
                style={{
                  background: '#FFF8E7',
                  border: '2px solid rgba(0, 0, 0, 0.2)',
                  borderRadius: '8px',
                  padding: '8px',
                  minWidth: '80px',
                  maxWidth: '100px',
                  boxShadow: '0 8px 24px rgba(0, 0, 0, 0.5)'
                }}
              >
                <div style={{ marginBottom: '8px', fontSize: '12px', fontWeight: 600, color: '#000', textAlign: 'center', borderBottom: '1px solid rgba(0, 0, 0, 0.1)', paddingBottom: '8px' }}>
                  Libero
                </div>
                <div style={{ marginBottom: '8px', fontSize: '11px', color: '#666', textAlign: 'center' }}>
                  # {liberoDropdown.playerNumber} out
                </div>
                {liberos.length === 0 ? (
                  <div style={{ padding: '8px', textAlign: 'center', color: '#666', fontSize: '11px' }}>
                    No liberos
                  </div>
                ) : (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                    {liberos.map(player => (
                      <button
                        key={player.id}
                        onClick={() => showLiberoConfirm(player.libero)}
                        style={{
                          padding: '4px 6px',
                          fontSize: '13px',
                          fontWeight: 700,
                          background: 'rgba(0, 0, 0, 0.05)',
                          color: '#000',
                          border: '1px solid rgba(0, 0, 0, 0.1)',
                          borderRadius: '6px',
                          cursor: 'pointer',
                          textAlign: 'center',
                          transition: 'all 0.2s',
                          width: '100%',
                          minHeight: '28px',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          gap: '4px'
                        }}
                        onMouseEnter={(e) => {
                          e.currentTarget.style.background = 'rgba(0, 0, 0, 0.15)'
                          e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.3)'
                          e.currentTarget.style.transform = 'scale(1.05)'
                        }}
                        onMouseLeave={(e) => {
                          e.currentTarget.style.background = 'rgba(0, 0, 0, 0.05)'
                          e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.1)'
                          e.currentTarget.style.transform = 'scale(1)'
                        }}
                      >
                        {player.libero === 'libero1' ? 'L1' : player.libero === 'redesignated' ? 'LR' : 'L2'} # {player.number}
                      </button>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </>
        )
      })()}

      {liberoInDropdown && (() => {
        const teamKey = liberoInDropdown.team
        const { playersOnCourt } = getTeamLineupState(teamKey)

        // Get eligible players (I if not serving, II, III)
        const currentServe = getCurrentServe()
        const teamServes = currentServe === teamKey
        const eligiblePlayers = playersOnCourt.filter(p => {
          if (p.position === 'I') return !teamServes // Position I only if not serving
          return p.position === 'II' || p.position === 'III'
        })

        // Get dropdown position
        // For left side teams, menu opens to the right (use left CSS)
        // For right side teams, menu opens to the left (use right CSS)
        const isRightSide = liberoInDropdown.side === 'right'
        const dropdownStyle = {
          position: 'fixed',
          left: isRightSide ? undefined : `${liberoInDropdown.x}px`,
          right: isRightSide ? `${window.innerWidth - liberoInDropdown.x}px` : undefined,
          top: `${liberoInDropdown.y}px`,
          transform: 'translateX(-50%)',
          zIndex: 1000
        }

        return (
          <>
            {/* Backdrop to close dropdown on click outside */}
            <div
              style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                zIndex: 999,
                background: 'transparent'
              }}
              onClick={() => {
                setLiberoInDropdown(null)
                setSubstitutionDropdown(null)
                setLiberoDropdown(null)
                setSanctionDropdown(null)
                setInjuryDropdown(null)
                setPlayerActionMenu(null)
              }}
            />
            {/* Dropdown */}
            <div style={dropdownStyle} className="modal-wrapper-roll-down">
              <div
                data-libero-in-dropdown
                style={{
                  background: '#FFF8E7',
                  border: '2px solid rgba(0, 0, 0, 0.2)',
                  borderRadius: '8px',
                  padding: '8px',
                  minWidth: '120px',
                  maxWidth: '150px',
                  boxShadow: '0 8px 24px rgba(0, 0, 0, 0.5)'
                }}
              >
                <div style={{ marginBottom: '8px', fontSize: '12px', fontWeight: 600, color: '#000', textAlign: 'center', borderBottom: '1px solid rgba(0, 0, 0, 0.1)', paddingBottom: '8px' }}>
                  Libero In
                </div>
                {eligiblePlayers.length === 0 ? (
                  <div style={{ padding: '8px', textAlign: 'center', color: '#666', fontSize: '11px' }}>
                    No eligible players
                  </div>
                ) : (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                    {eligiblePlayers.map(player => (
                      <button
                        key={`${player.position}-${player.number}`}
                        onClick={() => handleLiberoInPlayerSelect(player.position, player.number)}
                        style={{
                          padding: '6px 8px',
                          fontSize: '12px',
                          fontWeight: 700,
                          background: 'rgba(0, 0, 0, 0.05)',
                          color: '#000',
                          border: '1px solid rgba(0, 0, 0, 0.1)',
                          borderRadius: '6px',
                          cursor: 'pointer',
                          textAlign: 'center',
                          transition: 'all 0.2s',
                          width: '100%',
                          minHeight: '32px',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          gap: '4px'
                        }}
                        onMouseEnter={(e) => {
                          e.currentTarget.style.background = 'rgba(0, 0, 0, 0.15)'
                          e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.3)'
                          e.currentTarget.style.transform = 'scale(1.05)'
                        }}
                        onMouseLeave={(e) => {
                          e.currentTarget.style.background = 'rgba(0, 0, 0, 0.05)'
                          e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.1)'
                          e.currentTarget.style.transform = 'scale(1)'
                        }}
                      >
                        <span style={{ fontSize: '10px', opacity: 0.7 }}>Pos {player.position}:</span>
                        <span>#{player.number}</span>
                      </button>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </>
        )
      })()}

      {sanctionDropdown && (() => {
        // Get element position - use stored coordinates if available
        // For left side teams, menu opens to the right (use left CSS)
        // For right side teams, menu opens to the left (use right CSS)
        const isRightSide = sanctionDropdown.side === 'right'
        let dropdownStyle
        if (sanctionDropdown.x !== undefined && sanctionDropdown.y !== undefined) {
          dropdownStyle = {
            position: 'fixed',
            left: isRightSide ? undefined : `${sanctionDropdown.x}px`,
            right: isRightSide ? `${window.innerWidth - sanctionDropdown.x}px` : undefined,
            top: `${sanctionDropdown.y}px`,
            transform: 'translateY(-50%)',
            zIndex: 1000
          }
        } else {
          const rect = sanctionDropdown.element?.getBoundingClientRect?.()
          dropdownStyle = rect ? {
            position: 'fixed',
            left: isRightSide ? undefined : `${rect.right + 30}px`,
            right: isRightSide ? `${window.innerWidth - rect.left + 30}px` : undefined,
            top: `${rect.top + rect.height / 2}px`,
            transform: 'translateY(-50%)',
            zIndex: 1000
          } : {
            position: 'absolute',
            left: '50%',
            top: '50%',
            transform: 'translate(-50%, -50%)',
            zIndex: 1000
          }
        }

        return (
          <>
            {/* Backdrop to close dropdown on click outside */}
            <div
              style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                zIndex: 999,
                background: 'transparent'
              }}
              onClick={cancelSanction}
            />
            {/* Dropdown */}
            <div style={dropdownStyle} className="modal-wrapper-roll-up">
              <div
                data-sanction-dropdown
                style={{
                  background: 'rgba(15, 23, 42, 0.95)',
                  border: '2px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '8px',
                  padding: '8px',
                  minWidth: '160px',
                  boxShadow: '0 8px 24px rgba(0, 0, 0, 0.5)'
                }}
              >
                <div style={{ marginBottom: '8px', fontSize: '11px', fontWeight: 600, color: 'var(--text)', textAlign: 'center', borderBottom: '1px solid rgba(255, 255, 255, 0.1)', paddingBottom: '6px' }}>
                  {(() => {
                    const { type, playerNumber, role } = sanctionDropdown
                    if (type === 'official') {
                      // Map role to abbreviation
                      const roleAbbr = role === 'Coach' ? 'C' :
                        role === 'Assistant Coach 1' ? 'AC1' :
                          role === 'Assistant Coach 2' ? 'AC2' :
                            role === 'Physiotherapist' ? 'P' :
                              role === 'Medic' ? 'M' : role
                      return `Sanction for ${roleAbbr}`
                    } else if (type === 'bench' && playerNumber) {
                      return `Actions for # ${playerNumber}`
                    } else if (playerNumber) {
                      return `Sanction for ${playerNumber}`
                    } else {
                      return 'Sanction'
                    }
                  })()}
                </div>
                <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                  {(() => {
                    const teamKey = sanctionDropdown.team
                    const playerNumber = sanctionDropdown.playerNumber
                    const teamWarning = teamHasFormalWarning(teamKey)

                    // Check if player has each specific sanction type (for back-sanctioning rules)
                    const hasWarning = playerNumber ? playerHasSanctionType(teamKey, playerNumber, 'warning') : false
                    const hasPenalty = playerNumber ? playerHasSanctionType(teamKey, playerNumber, 'penalty') : false
                    const hasExpulsion = playerNumber ? playerHasSanctionType(teamKey, playerNumber, 'expulsion') : false
                    const hasDisqualification = playerNumber ? playerHasSanctionType(teamKey, playerNumber, 'disqualification') : false

                    // Determine which sanctions are available
                    // Rule: A player cannot get the same sanction type twice
                    // Exception: Warning can only be given if team hasn't been warned (player can have other sanctions)
                    const canGetWarning = !hasWarning && !teamWarning
                    // Penalty: can be given if player doesn't already have a penalty (back-sanctioning allowed)
                    const canGetPenalty = !hasPenalty
                    // Expulsion: can be given if player doesn't already have an expulsion (back-sanctioning allowed)
                    const canGetExpulsion = !hasExpulsion
                    // Disqualification: can be given if player doesn't already have a disqualification (back-sanctioning allowed)
                    const canGetDisqualification = !hasDisqualification

                    return (
                      <>
                        <button
                          onClick={() => showSanctionConfirm('warning')}
                          disabled={!canGetWarning}
                          style={{
                            padding: '4px 8px',
                            fontSize: '11px',
                            fontWeight: 600,
                            background: canGetWarning ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.02)',
                            color: canGetWarning ? 'var(--text)' : 'var(--muted)',
                            border: '1px solid rgba(255, 255, 255, 0.1)',
                            borderRadius: '4px',
                            cursor: canGetWarning ? 'pointer' : 'not-allowed',
                            textAlign: 'left',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '8px',
                            transition: 'all 0.2s',
                            opacity: canGetWarning ? 1 : 0.5
                          }}
                          onMouseEnter={(e) => {
                            if (canGetWarning) {
                              e.currentTarget.style.background = 'rgba(255, 255, 255, 0.15)'
                              e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.3)'
                            }
                          }}
                          onMouseLeave={(e) => {
                            if (canGetWarning) {
                              e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                              e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                            }
                          }}
                        >
                          <div className="sanction-card yellow" style={{ flexShrink: 0, width: '24px', height: '32px' }}></div>
                          <span>Warning{!canGetWarning && (teamWarning ? ' (Team has warning)' : ' (Already sanctioned)')}</span>
                        </button>
                        <button
                          onClick={() => showSanctionConfirm('penalty')}
                          disabled={!canGetPenalty}
                          style={{
                            padding: '4px 8px',
                            fontSize: '11px',
                            fontWeight: 600,
                            background: canGetPenalty ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.02)',
                            color: canGetPenalty ? 'var(--text)' : 'var(--muted)',
                            border: '1px solid rgba(255, 255, 255, 0.1)',
                            borderRadius: '4px',
                            cursor: canGetPenalty ? 'pointer' : 'not-allowed',
                            textAlign: 'left',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '8px',
                            transition: 'all 0.2s',
                            opacity: canGetPenalty ? 1 : 0.5
                          }}
                          onMouseEnter={(e) => {
                            if (canGetPenalty) {
                              e.currentTarget.style.background = 'rgba(255, 255, 255, 0.15)'
                              e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.3)'
                            }
                          }}
                          onMouseLeave={(e) => {
                            if (canGetPenalty) {
                              e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                              e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                            }
                          }}
                        >
                          <div className="sanction-card red" style={{ flexShrink: 0, width: '24px', height: '32px' }}></div>
                          <span>Penalty{!canGetPenalty && ' (Already sanctioned)'}</span>
                        </button>
                        <button
                          onClick={() => showSanctionConfirm('expulsion')}
                          disabled={!canGetExpulsion}
                          style={{
                            padding: '4px 8px',
                            fontSize: '11px',
                            fontWeight: 600,
                            background: canGetExpulsion ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.02)',
                            color: canGetExpulsion ? 'var(--text)' : 'var(--muted)',
                            border: '1px solid rgba(255, 255, 255, 0.1)',
                            borderRadius: '4px',
                            cursor: canGetExpulsion ? 'pointer' : 'not-allowed',
                            textAlign: 'left',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '8px',
                            transition: 'all 0.2s',
                            opacity: canGetExpulsion ? 1 : 0.5
                          }}
                          onMouseEnter={(e) => {
                            if (canGetExpulsion) {
                              e.currentTarget.style.background = 'rgba(255, 255, 255, 0.15)'
                              e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.3)'
                            }
                          }}
                          onMouseLeave={(e) => {
                            if (canGetExpulsion) {
                              e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                              e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                            }
                          }}
                        >
                          <div className="sanction-card combo" style={{ flexShrink: 0, width: '28px', height: '32px' }}></div>
                          <span>Expulsion{!canGetExpulsion && ' (Already sanctioned)'}</span>
                        </button>
                        <button
                          onClick={() => showSanctionConfirm('disqualification')}
                          disabled={false}
                          style={{
                            padding: '4px 8px',
                            fontSize: '11px',
                            fontWeight: 600,
                            background: 'rgba(255, 255, 255, 0.05)',
                            color: 'var(--text)',
                            border: '1px solid rgba(255, 255, 255, 0.1)',
                            borderRadius: '4px',
                            cursor: 'pointer',
                            textAlign: 'left',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '8px',
                            transition: 'all 0.2s'
                          }}
                          onMouseEnter={(e) => {
                            e.currentTarget.style.background = 'rgba(255, 255, 255, 0.15)'
                            e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.3)'
                          }}
                          onMouseLeave={(e) => {
                            e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                            e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                          }}
                        >
                          <div className="sanction-cards-separate" style={{ flexShrink: 0 }}>
                            <div className="sanction-card yellow" style={{ width: '20px', height: '28px' }}></div>
                            <div className="sanction-card red" style={{ width: '20px', height: '28px' }}></div>
                          </div>
                          <span>Disqualification</span>
                        </button>
                      </>
                    )
                  })()}
                </div>
              </div>
            </div>
          </>
        )
      })()}

      {/* Bench Player Action Menu */}
      {benchPlayerActionMenu && (() => {
        // Get element position - use stored coordinates if available
        // For left side teams, menu opens to the right (use left CSS)
        // For right side teams, menu opens to the left (use right CSS)
        const isRightSide = benchPlayerActionMenu.side === 'right'
        let menuStyle
        if (benchPlayerActionMenu.x !== undefined && benchPlayerActionMenu.y !== undefined) {
          menuStyle = {
            position: 'fixed',
            left: isRightSide ? undefined : `${benchPlayerActionMenu.x}px`,
            right: isRightSide ? `${window.innerWidth - benchPlayerActionMenu.x}px` : undefined,
            top: `${benchPlayerActionMenu.y}px`,
            transform: 'translateY(-50%)',
            zIndex: 1000
          }
        } else {
          const rect = benchPlayerActionMenu.element?.getBoundingClientRect?.()
          menuStyle = rect ? {
            position: 'fixed',
            left: isRightSide ? undefined : `${rect.right + 30}px`,
            right: isRightSide ? `${window.innerWidth - rect.left + 30}px` : undefined,
            top: `${rect.top + rect.height / 2}px`,
            transform: 'translateY(-50%)',
            zIndex: 1000
          } : {
            position: 'absolute',
            left: '50%',
            top: '50%',
            transform: 'translate(-50%, -50%)',
            zIndex: 1000
          }
        }

        const { team, playerNumber, canSubstitute, courtPlayerToSwapWith, neverPlayed } = benchPlayerActionMenu

        // For "never played" bench players, get available court players to substitute
        // Filter out liberos - cannot substitute for a libero on court
        const availableCourtPlayers = []
        if (neverPlayed && canSubstitute) {
          const currentLineup = getCurrentLineup(team)
          const liberoOnCourt = getLiberoOnCourt(team)
          const teamPlayers = team === 'home' ? data?.homePlayers : data?.awayPlayers
          if (currentLineup) {
            Object.entries(currentLineup).forEach(([pos, num]) => {
              if (num) {
                // Check if this court player can be substituted
                const canBeSub = canPlayerBeSubstituted(team, num)
                // Check if this is a libero (cannot substitute for libero)
                const isLibero = teamPlayers?.some(p =>
                  String(p.number) === String(num) && (p.role === 'libero1' || p.role === 'libero2')
                )
                // Also check if current libero is on court at this position
                const isLiberoOnCourt = liberoOnCourt && String(liberoOnCourt.liberoNumber) === String(num)
                if (canBeSub && !isLibero && !isLiberoOnCourt) {
                  availableCourtPlayers.push({ position: pos, number: num })
                }
              }
            })
          }
        }


        return (
          <>
            {/* Backdrop to close menu on click outside */}
            <div
              style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                zIndex: 999,
                background: 'transparent'
              }}
              onClick={() => { setBenchPlayerActionMenu(null); setBenchSubExpanded(false); setBenchSanctionExpanded(false) }}
            />
            {/* Action Menu */}
            <div style={menuStyle} className="modal-wrapper-roll-down">
              <div
                data-bench-player-action-menu
                style={{
                  background: 'rgba(15, 23, 42, 0.95)',
                  border: '2px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '8px',
                  padding: '8px',
                  minWidth: '140px',
                  boxShadow: '0 8px 24px rgba(0, 0, 0, 0.5)',
                  display: 'flex',
                  flexDirection: 'column',
                  gap: '6px'
                }}
              >
                <div style={{ fontSize: '11px', fontWeight: 600, color: 'var(--muted)', textAlign: 'center', marginBottom: '4px' }}>
                  # {playerNumber}
                </div>
                {/* Substitution Button - for returning players */}
                {courtPlayerToSwapWith && (
                  <button
                    onClick={() => {
                      if (canSubstitute && courtPlayerToSwapWith) {
                        setBenchPlayerActionMenu(null)
                        // Go directly to substitution confirmation modal
                        setSubstitutionConfirm({
                          team,
                          position: courtPlayerToSwapWith.position,
                          playerOut: courtPlayerToSwapWith.number,
                          playerIn: playerNumber
                        })
                      }
                    }}
                    disabled={!canSubstitute}
                    style={{
                      padding: '8px 12px',
                      fontSize: '12px',
                      fontWeight: 600,
                      background: canSubstitute ? 'linear-gradient(135deg, #22c55e, #16a34a)' : 'rgba(255, 255, 255, 0.05)',
                      color: canSubstitute ? '#000' : 'var(--muted)',
                      border: canSubstitute ? '1px solid rgba(0, 0, 0, 0.2)' : '1px solid rgba(255, 255, 255, 0.1)',
                      borderRadius: '6px',
                      cursor: canSubstitute ? 'pointer' : 'not-allowed',
                      textAlign: 'left',
                      transition: 'all 0.2s',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between',
                      gap: '6px',
                      width: '100%',
                      opacity: canSubstitute ? 1 : 0.5
                    }}
                    onMouseEnter={(e) => {
                      if (canSubstitute) {
                        e.currentTarget.style.background = 'linear-gradient(135deg, #4ade80, #22c55e)'
                        e.currentTarget.style.transform = 'scale(1.02)'
                      }
                    }}
                    onMouseLeave={(e) => {
                      if (canSubstitute) {
                        e.currentTarget.style.background = 'linear-gradient(135deg, #22c55e, #16a34a)'
                        e.currentTarget.style.transform = 'scale(1)'
                      }
                    }}
                  >
                    <span>Substitution</span>
                    <span style={{ fontSize: '14px', lineHeight: '1' }}>⇅</span>
                  </button>
                )}
                {/* Substitution button with expandable list - for players who never played */}
                {neverPlayed && availableCourtPlayers.length > 0 && (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                    <button
                      onClick={() => setBenchSubExpanded(!benchSubExpanded)}
                      style={{
                        padding: '8px 12px',
                        fontSize: '12px',
                        fontWeight: 600,
                        background: 'linear-gradient(135deg, #22c55e, #16a34a)',
                        color: '#000',
                        border: '1px solid rgba(0, 0, 0, 0.2)',
                        borderRadius: '6px',
                        cursor: 'pointer',
                        textAlign: 'left',
                        transition: 'all 0.2s',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        gap: '6px',
                        width: '100%'
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.background = 'linear-gradient(135deg, #4ade80, #22c55e)'
                        e.currentTarget.style.transform = 'scale(1.02)'
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.background = 'linear-gradient(135deg, #22c55e, #16a34a)'
                        e.currentTarget.style.transform = 'scale(1)'
                      }}
                    >
                      <span>Substitution</span>
                      <span style={{ fontSize: '14px', lineHeight: '1', transform: benchSubExpanded ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
                    </button>
                    {benchSubExpanded && (
                      <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px', marginTop: '4px' }}>
                        {availableCourtPlayers.map(cp => (
                          <button
                            key={cp.position}
                            onClick={() => {
                              setBenchPlayerActionMenu(null)
                              setBenchSubExpanded(false)
                              // Go directly to substitution confirmation modal
                              setSubstitutionConfirm({
                                team,
                                position: cp.position,
                                playerOut: cp.number,
                                playerIn: playerNumber
                              })
                            }}
                            style={{
                              padding: '6px 10px',
                              fontSize: '12px',
                              fontWeight: 700,
                              background: 'rgba(34, 197, 94, 0.2)',
                              color: '#22c55e',
                              border: '1px solid rgba(34, 197, 94, 0.4)',
                              borderRadius: '4px',
                              cursor: 'pointer',
                              transition: 'all 0.2s',
                              minWidth: '40px'
                            }}
                            onMouseEnter={(e) => {
                              e.currentTarget.style.background = 'rgba(34, 197, 94, 0.4)'
                              e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.6)'
                            }}
                            onMouseLeave={(e) => {
                              e.currentTarget.style.background = 'rgba(34, 197, 94, 0.2)'
                              e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.4)'
                            }}
                          >
                            {cp.number}
                          </button>
                        ))}
                      </div>
                    )}
                  </div>
                )}
                {/* Sanction - expandable */}
                {(() => {
                  // Get sanction availability for bench player
                  const teamWarning = teamHasFormalWarning(team)
                  const hasWarning = playerHasSanctionType(team, playerNumber, 'warning')
                  const hasPenalty = playerHasSanctionType(team, playerNumber, 'penalty')
                  const hasExpulsion = playerHasSanctionType(team, playerNumber, 'expulsion')
                  const canGetWarning = !hasWarning && !teamWarning
                  const canGetPenalty = !hasPenalty
                  const canGetExpulsion = !hasExpulsion

                  const showSanctionConfirmFromBenchMenu = (sanctionType) => {
                    setBenchPlayerActionMenu(null)
                    setBenchSubExpanded(false)
                    setBenchSanctionExpanded(false)
                    setSanctionConfirmModal({
                      team,
                      type: 'bench',
                      playerNumber,
                      sanctionType
                    })
                  }

                  return (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                      <button
                        onClick={() => setBenchSanctionExpanded(!benchSanctionExpanded)}
                        style={{
                          padding: '8px 12px',
                          fontSize: '12px',
                          fontWeight: 600,
                          background: '#000',
                          color: '#fff',
                          border: '1px solid rgba(255, 255, 255, 0.2)',
                          borderRadius: '6px',
                          cursor: 'pointer',
                          textAlign: 'left',
                          transition: 'all 0.2s',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'space-between',
                          gap: '6px',
                          width: '100%'
                        }}
                        onMouseEnter={(e) => {
                          e.currentTarget.style.background = '#1a1a1a'
                          e.currentTarget.style.transform = 'scale(1.02)'
                        }}
                        onMouseLeave={(e) => {
                          e.currentTarget.style.background = '#000'
                          e.currentTarget.style.transform = 'scale(1)'
                        }}
                      >
                        <span>Sanction</span>
                        <span style={{ fontSize: '14px', lineHeight: '1', transform: benchSanctionExpanded ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
                      </button>
                      {benchSanctionExpanded && (
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '4px', marginTop: '4px' }}>
                          <button
                            onClick={() => showSanctionConfirmFromBenchMenu('warning')}
                            disabled={!canGetWarning}
                            style={{
                              padding: '6px 10px',
                              fontSize: '11px',
                              fontWeight: 600,
                              background: canGetWarning ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.02)',
                              color: canGetWarning ? 'var(--text)' : 'var(--muted)',
                              border: '1px solid rgba(255, 255, 255, 0.1)',
                              borderRadius: '4px',
                              cursor: canGetWarning ? 'pointer' : 'not-allowed',
                              textAlign: 'left',
                              display: 'flex',
                              alignItems: 'center',
                              gap: '8px',
                              opacity: canGetWarning ? 1 : 0.5
                            }}
                          >
                            <div className="sanction-card yellow" style={{ flexShrink: 0, width: '20px', height: '26px' }}></div>
                            <span>Warning</span>
                          </button>
                          <button
                            onClick={() => showSanctionConfirmFromBenchMenu('penalty')}
                            disabled={!canGetPenalty}
                            style={{
                              padding: '6px 10px',
                              fontSize: '11px',
                              fontWeight: 600,
                              background: canGetPenalty ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.02)',
                              color: canGetPenalty ? 'var(--text)' : 'var(--muted)',
                              border: '1px solid rgba(255, 255, 255, 0.1)',
                              borderRadius: '4px',
                              cursor: canGetPenalty ? 'pointer' : 'not-allowed',
                              textAlign: 'left',
                              display: 'flex',
                              alignItems: 'center',
                              gap: '8px',
                              opacity: canGetPenalty ? 1 : 0.5
                            }}
                          >
                            <div className="sanction-card red" style={{ flexShrink: 0, width: '20px', height: '26px' }}></div>
                            <span>Penalty</span>
                          </button>
                          <button
                            onClick={() => showSanctionConfirmFromBenchMenu('expulsion')}
                            disabled={!canGetExpulsion}
                            style={{
                              padding: '6px 10px',
                              fontSize: '11px',
                              fontWeight: 600,
                              background: canGetExpulsion ? 'rgba(255, 255, 255, 0.05)' : 'rgba(255, 255, 255, 0.02)',
                              color: canGetExpulsion ? 'var(--text)' : 'var(--muted)',
                              border: '1px solid rgba(255, 255, 255, 0.1)',
                              borderRadius: '4px',
                              cursor: canGetExpulsion ? 'pointer' : 'not-allowed',
                              textAlign: 'left',
                              display: 'flex',
                              alignItems: 'center',
                              gap: '8px',
                              opacity: canGetExpulsion ? 1 : 0.5
                            }}
                          >
                            <div className="sanction-card combo" style={{ flexShrink: 0, width: '24px', height: '26px' }}></div>
                            <span>Expulsion</span>
                          </button>
                          <button
                            onClick={() => showSanctionConfirmFromBenchMenu('disqualification')}
                            style={{
                              padding: '6px 10px',
                              fontSize: '11px',
                              fontWeight: 600,
                              background: 'rgba(255, 255, 255, 0.05)',
                              color: 'var(--text)',
                              border: '1px solid rgba(255, 255, 255, 0.1)',
                              borderRadius: '4px',
                              cursor: 'pointer',
                              textAlign: 'left',
                              display: 'flex',
                              alignItems: 'center',
                              gap: '8px'
                            }}
                          >
                            <div className="sanction-cards-separate" style={{ flexShrink: 0, display: 'flex', gap: '2px' }}>
                              <div className="sanction-card yellow" style={{ width: '16px', height: '22px' }}></div>
                              <div className="sanction-card red" style={{ width: '16px', height: '22px' }}></div>
                            </div>
                            <span>Disqualification</span>
                          </button>
                        </div>
                      )}
                    </div>
                  )
                })()}
                {/* Injury Button */}
                <button
                  onClick={async () => {
                    // For bench player injury, just add a remark (no substitution needed since they're not on court)
                    const remarks = data?.match?.remarks || ''
                    const now = new Date()
                    const timestamp = `${String(now.getUTCHours()).padStart(2, '0')}:${String(now.getUTCMinutes()).padStart(2, '0')}`
                    const teamName = team === 'home' ? (data?.homeTeam?.name || 'Home') : (data?.awayTeam?.name || 'Away')
                    const newRemark = `[${timestamp}] Injury: ${teamName} #${playerNumber} (bench)`
                    const updatedRemarks = remarks ? `${remarks}\n${newRemark}` : newRemark

                    await db.matches.update(matchId, { remarks: updatedRemarks })
                    setBenchPlayerActionMenu(null)
                    setConfirmMessage(`Injury recorded for #${playerNumber}`)
                  }}
                  style={{
                    padding: '8px 12px',
                    fontSize: '12px',
                    fontWeight: 600,
                    background: '#dc2626',
                    color: '#fff',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    borderRadius: '6px',
                    cursor: 'pointer',
                    textAlign: 'left',
                    transition: 'all 0.2s',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    gap: '6px',
                    width: '100%'
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.background = '#ef4444'
                    e.currentTarget.style.transform = 'scale(1.02)'
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.background = '#dc2626'
                    e.currentTarget.style.transform = 'scale(1)'
                  }}
                >
                  <span>Injury</span>
                  <span style={{ fontSize: '14px', lineHeight: '1' }}>✚</span>
                </button>
              </div>
            </div>
          </>
        )
      })()}


      {injuryDropdown && (() => {
        // Get element position - use stored coordinates if available
        // For left side teams, menu opens to the right (use left CSS)
        // For right side teams, menu opens to the left (use right CSS)
        const isRightSide = injuryDropdown.side === 'right'
        let dropdownStyle
        if (injuryDropdown.x !== undefined && injuryDropdown.y !== undefined) {
          dropdownStyle = {
            position: 'fixed',
            left: isRightSide ? undefined : `${injuryDropdown.x}px`,
            right: isRightSide ? `${window.innerWidth - injuryDropdown.x}px` : undefined,
            top: `${injuryDropdown.y}px`,
            transform: 'translateY(-50%)',
            zIndex: 1000
          }
        } else {
          const rect = injuryDropdown.element?.getBoundingClientRect?.()
          dropdownStyle = rect ? {
            position: 'fixed',
            left: isRightSide ? undefined : `${rect.right + 30}px`,
            right: isRightSide ? `${window.innerWidth - rect.left + 30}px` : undefined,
            top: `${rect.top + rect.height / 2}px`,
            transform: 'translateY(-50%)',
            zIndex: 1000
          } : {
            position: 'absolute',
            left: '50%',
            top: '50%',
            transform: 'translate(-50%, -50%)',
            zIndex: 1000
          }
        }

        return (
          <>
            {/* Backdrop to close dropdown on click outside */}
            <div
              style={{
                position: 'fixed',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                zIndex: 999,
                background: 'transparent'
              }}
              onClick={() => {
                setSubstitutionDropdown(null)
                setLiberoDropdown(null)
                setLiberoInDropdown(null)
                setSanctionDropdown(null)
                setInjuryDropdown(null)
                setPlayerActionMenu(null)
              }}
            />
            {/* Dropdown */}
            <div style={dropdownStyle} className="modal-wrapper-roll-up">
              <div
                data-injury-dropdown
                style={{
                  background: 'rgba(15, 23, 42, 0.95)',
                  border: '2px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '8px',
                  padding: '8px',
                  minWidth: '120px',
                  boxShadow: '0 8px 24px rgba(0, 0, 0, 0.5)'
                }}
              >
                <div style={{ marginBottom: '8px', fontSize: '11px', fontWeight: 600, color: 'var(--text)', textAlign: 'center', borderBottom: '1px solid rgba(255, 255, 255, 0.1)', paddingBottom: '6px' }}>
                  Injury
                </div>
                <div style={{ marginBottom: '8px', fontSize: '11px', color: 'var(--muted)', textAlign: 'center' }}>
                  # {injuryDropdown.playerNumber}
                </div>
                <button
                  onClick={handleInjury}
                  style={{
                    padding: '6px 12px',
                    fontSize: '11px',
                    fontWeight: 600,
                    background: 'rgba(239, 68, 68, 0.2)',
                    color: '#f87171',
                    border: '1px solid rgba(239, 68, 68, 0.4)',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    textAlign: 'center',
                    width: '100%',
                    transition: 'all 0.2s'
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.background = 'rgba(239, 68, 68, 0.3)'
                    e.currentTarget.style.borderColor = 'rgba(239, 68, 68, 0.6)'
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.background = 'rgba(239, 68, 68, 0.2)'
                    e.currentTarget.style.borderColor = 'rgba(239, 68, 68, 0.4)'
                  }}
                >
                  Substitute
                </button>
              </div>
            </div>
          </>
        )
      })()}

      {/* Keyboard Shortcuts Configuration Modal */}
      {keybindingsModalOpen && (
        <Modal
          title={t('scoreboard.menu.keyboardShortcuts')}
          open={true}
          onClose={() => {
            setKeybindingsModalOpen(false)
            setEditingKey(null)
          }}
          width={500}
        >
          <div style={{ padding: '16px', maxHeight: '70vh', overflowY: 'auto' }}>
            <p style={{ marginBottom: '16px', fontSize: '12px', color: 'rgba(255,255,255,0.6)' }}>
              {t('scoreboard.keybindings.instruction', 'Click on a key to change it. Press the new key to assign, or Escape to cancel.')}
            </p>
            {[
              { key: 'pointLeft', labelKey: 'scoreboard.keybindings.pointLeftTeam', descKey: 'scoreboard.keybindings.pointLeftTeamDesc', label: 'Point Left Team', description: 'Award point to left team' },
              { key: 'pointRight', labelKey: 'scoreboard.keybindings.pointRightTeam', descKey: 'scoreboard.keybindings.pointRightTeamDesc', label: 'Point Right Team', description: 'Award point to right team' },
              { key: 'timeoutLeft', labelKey: 'scoreboard.keybindings.timeoutLeftTeam', descKey: 'scoreboard.keybindings.timeoutLeftTeamDesc', label: 'Timeout Left Team', description: 'Call timeout for left team' },
              { key: 'timeoutRight', labelKey: 'scoreboard.keybindings.timeoutRightTeam', descKey: 'scoreboard.keybindings.timeoutRightTeamDesc', label: 'Timeout Right Team', description: 'Call timeout for right team' },
              { key: 'exchangeLiberoLeft', labelKey: 'scoreboard.keybindings.exchangeLiberoLeft', descKey: 'scoreboard.keybindings.exchangeLiberoLeftDesc', label: 'Exchange Libero Left', description: 'Exchange L1/L2 for left team' },
              { key: 'exchangeLiberoRight', labelKey: 'scoreboard.keybindings.exchangeLiberoRight', descKey: 'scoreboard.keybindings.exchangeLiberoRightDesc', label: 'Exchange Libero Right', description: 'Exchange L1/L2 for right team' },
              { key: 'undo', labelKey: 'scoreboard.keybindings.undo', descKey: 'scoreboard.keybindings.undoDesc', label: 'Undo', description: 'Undo last action' },
              { key: 'startRally', labelKey: 'scoreboard.keybindings.startRallyConfirm', descKey: 'scoreboard.keybindings.startRallyConfirmDesc', label: 'Start Rally / Confirm', description: 'Start rally or confirm modal' },
              { key: 'cancel', labelKey: 'scoreboard.keybindings.cancelClose', descKey: 'scoreboard.keybindings.cancelCloseDesc', label: 'Cancel / Close', description: 'Cancel or close menus' }
            ].map(({ key, labelKey, descKey, label, description }) => (
              <div
                key={key}
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'space-between',
                  padding: '10px 12px',
                  background: editingKey === key ? 'rgba(59, 130, 246, 0.2)' : 'rgba(255, 255, 255, 0.05)',
                  borderRadius: '6px',
                  marginBottom: '8px',
                  border: editingKey === key ? '1px solid rgba(59, 130, 246, 0.5)' : '1px solid transparent'
                }}
              >
                <div style={{ flex: 1 }}>
                  <div style={{ fontWeight: 600, fontSize: '13px' }}>{t(labelKey, label)}</div>
                  <div style={{ fontSize: '11px', color: 'rgba(255,255,255,0.5)' }}>{t(descKey, description)}</div>
                </div>
                <button
                  onClick={() => {
                    if (editingKey === key) {
                      setEditingKey(null)
                    } else {
                      setEditingKey(key)
                      // Listen for next keypress
                      const handleKeyCapture = (e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        if (e.key === 'Escape') {
                          setEditingKey(null)
                        } else {
                          const newBindings = { ...keyBindings, [key]: e.key }
                          setKeyBindings(newBindings)
                          localStorage.setItem('keyBindings', JSON.stringify(newBindings))
                          setEditingKey(null)
                        }
                        window.removeEventListener('keydown', handleKeyCapture, true)
                      }
                      window.addEventListener('keydown', handleKeyCapture, true)
                    }
                  }}
                  style={{
                    padding: '6px 12px',
                    fontSize: '12px',
                    fontWeight: 600,
                    background: editingKey === key ? '#3b82f6' : 'rgba(255, 255, 255, 0.1)',
                    color: editingKey === key ? '#fff' : 'var(--text)',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    minWidth: '80px',
                    textAlign: 'center'
                  }}
                >
                  {editingKey === key ? t('scoreboard.keybindings.pressKey', 'Press key...') : (
                    keyBindings[key] === ' ' ? 'Space' :
                      keyBindings[key] === 'Enter' ? 'Enter' :
                        keyBindings[key] === 'Escape' ? 'Esc' :
                          keyBindings[key] === 'Backspace' ? 'Backspace' :
                            keyBindings[key] === 'ArrowUp' ? '↑' :
                              keyBindings[key] === 'ArrowDown' ? '↓' :
                                keyBindings[key] === 'ArrowLeft' ? '←' :
                                  keyBindings[key] === 'ArrowRight' ? '→' :
                                    keyBindings[key].toUpperCase()
                  )}
                </button>
              </div>
            ))}
            <div style={{ display: 'flex', gap: '12px', marginTop: '16px', justifyContent: 'flex-end' }}>
              <button
                onClick={() => {
                  setKeyBindings(defaultKeyBindings)
                  localStorage.setItem('keyBindings', JSON.stringify(defaultKeyBindings))
                }}
                style={{
                  padding: '8px 16px',
                  fontSize: '12px',
                  fontWeight: 600,
                  background: 'rgba(255, 255, 255, 0.1)',
                  color: 'var(--text)',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '6px',
                  cursor: 'pointer'
                }}
              >
                {t('scoreboard.keybindings.resetToDefaults', 'Reset to Defaults')}
              </button>
              <button
                onClick={() => {
                  setKeybindingsModalOpen(false)
                  setEditingKey(null)
                }}
                style={{
                  padding: '8px 16px',
                  fontSize: '12px',
                  fontWeight: 600,
                  background: 'var(--accent)',
                  color: '#000',
                  border: 'none',
                  borderRadius: '6px',
                  cursor: 'pointer'
                }}
              >
                {t('scoreboard.keybindings.done', 'Done')}
              </button>
            </div>
          </div>
        </Modal>
      )}

      {/* Accidental Rally Start Confirmation Modal */}
      {accidentalRallyConfirmModal && (
        <Modal
          title={t('scoreboard.modals.confirmRallyStart')}
          open={true}
          onClose={() => setAccidentalRallyConfirmModal(null)}
          width={320}
          hideCloseButton={true}
        >
          <div style={{ padding: '24px', textAlign: 'center' }}>
            <div style={{ marginBottom: '16px', fontSize: '48px' }}>⚠️</div>
            <p style={{ marginBottom: '8px', fontSize: '14px', fontWeight: 600 }}>
              {t('scoreboard.confirm.rallyStartedQuickly')}
            </p>
            <p style={{ marginBottom: '24px', fontSize: '12px', color: 'var(--muted)' }}>
              {t('scoreboard.confirm.areYouSureRallyStarted')}
            </p>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
              <button
                onClick={accidentalRallyConfirmModal.onConfirm}
                style={{
                  padding: '12px 24px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'var(--accent)',
                  color: '#000',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                {t('scoreboard.confirm.yesStartRally')}
              </button>
              <button
                onClick={() => setAccidentalRallyConfirmModal(null)}
                style={{
                  padding: '12px 24px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'rgba(255, 255, 255, 0.1)',
                  color: 'var(--text)',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                {t('common.cancel')}
              </button>
            </div>
          </div>
        </Modal>
      )}

      {/* Accidental Point Award Confirmation Modal */}
      {accidentalPointConfirmModal && (
        <Modal
          title={t('scoreboard.modals.confirmPoint')}
          open={true}
          onClose={() => setAccidentalPointConfirmModal(null)}
          width={320}
          hideCloseButton={true}
        >
          <div style={{ padding: '24px', textAlign: 'center' }}>
            <div style={{ marginBottom: '16px', fontSize: '48px' }}>⚠️</div>
            <p style={{ marginBottom: '8px', fontSize: '14px', fontWeight: 600 }}>
              {t('scoreboard.confirm.pointAwardedQuickly')}
            </p>
            <p style={{ marginBottom: '24px', fontSize: '12px', color: 'var(--muted)' }}>
              {t('scoreboard.confirm.areYouSureAwardPoint', { team: accidentalPointConfirmModal.team === 'home' ? (data?.homeTeam?.name || 'Home') : (data?.awayTeam?.name || 'Away') })}
            </p>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
              <button
                onClick={accidentalPointConfirmModal.onConfirm}
                style={{
                  padding: '12px 24px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'var(--accent)',
                  color: '#000',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                {t('scoreboard.confirm.yesAwardPoint')}
              </button>
              <button
                onClick={() => setAccidentalPointConfirmModal(null)}
                style={{
                  padding: '12px 24px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'rgba(255, 255, 255, 0.1)',
                  color: 'var(--text)',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                {t('common.cancel')}
              </button>
            </div>
          </div>
        </Modal>
      )}

      {/* Duplicate Timeout Confirmation Modal */}
      {duplicateTimeoutConfirm && (
        <Modal
          title={t('scoreboard.modals.confirmTimeout', 'Confirm Timeout')}
          open={true}
          onClose={() => setDuplicateTimeoutConfirm(null)}
          width={320}
          hideCloseButton={true}
        >
          <div style={{ padding: '24px', textAlign: 'center' }}>
            <div style={{ marginBottom: '16px', fontSize: '48px' }}>⏱️</div>
            <p style={{ marginBottom: '8px', fontSize: '14px', fontWeight: 600 }}>
              {t('scoreboard.confirm.timeoutAlreadyTaken', 'Timeout already taken')}
            </p>
            <p style={{ marginBottom: '24px', fontSize: '12px', color: 'var(--muted)' }}>
              {t('scoreboard.confirm.areYouSureAnotherTimeout', {
                team: duplicateTimeoutConfirm.team === 'home' ? (data?.homeTeam?.name || 'Home') : (data?.awayTeam?.name || 'Away'),
                defaultValue: `${duplicateTimeoutConfirm.team === 'home' ? (data?.homeTeam?.name || 'Home') : (data?.awayTeam?.name || 'Away')} already has a timeout with no points since. Are you sure you want another timeout?`
              })}
            </p>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
              <button
                onClick={() => {
                  const team = duplicateTimeoutConfirm.team
                  setDuplicateTimeoutConfirm(null)
                  setTimeoutModal({ team, countdown: 30, started: false })
                }}
                style={{
                  padding: '12px 24px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'var(--accent)',
                  color: '#000',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                {t('scoreboard.confirm.yesTimeout', 'Yes, Timeout')}
              </button>
              <button
                onClick={() => setDuplicateTimeoutConfirm(null)}
                style={{
                  padding: '12px 24px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'rgba(255, 255, 255, 0.1)',
                  color: 'var(--text)',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                {t('common.cancel')}
              </button>
            </div>
          </div>
        </Modal>
      )}

      {sanctionConfirmModal && (() => {
        const teamData = sanctionConfirmModal.team === 'home' ? data?.homeTeam : data?.awayTeam
        const teamColor = teamData?.color || (sanctionConfirmModal.team === 'home' ? '#ef4444' : '#3b82f6')
        const teamLabel = sanctionConfirmModal.team === teamAKey ? 'A' : 'B'
        const teamName = teamData?.name || (sanctionConfirmModal.team === 'home' ? 'Home' : 'Away')
        const isBright = isBrightColor(teamColor)

        return (
          <Modal
            title={
              <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                <span>{teamName}</span>
                <span style={{
                  padding: '4px 12px',
                  borderRadius: '6px',
                  fontSize: '14px',
                  fontWeight: 700,
                  background: teamColor,
                  color: isBright ? '#000' : '#fff'
                }}>{teamLabel}</span>
              </div>
            }
            open={true}
            onClose={cancelSanctionConfirm}
            width={240}
            hideCloseButton={true}
          >
            <div style={{ padding: '16px', textAlign: 'center' }}>
              <p style={{ marginBottom: '12px', fontSize: '12px', color: 'var(--muted)' }}>
                {sanctionConfirmModal.type === 'player' && `#${sanctionConfirmModal.playerNumber}`}
                {sanctionConfirmModal.type === 'bench' && `Bench #${sanctionConfirmModal.playerNumber}`}
                {sanctionConfirmModal.type === 'libero' && `Libero #${sanctionConfirmModal.playerNumber}`}
                {sanctionConfirmModal.type === 'official' && `${sanctionConfirmModal.role}`}
              </p>
              <div style={{ marginBottom: '16px', display: 'flex', justifyContent: 'center', alignItems: 'center', gap: '8px' }}>
                {sanctionConfirmModal.sanctionType === 'warning' && <div className="sanction-card yellow" style={{ width: '28px', height: '38px' }}></div>}
                {sanctionConfirmModal.sanctionType === 'penalty' && <div className="sanction-card red" style={{ width: '28px', height: '38px' }}></div>}
                {sanctionConfirmModal.sanctionType === 'expulsion' && <div className="sanction-card combo" style={{ width: '32px', height: '38px' }}></div>}
                {sanctionConfirmModal.sanctionType === 'disqualification' && (
                  <div className="sanction-cards-separate">
                    <div className="sanction-card yellow" style={{ width: '24px', height: '32px' }}></div>
                    <div className="sanction-card red" style={{ width: '24px', height: '32px' }}></div>
                  </div>
                )}
              </div>
              <p style={{ marginBottom: '16px', fontSize: '13px', fontWeight: 600 }}>
                {sanctionConfirmModal.sanctionType === 'warning' && 'Warning'}
                {sanctionConfirmModal.sanctionType === 'penalty' && 'Penalty'}
                {sanctionConfirmModal.sanctionType === 'expulsion' && 'Expulsion'}
                {sanctionConfirmModal.sanctionType === 'disqualification' && 'Disqualification'}
              </p>
              <div style={{ display: 'flex', gap: '8px', justifyContent: 'center' }}>
                <button
                  onClick={confirmPlayerSanction}
                  style={{
                    padding: '8px 16px',
                    fontSize: '12px',
                    fontWeight: 600,
                    background: 'var(--accent)',
                    color: '#000',
                    border: 'none',
                    borderRadius: '6px',
                    cursor: 'pointer'
                  }}
                >
                  Confirm
                </button>
                <button
                  onClick={cancelSanctionConfirm}
                  style={{
                    padding: '8px 16px',
                    fontSize: '12px',
                    fontWeight: 600,
                    background: 'rgba(255, 255, 255, 0.1)',
                    color: 'var(--text)',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    borderRadius: '6px',
                    cursor: 'pointer'
                  }}
                >
                  Cancel
                </button>
              </div>
            </div>
          </Modal>
        )
      })()}

      {substitutionConfirm && (() => {
        const teamData = substitutionConfirm.team === 'home' ? data?.homeTeam : data?.awayTeam
        const teamColor = teamData?.color || (substitutionConfirm.team === 'home' ? '#ef4444' : '#3b82f6')
        const teamLabel = substitutionConfirm.team === teamAKey ? 'A' : 'B'
        const teamName = teamData?.name || (substitutionConfirm.team === 'home' ? 'Home' : 'Away')
        const isBright = isBrightColor(teamColor)

        return (
          <Modal
            title={
              <div style={{ display: 'flex', alignItems: 'center', gap: '14px' }}>
                <span style={{ fontSize: '19px' }}>{teamName}</span>
                <span
                  style={{
                    padding: '5px 14px',
                    borderRadius: '7px',
                    fontSize: '17px',
                    fontWeight: 700,
                    background: teamColor,
                    color: isBright ? '#000' : '#fff'
                  }}
                >
                  {teamLabel}
                </span>
              </div>
            }
            open={true}
            onClose={cancelSubstitutionConfirm}
            width="auto"
            hideCloseButton={true}
          >
            <div style={{ padding: '29px', textAlign: 'center' }}>
              {substitutionConfirm.isExceptional && (
                <div style={{ marginBottom: '19px', padding: '10px', background: 'rgba(234, 179, 8, 0.2)', border: '1px solid rgba(234, 179, 8, 0.4)', borderRadius: '7px', fontSize: '14px', color: '#facc15', fontWeight: 600 }}>
                  Exceptional Substitution - Player cannot take part anymore
                </div>
              )}
              {/* Display current score - requesting team on left */}
              {(() => {
                const requestingTeamData = substitutionConfirm.team === 'home' ? data?.homeTeam : data?.awayTeam
                const otherTeamData = substitutionConfirm.team === 'home' ? data?.awayTeam : data?.homeTeam
                const requestingTeamScore = substitutionConfirm.team === 'home' ? (data?.set?.homePoints || 0) : (data?.set?.awayPoints || 0)
                const otherTeamScore = substitutionConfirm.team === 'home' ? (data?.set?.awayPoints || 0) : (data?.set?.homePoints || 0)
                const requestingTeamLabel = substitutionConfirm.team === teamAKey ? 'A' : 'B'
                const otherTeamLabel = substitutionConfirm.team === teamAKey ? 'B' : 'A'
                const requestingTeamColor = requestingTeamData?.color || (substitutionConfirm.team === 'home' ? '#ef4444' : '#3b82f6')
                const otherTeamColor = otherTeamData?.color || (substitutionConfirm.team === 'home' ? '#3b82f6' : '#ef4444')
                const isRequestingBright = isBrightColor(requestingTeamColor)
                const isOtherBright = isBrightColor(otherTeamColor)
                const currentSubs = substitutionsUsed[substitutionConfirm.team] || 0
                const subLabel = currentSubs === 4 ? '5th' : currentSubs === 5 ? '6th' : ''
                return (
                  <>
                    <div style={{ marginBottom: '19px', fontSize: '24px', fontWeight: 700, display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '10px' }}>
                      <span style={{
                        fontSize: '16px',
                        fontWeight: 700,
                        padding: '4px 10px',
                        borderRadius: '6px',
                        background: requestingTeamColor,
                        color: isRequestingBright ? '#000' : '#fff'
                      }}>{requestingTeamLabel}</span>
                      <span>{requestingTeamScore}</span>
                      <span>:</span>
                      <span>{otherTeamScore}</span>
                      <span style={{
                        fontSize: '16px',
                        fontWeight: 700,
                        padding: '4px 10px',
                        borderRadius: '6px',
                        background: otherTeamColor,
                        color: isOtherBright ? '#000' : '#fff'
                      }}>{otherTeamLabel}</span>
                    </div>
                    {subLabel && (
                      <div style={{ marginBottom: '10px', fontSize: '14px' }}>
                        <span style={{ color: '#ef4444', fontWeight: 700 }}>{subLabel}</span> substitution
                      </div>
                    )}
                  </>
                )
              })()}
              <div style={{ marginBottom: '29px', fontSize: '19px', fontWeight: 600 }}>
                <div style={{ marginBottom: '10px', color: '#ef4444', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '10px' }}>
                  <span>OUT: # {substitutionConfirm.playerOut}</span>
                  {(substitutionConfirm.isExpelled || substitutionConfirm.isDisqualified) ? (
                    <span style={{ fontSize: '29px', fontWeight: 700, color: '#ef4444' }}>✕</span>
                  ) : (
                    <span style={{ fontSize: '29px', fontWeight: 700 }}>↓</span>
                  )}
                </div>
                <div style={{ color: '#22c55e', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '10px' }}>
                  <span>IN: # {substitutionConfirm.playerIn}</span>
                  <span style={{ fontSize: '29px', fontWeight: 700 }}>↑</span>
                </div>
              </div>
              <div style={{ display: 'flex', gap: '14px', justifyContent: 'center' }}>
                <button
                  onClick={confirmSubstitution}
                  style={{
                    padding: '14px 29px',
                    fontSize: '17px',
                    fontWeight: 600,
                    background: 'var(--accent)',
                    color: '#000',
                    border: 'none',
                    borderRadius: '10px',
                    cursor: 'pointer'
                  }}
                >
                  Yes
                </button>
                <button
                  onClick={cancelSubstitutionConfirm}
                  style={{
                    padding: '14px 29px',
                    fontSize: '17px',
                    fontWeight: 600,
                    background: 'rgba(255, 255, 255, 0.1)',
                    color: 'var(--text)',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    borderRadius: '10px',
                    cursor: 'pointer'
                  }}
                >
                  Cancel
                </button>
              </div>
            </div>
          </Modal>
        )
      })()}

      {liberoConfirm && (() => {
        const teamData = liberoConfirm.team === 'home' ? data?.homeTeam : data?.awayTeam
        const teamColor = teamData?.color || (liberoConfirm.team === 'home' ? '#ef4444' : '#3b82f6')
        const teamLabel = liberoConfirm.team === teamAKey ? 'A' : 'B'
        const teamName = teamData?.name || (liberoConfirm.team === 'home' ? 'Home' : 'Away')

        // Get libero number from players list
        const teamPlayers = liberoConfirm.team === 'home' ? data?.homePlayers : data?.awayPlayers
        const liberoPlayer = teamPlayers?.find(p => p.libero === liberoConfirm.liberoIn)
        const liberoNumber = liberoConfirm.newLiberoNumber || liberoPlayer?.number
        const liberoLabel = liberoConfirm.liberoIn === 'libero1' ? 'L1' : liberoConfirm.liberoIn === 'redesignated' ? 'LR' : 'L2'

        return (
          <div
            style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.5)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 9999
            }}
            onClick={cancelLiberoConfirm}
          >
            <div
              style={{
                background: '#fff',
                borderRadius: '16px',
                padding: '24px 32px',
                minWidth: '280px',
                boxShadow: '0 8px 32px rgba(0, 0, 0, 0.3)'
              }}
              onClick={e => e.stopPropagation()}
            >
              {/* Header with team name and badge */}
              <div style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '12px',
                marginBottom: '20px',
                paddingBottom: '16px',
                borderBottom: '2px solid #e5e7eb'
              }}>
                <span style={{ fontSize: '18px', fontWeight: 600, color: '#1f2937' }}>{teamName}</span>
                <span style={{
                  padding: '4px 12px',
                  borderRadius: '6px',
                  fontSize: '14px',
                  fontWeight: 700,
                  background: teamColor,
                  color: isBrightColor(teamColor) ? '#000' : '#fff'
                }}>{teamLabel}</span>
              </div>

              {/* Libero IN/OUT and Player Replaced/Returns - side by side */}
              <div style={{ display: 'flex', gap: '12px', marginBottom: '20px' }}>
                {liberoConfirm.isExit ? (
                  <>
                    {/* Libero OUT */}
                    <div style={{
                      flex: 1,
                      padding: '14px',
                      background: '#fef2f2',
                      borderRadius: '12px',
                      border: '2px solid #ef4444',
                      textAlign: 'center'
                    }}>
                      <div style={{
                        fontSize: '11px',
                        color: '#991b1b',
                        fontWeight: 600,
                        marginBottom: '6px',
                        textTransform: 'uppercase',
                        letterSpacing: '0.5px'
                      }}>
                        Libero OUT
                      </div>
                      <div style={{
                        fontSize: '26px',
                        fontWeight: 700,
                        color: '#991b1b'
                      }}>
                        #{liberoConfirm.playerOut}
                      </div>
                    </div>

                    {/* Player Returns */}
                    <div style={{
                      flex: 1,
                      padding: '14px',
                      background: '#dcfce7',
                      borderRadius: '12px',
                      border: '2px solid #22c55e',
                      textAlign: 'center'
                    }}>
                      <div style={{
                        fontSize: '11px',
                        color: '#166534',
                        fontWeight: 600,
                        marginBottom: '6px',
                        textTransform: 'uppercase',
                        letterSpacing: '0.5px'
                      }}>
                        Returns
                      </div>
                      <div style={{
                        fontSize: '26px',
                        fontWeight: 700,
                        color: '#166534'
                      }}>
                        #{liberoConfirm.replacedPlayer}
                      </div>
                    </div>
                  </>
                ) : (
                  <>
                    {/* Libero IN */}
                    <div style={{
                      flex: 1,
                      padding: '14px',
                      background: '#dcfce7',
                      borderRadius: '12px',
                      border: '2px solid #22c55e',
                      textAlign: 'center'
                    }}>
                      <div style={{
                        fontSize: '11px',
                        color: '#166534',
                        fontWeight: 600,
                        marginBottom: '6px',
                        textTransform: 'uppercase',
                        letterSpacing: '0.5px'
                      }}>
                        Libero IN
                      </div>
                      <div style={{
                        fontSize: '26px',
                        fontWeight: 700,
                        color: '#166534'
                      }}>
                        #{liberoNumber || '?'}
                      </div>
                      <div style={{
                        fontSize: '12px',
                        padding: '2px 8px',
                        background: '#22c55e',
                        color: '#fff',
                        borderRadius: '4px',
                        display: 'inline-block',
                        marginTop: '4px'
                      }}>{liberoLabel}</div>
                    </div>

                    {/* Player Replaced */}
                    <div style={{
                      flex: 1,
                      padding: '14px',
                      background: '#fef2f2',
                      borderRadius: '12px',
                      border: '2px solid #ef4444',
                      textAlign: 'center'
                    }}>
                      <div style={{
                        fontSize: '11px',
                        color: '#991b1b',
                        fontWeight: 600,
                        marginBottom: '6px',
                        textTransform: 'uppercase',
                        letterSpacing: '0.5px'
                      }}>
                        Replaced
                      </div>
                      <div style={{
                        fontSize: '26px',
                        fontWeight: 700,
                        color: '#991b1b'
                      }}>
                        #{liberoConfirm.playerOut}
                      </div>
                    </div>
                  </>
                )}
              </div>

              {/* Buttons */}
              <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
                <button
                  onClick={confirmLibero}
                  style={{
                    padding: '12px 28px',
                    fontSize: '16px',
                    fontWeight: 600,
                    background: '#22c55e',
                    color: '#fff',
                    border: 'none',
                    borderRadius: '8px',
                    cursor: 'pointer'
                  }}
                >
                  Confirm
                </button>
                <button
                  onClick={cancelLiberoConfirm}
                  style={{
                    padding: '12px 28px',
                    fontSize: '16px',
                    fontWeight: 600,
                    background: '#f3f4f6',
                    color: '#374151',
                    border: '1px solid #d1d5db',
                    borderRadius: '8px',
                    cursor: 'pointer'
                  }}
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )
      })()}

      {liberoReentryModal && (() => {
        const teamData = liberoReentryModal.team === 'home' ? data?.homeTeam : data?.awayTeam
        const teamColor = teamData?.color || (liberoReentryModal.team === 'home' ? '#ef4444' : '#3b82f6')
        const teamLabel = liberoReentryModal.team === teamAKey ? 'A' : 'B'
        const teamName = teamData?.name || (liberoReentryModal.team === 'home' ? 'Home' : 'Away')

        // Get the selected libero info
        const selectedLibero = liberoReentryModal.availableLiberos?.[liberoReentryModal.selectedLiberoIndex || 0]
        const liberoNumber = selectedLibero?.number || liberoReentryModal.liberoNumber
        const liberoLabel = selectedLibero?.label || (liberoReentryModal.liberoType === 'libero1' ? 'L1' : liberoReentryModal.liberoType === 'redesignated' ? 'LR' : 'L2')

        // Determine if this team is on the left or right side
        const isOnLeftSide = (liberoReentryModal.team === 'home') === leftIsHome

        // Get position from the appropriate ref
        const positionRef = isOnLeftSide ? leftCourtPositionVRef : rightCourtPositionIIRef
        const rect = positionRef.current?.getBoundingClientRect()

        // Calculate modal position (top-left corner at the position box)
        const modalTop = rect ? rect.top : (isOnLeftSide ? '50%' : '30%')
        const modalLeft = rect ? rect.left : (isOnLeftSide ? '10%' : '55%')

        return (
          <div
            style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.5)',
              zIndex: 9999
            }}
            onClick={cancelLiberoReentry}
          >
            <div
              style={{
                position: 'absolute',
                top: typeof modalTop === 'number' ? `${modalTop}px` : modalTop,
                left: typeof modalLeft === 'number' ? `${modalLeft}px` : modalLeft,
                background: '#fff',
                borderRadius: '16px',
                padding: '24px 32px',
                minWidth: '320px',
                maxWidth: '420px',
                boxShadow: '0 8px 32px rgba(0, 0, 0, 0.3)'
              }}
              onClick={e => e.stopPropagation()}
            >
              {/* Header */}
              <div style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '12px',
                marginBottom: '16px',
                paddingBottom: '12px',
                borderBottom: '2px solid #e5e7eb'
              }}>
                <span style={{ fontSize: '18px', fontWeight: 600, color: '#1f2937' }}>{teamName}</span>
                <span style={{
                  padding: '4px 12px',
                  borderRadius: '6px',
                  fontSize: '14px',
                  fontWeight: 700,
                  background: teamColor,
                  color: isBrightColor(teamColor) ? '#000' : '#fff'
                }}>{teamLabel}</span>
              </div>

              {/* Message */}
              <div style={{
                fontSize: '14px',
                color: '#6b7280',
                textAlign: 'center',
                marginBottom: '16px'
              }}>
                Sub libero in position I?
              </div>

              {/* Player OUT and Libero IN - side by side */}
              <div style={{ display: 'flex', gap: '12px', marginBottom: '16px' }}>
                {/* Player OUT */}
                <div style={{
                  flex: 1,
                  padding: '14px',
                  background: '#fef2f2',
                  borderRadius: '12px',
                  border: '2px solid #ef4444',
                  textAlign: 'center'
                }}>
                  <div style={{
                    fontSize: '11px',
                    color: '#991b1b',
                    fontWeight: 600,
                    marginBottom: '6px',
                    textTransform: 'uppercase',
                    letterSpacing: '0.5px'
                  }}>
                    Player OUT
                  </div>
                  <div style={{
                    fontSize: '26px',
                    fontWeight: 700,
                    color: '#991b1b'
                  }}>
                    #{liberoReentryModal.playerNumber}
                  </div>
                </div>

                {/* Libero IN */}
                <div style={{
                  flex: 1,
                  padding: '14px',
                  background: '#dcfce7',
                  borderRadius: '12px',
                  border: '2px solid #22c55e',
                  textAlign: 'center'
                }}>
                  <div style={{
                    fontSize: '11px',
                    color: '#166534',
                    fontWeight: 600,
                    marginBottom: '6px',
                    textTransform: 'uppercase',
                    letterSpacing: '0.5px'
                  }}>
                    Libero IN
                  </div>
                  <div style={{
                    fontSize: '26px',
                    fontWeight: 700,
                    color: '#166534'
                  }}>
                    #{liberoNumber}
                  </div>
                  <div style={{
                    fontSize: '12px',
                    padding: '2px 8px',
                    background: '#22c55e',
                    color: '#fff',
                    borderRadius: '4px',
                    display: 'inline-block',
                    marginTop: '4px'
                  }}>{liberoLabel}</div>
                </div>
              </div>

              {/* Libero selection if multiple available */}
              {liberoReentryModal.availableLiberos && liberoReentryModal.availableLiberos.length > 1 && (
                <div style={{ marginBottom: '16px' }}>
                  <div style={{ fontSize: '12px', color: '#6b7280', textAlign: 'center', marginBottom: '8px' }}>
                    Select libero:
                  </div>
                  <div style={{ display: 'flex', gap: '8px', justifyContent: 'center' }}>
                    {liberoReentryModal.availableLiberos.map((libero, index) => (
                      <button
                        key={`${libero.type}-${libero.number}`}
                        onClick={() => {
                          setLiberoReentryModal({
                            ...liberoReentryModal,
                            selectedLiberoIndex: index
                          })
                        }}
                        style={{
                          padding: '8px 16px',
                          background: index === (liberoReentryModal.selectedLiberoIndex || 0)
                            ? '#22c55e'
                            : '#f3f4f6',
                          color: index === (liberoReentryModal.selectedLiberoIndex || 0)
                            ? '#fff'
                            : '#374151',
                          border: index === (liberoReentryModal.selectedLiberoIndex || 0)
                            ? '2px solid #16a34a'
                            : '1px solid #d1d5db',
                          borderRadius: '8px',
                          cursor: 'pointer',
                          fontWeight: 600,
                          fontSize: '14px',
                          transition: 'all 0.2s ease'
                        }}
                      >
                        <div>{libero.label}</div>
                        <div style={{ fontSize: '16px', marginTop: '2px' }}>#{libero.number}</div>
                      </button>
                    ))}
                  </div>
                </div>
              )}

              {/* Buttons */}
              <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
                <button
                  onClick={confirmLiberoReentry}
                  style={{
                    padding: '12px 28px',
                    fontSize: '15px',
                    fontWeight: 600,
                    background: '#22c55e',
                    color: '#fff',
                    border: 'none',
                    borderRadius: '8px',
                    cursor: 'pointer'
                  }}
                >
                  Confirm
                </button>
                <button
                  onClick={cancelLiberoReentry}
                  style={{
                    padding: '12px 28px',
                    fontSize: '15px',
                    fontWeight: 600,
                    background: '#f3f4f6',
                    color: '#374151',
                    border: '1px solid #d1d5db',
                    borderRadius: '8px',
                    cursor: 'pointer'
                  }}
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )
      })()}

      {liberoRedesignationModal && data && (() => {
        let availablePlayers = []
        try {
          if (getAvailablePlayersForRedesignation) {
            availablePlayers = getAvailablePlayersForRedesignation(
              liberoRedesignationModal.team,
              liberoRedesignationModal.unableLiberoNumber
            ) || []
          }
        } catch (error) {
          availablePlayers = []
        }
        return (
          <Modal
            title={t('scoreboard.modals.liberoRedesignation')}
            open={true}
            onClose={() => setLiberoRedesignationModal(null)}
            width={480}
            hideCloseButton={true}
          >
            <div style={{ padding: '29px' }}>
              <p style={{ marginBottom: '29px', fontSize: '17px', color: 'var(--muted)' }}>
                Select a player to re-designate as Libero:
              </p>
              {availablePlayers.length === 0 ? (
                <p style={{ textAlign: 'center', color: 'var(--muted)', marginBottom: '29px', fontSize: '17px' }}>
                  No available players for re-designation
                </p>
              ) : (
                <div style={{ display: 'flex', flexDirection: 'column', gap: '10px', marginBottom: '29px', maxHeight: '360px', overflowY: 'auto' }}>
                  {availablePlayers.map(player => (
                    <button
                      key={player.id}
                      onClick={() => confirmLiberoRedesignation(player.number)}
                      style={{
                        padding: '14px',
                        fontSize: '17px',
                        fontWeight: 600,
                        background: 'rgba(255, 255, 255, 0.05)',
                        color: 'var(--text)',
                        border: '1px solid rgba(255, 255, 255, 0.1)',
                        borderRadius: '7px',
                        cursor: 'pointer',
                        textAlign: 'left',
                        transition: 'all 0.2s'
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.background = 'rgba(255, 255, 255, 0.1)'
                        e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.2)'
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'
                        e.currentTarget.style.borderColor = 'rgba(255, 255, 255, 0.1)'
                      }}
                    >
                      #{player.number} - {player.lastName || player.name} {player.firstName}
                    </button>
                  ))}
                </div>
              )}
              <div style={{ display: 'flex', gap: '14px', justifyContent: 'center' }}>
                <button
                  onClick={() => setLiberoRedesignationModal(null)}
                  style={{
                    padding: '14px 29px',
                    fontSize: '17px',
                    fontWeight: 600,
                    background: 'rgba(255, 255, 255, 0.1)',
                    color: 'var(--text)',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    borderRadius: '10px',
                    cursor: 'pointer'
                  }}
                >
                  Cancel
                </button>
              </div>
            </div>
          </Modal>
        )
      })()}

      {reopenSetConfirm && (
        <Modal
          title={t('scoreboard.modals.reopenSet')}
          open={true}
          onClose={() => setReopenSetConfirm(null)}
          width={400}
          hideCloseButton={true}
        >
          <div style={{ padding: '24px', textAlign: 'center' }}>
            <p style={{ marginBottom: '24px', fontSize: '16px' }}>
              Reopen Set {reopenSetConfirm.setIndex}? This will delete all subsequent sets and their events.
            </p>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
              <button
                onClick={async () => {
                  // Mark the set as not finished
                  await db.sets.update(reopenSetConfirm.setId, { finished: false })

                  // Delete all subsequent sets
                  const allSets = await db.sets.where('matchId').equals(matchId).toArray()
                  const setsToDelete = allSets.filter(s => s.index > reopenSetConfirm.setIndex)
                  for (const s of setsToDelete) {
                    // Delete events for this set
                    await db.events.where('matchId').equals(matchId).and(e => e.setIndex === s.index).delete()
                    // Delete the set
                    await db.sets.delete(s.id)
                  }

                  // Update match status back to 'live' if it was 'final'
                  if (data.match?.status === 'final') {
                    await db.matches.update(matchId, { status: 'live' })
                  }

                  setReopenSetConfirm(null)
                }}
                style={{
                  padding: '12px 24px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'var(--accent)',
                  color: '#000',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                Yes, Reopen
              </button>
              <button
                onClick={() => setReopenSetConfirm(null)}
                style={{
                  padding: '12px 24px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'rgba(255, 255, 255, 0.1)',
                  color: 'var(--text)',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                Cancel
              </button>
            </div>
          </div>
        </Modal>
      )}

      {liberoBenchActionMenu && (() => {
        const isRightSide = liberoBenchActionMenu.side === 'right'
        const menuStyle = {
          position: 'fixed',
          left: isRightSide ? undefined : `${liberoBenchActionMenu.x}px`,
          right: isRightSide ? `${window.innerWidth - liberoBenchActionMenu.x}px` : undefined,
          top: `${liberoBenchActionMenu.y}px`,
          transform: 'translateY(-50%)',
          zIndex: 1000
        }

        // Get eligible back-row players for libero substitution
        const teamKey = liberoBenchActionMenu.team
        const { playersOnCourt } = getTeamLineupState(teamKey)
        const currentServe = getCurrentServe()
        const isServing = currentServe === teamKey
        const teamPlayers = teamKey === 'home' ? data?.homePlayers : data?.awayPlayers

        // Back row positions: I, V, VI - but I cannot be replaced when serving
        const backRowPositions = ['I', 'V', 'VI']
        const eligiblePositions = backRowPositions.filter(pos => {
          // Position I cannot be replaced when this team is serving
          if (pos === 'I' && isServing) return false
          // Check if there's been a point since last libero exchange for this position
          return hasPointSinceLastLiberoExchange(teamKey, pos)
        })

        // Get the lineup to find player numbers at each position
        const lineupEvents = (data?.events || [])
          .filter(e => e.type === 'lineup' && e.payload?.team === teamKey && e.setIndex === data?.set?.index)
        const latestLineup = lineupEvents[lineupEvents.length - 1]?.payload?.lineup || {}

        const eligiblePlayers = eligiblePositions.map(pos => {
          const posData = latestLineup[pos]
          // Handle both rich format (object with number) and legacy format (just number)
          const playerNum = posData && typeof posData === 'object' && posData.number !== undefined
            ? posData.number
            : posData
          const player = teamPlayers?.find(p => String(p.number) === String(playerNum))
          return { position: pos, number: playerNum, player }
        }).filter(p => p.number && !teamPlayers?.find(tp => String(tp.number) === String(p.number))?.libero)

        // Check if libero is already on court
        const liberoOnCourt = getLiberoOnCourt(teamKey)
        const canPutIn = !liberoOnCourt && eligiblePlayers.length > 0 && rallyStatus === 'idle'

        return (
          <>
            <div
              style={{
                position: 'fixed',
                inset: 0,
                zIndex: 999
              }}
              onClick={() => { setLiberoBenchActionMenu(null); setLiberoBenchReplaceExpanded(false); setLiberoBenchUnableExpanded(false) }}
            />
            <div style={menuStyle}>
              <div style={{
                background: 'rgba(15, 23, 42, 0.98)',
                border: '1px solid rgba(255, 255, 255, 0.2)',
                borderRadius: '8px',
                padding: '8px',
                display: 'flex',
                flexDirection: 'column',
                gap: '4px',
                minWidth: '200px'
              }}>
                {/* Put in section - collapsible */}
                {canPutIn && (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                    <button
                      onClick={() => setLiberoBenchReplaceExpanded(!liberoBenchReplaceExpanded)}
                      style={{
                        padding: '8px 12px',
                        fontSize: '12px',
                        fontWeight: 600,
                        background: '#FFF8E7',
                        color: '#000',
                        border: '1px solid rgba(0, 0, 0, 0.2)',
                        borderRadius: '6px',
                        cursor: 'pointer',
                        textAlign: 'left',
                        transition: 'all 0.2s',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        gap: '6px',
                        width: '100%'
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.background = '#fff3cd'
                        e.currentTarget.style.transform = 'scale(1.02)'
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.background = '#FFF8E7'
                        e.currentTarget.style.transform = 'scale(1)'
                      }}
                    >
                      <span>Replace</span>
                      <span style={{ fontSize: '14px', lineHeight: '1', transform: liberoBenchReplaceExpanded ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
                    </button>
                    {liberoBenchReplaceExpanded && (
                      <div style={{ display: 'flex', justifyContent: 'space-evenly', gap: '4px', marginTop: '4px' }}>
                        {eligiblePlayers.map(({ position, number }) => (
                          <button
                            key={position}
                            onClick={() => {
                              // Open libero confirmation with this position
                              setLiberoDropdown({
                                team: teamKey,
                                position,
                                playerNumber: number,
                                element: liberoBenchActionMenu.element,
                                x: liberoBenchActionMenu.x,
                                y: liberoBenchActionMenu.y
                              })
                              // Auto-select this libero
                              setTimeout(() => {
                                showLiberoConfirm(liberoBenchActionMenu.liberoType)
                              }, 50)
                              setLiberoBenchActionMenu(null)
                              setLiberoBenchReplaceExpanded(false)
                            }}
                            style={{
                              padding: '6px 12px',
                              fontSize: '14px',
                              fontWeight: 700,
                              background: '#fff',
                              color: '#000',
                              border: '1px solid rgba(0, 0, 0, 0.2)',
                              borderRadius: '4px',
                              cursor: 'pointer',
                              textAlign: 'center',
                              transition: 'all 0.2s',
                              minWidth: '45px'
                            }}
                            onMouseEnter={(e) => {
                              e.currentTarget.style.background = '#f3f4f6'
                              e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.4)'
                            }}
                            onMouseLeave={(e) => {
                              e.currentTarget.style.background = '#fff'
                              e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.2)'
                            }}
                          >
                            {number}
                          </button>
                        ))}
                      </div>
                    )}
                  </div>
                )}

                {/* Unable to play - expandable */}
                <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                  <button
                    onClick={() => setLiberoBenchUnableExpanded(!liberoBenchUnableExpanded)}
                    style={{
                      padding: '8px 12px',
                      fontSize: '12px',
                      fontWeight: 600,
                      background: '#ef4444',
                      color: '#fff',
                      border: '1px solid rgba(255, 255, 255, 0.2)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      textAlign: 'left',
                      transition: 'all 0.2s',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between',
                      gap: '6px',
                      width: '100%'
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.background = '#dc2626'
                      e.currentTarget.style.transform = 'scale(1.02)'
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.background = '#ef4444'
                      e.currentTarget.style.transform = 'scale(1)'
                    }}
                  >
                    <span>Unable to play</span>
                    <span style={{ fontSize: '14px', lineHeight: '1', transform: liberoBenchUnableExpanded ? 'rotate(180deg)' : 'rotate(0deg)', transition: 'transform 0.2s' }}>▼</span>
                  </button>
                  {liberoBenchUnableExpanded && (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px', marginTop: '4px' }}>
                      <button
                        onClick={() => {
                          setLiberoUnableModal({
                            team: liberoBenchActionMenu.team,
                            liberoNumber: liberoBenchActionMenu.liberoNumber,
                            liberoType: liberoBenchActionMenu.liberoType,
                            reason: 'declared',
                            isOnCourt: false
                          })
                          setLiberoBenchActionMenu(null)
                          setLiberoBenchUnableExpanded(false)
                        }}
                        style={{
                          padding: '6px 10px',
                          fontSize: '11px',
                          fontWeight: 600,
                          background: '#f97316',
                          color: '#000',
                          border: '1px solid rgba(0, 0, 0, 0.2)',
                          borderRadius: '4px',
                          cursor: 'pointer',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'space-between',
                          gap: '8px'
                        }}
                      >
                        <span>Declared unable</span>
                        <span style={{ fontSize: '14px' }}>🗣️</span>
                      </button>
                      <button
                        onClick={() => {
                          setLiberoUnableModal({
                            team: liberoBenchActionMenu.team,
                            liberoNumber: liberoBenchActionMenu.liberoNumber,
                            liberoType: liberoBenchActionMenu.liberoType,
                            reason: 'injury',
                            isOnCourt: false
                          })
                          setLiberoBenchActionMenu(null)
                          setLiberoBenchUnableExpanded(false)
                        }}
                        style={{
                          padding: '6px 10px',
                          fontSize: '11px',
                          fontWeight: 600,
                          background: 'rgba(239, 68, 68,1)',
                          color: '#ffff',
                          border: '1px solid rgba(239, 68, 68, 0.3)',
                          borderRadius: '4px',
                          cursor: 'pointer',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'space-between',
                          gap: '8px'
                        }}
                      >
                        <span>Injury / Illness</span>
                        <span style={{ fontSize: '14px' }}>✚</span>
                      </button>
                    </div>
                  )}
                </div>

                {/* Sanction */}
                <button
                  onClick={() => {
                    setSanctionDropdown({
                      team: liberoBenchActionMenu.team,
                      type: 'libero',
                      playerNumber: liberoBenchActionMenu.liberoNumber,
                      element: liberoBenchActionMenu.element,
                      x: liberoBenchActionMenu.x,
                      y: liberoBenchActionMenu.y,
                      side: liberoBenchActionMenu.side
                    })
                    setLiberoBenchActionMenu(null)
                  }}
                  style={{
                    padding: '8px 12px',
                    fontSize: '12px',
                    fontWeight: 600,
                    background: '#000',
                    color: '#fff',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    borderRadius: '6px',
                    cursor: 'pointer',
                    textAlign: 'left',
                    transition: 'all 0.2s',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    gap: '6px'
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.background = '#1a1a1a'
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.background = '#000'
                  }}
                >
                  <span>Sanction</span>
                  <div style={{ display: 'flex', gap: '2px' }}>
                    <div className="sanction-card yellow" style={{ width: '12px', height: '16px' }}></div>
                    <div className="sanction-card red" style={{ width: '12px', height: '16px' }}></div>
                  </div>
                </button>
              </div>
            </div>
          </>
        )
      })()}

      {liberoUnableModal && data && (() => {
        const teamData = liberoUnableModal.team === 'home' ? data?.homeTeam : data?.awayTeam
        const teamColor = teamData?.color || (liberoUnableModal.team === 'home' ? '#ef4444' : '#3b82f6')
        const teamLabel = liberoUnableModal.team === teamAKey ? 'A' : 'B'
        const teamName = teamData?.name || (liberoUnableModal.team === 'home' ? 'Home' : 'Away')
        const liberoLabel = liberoUnableModal.liberoType === 'libero1' ? 'L1' : liberoUnableModal.liberoType === 'redesignated' ? 'LR' : 'L2'

        // If reason is already selected, show confirmation
        const reasonSelected = liberoUnableModal.reason && liberoUnableModal.reason !== 'pending'

        return (
          <div
            style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.5)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 9999
            }}
            onClick={() => setLiberoUnableModal(null)}
          >
            <div
              style={{
                background: '#fff',
                borderRadius: '16px',
                padding: '24px 32px',
                minWidth: '340px',
                maxWidth: '420px',
                boxShadow: '0 8px 32px rgba(0, 0, 0, 0.3)'
              }}
              onClick={e => e.stopPropagation()}
            >
              {/* Header */}
              <div style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '12px',
                marginBottom: '16px',
                paddingBottom: '12px',
                borderBottom: '2px solid #e5e7eb'
              }}>
                <span style={{ fontSize: '18px', fontWeight: 600, color: '#1f2937' }}>{teamName}</span>
                <span style={{
                  padding: '4px 12px',
                  borderRadius: '6px',
                  fontSize: '14px',
                  fontWeight: 700,
                  background: teamColor,
                  color: isBrightColor(teamColor) ? '#000' : '#fff'
                }}>{teamLabel}</span>
              </div>

              {/* Libero Info */}
              <div style={{
                textAlign: 'center',
                marginBottom: '20px',
                padding: '16px',
                background: '#fef2f2',
                borderRadius: '12px',
                border: '2px solid #ef4444'
              }}>
                <div style={{ fontSize: '12px', color: '#991b1b', fontWeight: 600, marginBottom: '6px', textTransform: 'uppercase' }}>
                  Libero Unable to Play
                </div>
                <div style={{ fontSize: '28px', fontWeight: 700, color: '#991b1b' }}>
                  #{liberoUnableModal.liberoNumber}
                </div>
                <div style={{
                  fontSize: '12px',
                  padding: '2px 8px',
                  background: '#ef4444',
                  color: '#fff',
                  borderRadius: '4px',
                  display: 'inline-block',
                  marginTop: '4px'
                }}>{liberoLabel}</div>
              </div>

              {liberoUnableModal.step === 'redesignate' ? (
                <>
                  {/* Redesignation Prompt */}
                  <div style={{ fontSize: '14px', color: '#6b7280', textAlign: 'center', marginBottom: '20px' }}>
                    The libero is now unable to play. Do you want to redesignate a new libero now?
                  </div>
                  <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
                    <button
                      onClick={() => {
                        checkLiberoRedesignation(liberoUnableModal.team, liberoUnableModal.liberoNumber, liberoUnableModal.liberoType, liberoUnableModal.reason)
                        setLiberoUnableModal(null)
                      }}
                      style={{
                        padding: '12px 28px',
                        fontSize: '15px',
                        fontWeight: 600,
                        background: '#3b82f6',
                        color: '#fff',
                        border: 'none',
                        borderRadius: '8px',
                        cursor: 'pointer'
                      }}
                    >
                      Yes, Redesignate
                    </button>
                    <button
                      onClick={() => setLiberoUnableModal(null)}
                      style={{
                        padding: '12px 28px',
                        fontSize: '15px',
                        fontWeight: 600,
                        background: '#f3f4f6',
                        color: '#374151',
                        border: '1px solid #d1d5db',
                        borderRadius: '8px',
                        cursor: 'pointer'
                      }}
                    >
                      No, Later
                    </button>
                  </div>
                </>
              ) : !reasonSelected ? (
                <>
                  {/* Select reason */}
                  <div style={{ fontSize: '14px', color: '#6b7280', textAlign: 'center', marginBottom: '16px' }}>
                    Select reason:
                  </div>
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '10px', marginBottom: '20px' }}>
                    <button
                      onClick={() => setLiberoUnableModal({ ...liberoUnableModal, reason: 'declared' })}
                      style={{
                        padding: '14px 20px',
                        fontSize: '15px',
                        fontWeight: 600,
                        background: '#f97316',
                        color: '#000',
                        border: '1px solid rgba(0, 0, 0, 0.2)',
                        borderRadius: '10px',
                        cursor: 'pointer',
                        textAlign: 'left',
                        transition: 'all 0.2s',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        gap: '12px'
                      }}
                    >
                      <div>
                        <div style={{ fontWeight: 700 }}>Declared unable</div>
                        <div style={{ fontSize: '12px', opacity: 0.8, marginTop: '4px' }}>
                          Declares libero unable to continue
                        </div>
                      </div>
                      <span style={{ fontSize: '18px' }}>🗣️</span>
                    </button>
                    <button
                      onClick={() => setLiberoUnableModal({ ...liberoUnableModal, reason: 'injury' })}
                      style={{
                        padding: '14px 20px',
                        fontSize: '15px',
                        fontWeight: 600,
                        background: '#fef2f2',
                        color: '#991b1b',
                        border: '1px solid #fecaca',
                        borderRadius: '10px',
                        cursor: 'pointer',
                        textAlign: 'left',
                        transition: 'all 0.2s',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        gap: '12px'
                      }}
                    >
                      <div>
                        <div style={{ fontWeight: 700 }}>Injury / Illness</div>
                        <div style={{ fontSize: '12px', color: '#991b1b', marginTop: '4px' }}>
                          Libero is injured or ill
                        </div>
                      </div>
                      <span style={{ fontSize: '18px' }}>✚</span>
                    </button>
                  </div>
                  <div style={{ display: 'flex', justifyContent: 'center' }}>
                    <button
                      onClick={() => setLiberoUnableModal(null)}
                      style={{
                        padding: '10px 24px',
                        fontSize: '14px',
                        fontWeight: 600,
                        background: '#f3f4f6',
                        color: '#374151',
                        border: '1px solid #d1d5db',
                        borderRadius: '8px',
                        cursor: 'pointer'
                      }}
                    >
                      Cancel
                    </button>
                  </div>
                </>
              ) : (
                <>
                  {/* Confirmation */}
                  <div style={{ fontSize: '14px', color: '#6b7280', textAlign: 'center', marginBottom: '16px' }}>
                    {(() => {
                      const courtText = liberoUnableModal.isOnCourt ? ' The replaced player will return to court.' : ''
                      switch (liberoUnableModal.reason) {
                        case 'injury':
                          return `The libero will be marked as injured. They may return to play later unless a redesignation occurs.${courtText}`
                        case 'expulsion':
                          return `The libero is expelled and cannot play for the remainder of this set. They may return in the next set.${courtText}`
                        case 'disqualification':
                          return `The libero is disqualified and cannot play for the remainder of the match.${courtText}`
                        default: // 'declared'
                          return `The libero will be declared unable to play.${courtText}`
                      }
                    })()}
                  </div>
                  <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
                    <button
                      onClick={confirmLiberoUnable}
                      style={{
                        padding: '12px 28px',
                        fontSize: '15px',
                        fontWeight: 600,
                        background: '#ef4444',
                        color: '#fff',
                        border: 'none',
                        borderRadius: '8px',
                        cursor: 'pointer'
                      }}
                    >
                      Confirm
                    </button>
                    <button
                      onClick={() => setLiberoUnableModal(null)}
                      style={{
                        padding: '12px 28px',
                        fontSize: '15px',
                        fontWeight: 600,
                        background: '#f3f4f6',
                        color: '#374151',
                        border: '1px solid #d1d5db',
                        borderRadius: '8px',
                        cursor: 'pointer'
                      }}
                    >
                      Cancel
                    </button>
                  </div>
                </>
              )}
            </div>
          </div>
        )
      })()}

      {liberoReminder && (
        <Modal
          title={t('scoreboard.modals.liberoReminder')}
          open={true}
          onClose={() => {
            setLiberoReminder(null)
          }}
          width={480}
          hideCloseButton={true}
        >
          <div style={{ padding: '29px', textAlign: 'center' }}>
            <p style={{ marginBottom: '29px', fontSize: '19px' }}>
              Remember to insert the libero if available
            </p>
            {liberoReminder.teams.length > 1 && (
              <p style={{ marginBottom: '19px', fontSize: '17px', color: 'var(--muted)' }}>
                {liberoReminder.teams.map((team, idx) => {
                  const teamName = team === 'home'
                    ? (data?.homeTeam?.name || 'Home')
                    : (data?.awayTeam?.name || 'Away')
                  return (
                    <span key={team}>
                      {teamName}
                      {idx < liberoReminder.teams.length - 1 ? ' and ' : ''}
                    </span>
                  )
                })}
              </p>
            )}
            <div style={{ display: 'flex', gap: '14px', justifyContent: 'center' }}>
              <button
                onClick={() => {
                  setLiberoReminder(null)
                }}
                style={{
                  padding: '14px 29px',
                  fontSize: '17px',
                  fontWeight: 600,
                  background: 'rgba(255, 255, 255, 0.1)',
                  color: 'var(--text)',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '10px',
                  cursor: 'pointer'
                }}
              >
                Back
              </button>
              <button
                onClick={async () => {
                  setLiberoReminder(null)

                  // Show set start time confirmation
                  let defaultTime = roundToMinute(new Date().toISOString())

                  if (data?.set?.index === 1) {
                    // Use scheduled time from match
                    if (data?.match?.scheduledAt) {
                      defaultTime = roundToMinute(data.match.scheduledAt)
                    }
                  } else {
                    // Get previous set's end time
                    const allSets = await db.sets.where('matchId').equals(matchId).toArray()
                    const previousSet = allSets.find(s => s.index === (data.set.index - 1))
                    if (previousSet?.endTime) {
                      // Add 3 minutes to previous set end time
                      const prevEndTime = new Date(previousSet.endTime)
                      prevEndTime.setMinutes(prevEndTime.getMinutes() + 3)
                      defaultTime = prevEndTime.toISOString()
                    }
                  }

                  setSetStartTimeModal({ setIndex: data?.set?.index, defaultTime })
                }}
                style={{
                  padding: '14px 29px',
                  fontSize: '17px',
                  fontWeight: 600,
                  background: 'var(--accent)',
                  color: '#000',
                  border: 'none',
                  borderRadius: '10px',
                  cursor: 'pointer'
                }}
              >
                Continue
              </button>
            </div>
          </div>
        </Modal>
      )}

      {setStartTimeModal && (
        <SetStartTimeModal
          setIndex={setStartTimeModal.setIndex}
          defaultTime={setStartTimeModal.defaultTime}
          onConfirm={confirmSetStartTime}
          onCancel={() => setSetStartTimeModal(null)}
        />
      )}

      {setEndTimeModal && (
        <SetEndTimeModal
          setIndex={setEndTimeModal.setIndex}
          winner={setEndTimeModal.winner}
          homePoints={setEndTimeModal.homePoints}
          awayPoints={setEndTimeModal.awayPoints}
          defaultTime={setEndTimeModal.defaultTime}
          teamAKey={teamAKey}
          leftIsHome={leftIsHome}
          isMatchEnd={setEndTimeModal.isMatchEnd}
          homeTeamName={data?.homeTeam?.shortName || data?.homeTeam?.name || 'Home'}
          awayTeamName={data?.awayTeam?.shortName || data?.awayTeam?.name || 'Away'}
          onConfirm={confirmSetEndTime}
          onDecisionChange={async () => {
            // Track that user dismissed via undo to prevent re-showing
            setEndModalDismissedRef.current = setEndTimeModal.setIndex

            // Find the last point event directly and open decision modal
            if (data?.events && data?.set) {
              const currentSetEvents = data.events
                .filter(e => e.setIndex === data.set.index)
                .sort((a, b) => (b.seq || 0) - (a.seq || 0))

              // Find the last POINT event (ignoring set_end, sanctions, etc that might be after it)
              // We need to find the actual point that caused the set end condition
              const pointEvent = currentSetEvents.find(e => e.type === 'point')

              if (pointEvent) {
                // Open decision modal (no selectedOption forces choice)
                setReplayRallyConfirm({ event: pointEvent, description: 'Decision Change', selectedOption: null })
              }
            }

            // Close the set end modal
            setSetEndTimeModal(null)
          }}
        />
      )}

      {/* Sync Progress Modal - shown during set end sync */}
      <SyncProgressModal
        open={syncModalOpen}
        steps={syncState?.steps || []}
        errorMessage={syncState?.hasError ? t('scoreboard.sync.syncError', 'Sync failed. Data saved locally.') : null}
        onProceed={handleSyncProceed}
        isComplete={syncState?.isComplete || false}
        hasError={syncState?.hasError || false}
        hasWarning={syncState?.hasWarning || false}
      />

      {toSubDetailsModal && (
        <ToSubDetailsModal
          type={toSubDetailsModal.type}
          side={toSubDetailsModal.side}
          timeoutDetails={toSubDetailsModal.type === 'timeout' ? getTimeoutDetails(toSubDetailsModal.side) : null}
          substitutionDetails={toSubDetailsModal.type === 'substitution' ? getSubstitutionDetails(toSubDetailsModal.side) : null}
          teamName={toSubDetailsModal.side === 'left'
            ? (leftIsHome ? (data?.homeTeam?.name || 'Left Team') : (data?.awayTeam?.name || 'Left Team'))
            : (leftIsHome ? (data?.awayTeam?.name || 'Right Team') : (data?.homeTeam?.name || 'Right Team'))}
          onClose={() => setToSubDetailsModal(null)}
        />
      )}

      {sanctionConfirm && (
        <Modal
          title={t('scoreboard.modals.confirmSanction')}
          open={true}
          onClose={() => setSanctionConfirm(null)}
          width={400}
          hideCloseButton={true}
        >
          <div style={{ padding: '24px', textAlign: 'center' }}>
            <p style={{ marginBottom: '24px', fontSize: '16px' }}>
              Apply {sanctionConfirm.type === 'improper_request' ? 'Improper Request' :
                sanctionConfirm.type === 'delay_warning' ? 'Delay Warning' :
                  'Delay Penalty'} to Team {(() => {
                    const sideTeamKey = sanctionConfirm.side === 'left' ? (leftIsHome ? 'home' : 'away') : (leftIsHome ? 'away' : 'home')
                    return sideTeamKey === teamAKey ? 'A' : 'B'
                  })()}?
            </p>
            {sanctionConfirm.type === 'delay_penalty' && (
              <p style={{ marginBottom: '16px', fontSize: '14px', color: 'var(--muted)', fontStyle: 'italic' }}>
                This will award a point and service to the opponent team
              </p>
            )}
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
              <button
                onClick={confirmSanction}
                style={{
                  padding: '12px 24px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'var(--accent)',
                  color: '#000',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                Yes
              </button>
              <button
                onClick={() => setSanctionConfirm(null)}
                style={{
                  padding: '12px 24px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'rgba(255, 255, 255, 0.1)',
                  color: 'var(--text)',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                No
              </button>
            </div>
          </div>
        </Modal>
      )}

      {/* Connection Status Popover */}
      {connectionModal && connectionModal !== 'teamA' && connectionModal !== 'teamB' && (
        <div
          onClick={(e) => {
            if (e.target === e.currentTarget) {
              setConnectionModal(null)
            }
          }}
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            zIndex: 10000,
            background: 'transparent'
          }}
        >
          <div
            style={{
              position: 'absolute',
              left: `${connectionModalPosition.x}px`,
              top: `${connectionModalPosition.y}px`,
              background: 'rgba(15, 23, 42, 0.98)',
              border: '1px solid rgba(255,255,255,0.2)',
              borderRadius: '12px',
              padding: '16px',
              minWidth: '200px',
              boxShadow: '0 8px 32px rgba(0,0,0,0.4)',
              zIndex: 10001
            }}
            onClick={(e) => e.stopPropagation()}
          >
            {/* Thought bubble tail */}
            <div style={{
              position: 'absolute',
              top: '-7px',
              left: '20px',
              width: 0,
              height: 0,
              borderLeft: '8px solid transparent',
              borderRight: '8px solid transparent',
              borderBottom: '8px solid rgba(15, 23, 42, 0.98)'
            }} />
            <div style={{
              position: 'absolute',
              top: '-8px',
              left: '20px',
              width: 0,
              height: 0,
              borderLeft: '8px solid transparent',
              borderRight: '8px solid transparent',
              borderBottom: '8px solid rgba(255,255,255,0.2)'
            }} />

            <div style={{ marginBottom: '12px' }}>
              <div style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                marginBottom: '8px'
              }}>
                <span style={{ fontSize: '12px', fontWeight: 600, color: 'var(--text)' }}>
                  {connectionModal === 'referee' ? 'Referee Connection' : connectionModal === 'teamA' ? `Team ${teamAShortName} Connection` : `Team ${teamBShortName} Connection`}
                </span>
                <button
                  onClick={() => setConnectionModal(null)}
                  style={{
                    background: 'transparent',
                    border: 'none',
                    color: 'var(--muted)',
                    cursor: 'pointer',
                    fontSize: '18px',
                    lineHeight: 1,
                    padding: 0,
                    width: '20px',
                    height: '20px',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                  }}
                >
                  ×
                </button>
              </div>

              <label style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                cursor: 'pointer',
                padding: '8px 0'
              }}>
                <span style={{ fontSize: '11px', color: 'var(--muted)' }}>
                  Enable Dashboard
                </span>
                <div style={{
                  position: 'relative',
                  width: '44px',
                  height: '24px',
                  background: (connectionModal === 'referee' ? refereeConnectionEnabled : connectionModal === 'teamA' ? homeTeamConnectionEnabled : awayTeamConnectionEnabled) ? '#22c55e' : '#6b7280',
                  borderRadius: '12px',
                  transition: 'background 0.2s',
                  cursor: 'pointer'
                }}
                  onClick={(e) => {
                    e.stopPropagation()
                    if (connectionModal === 'referee') {
                      handleRefereeConnectionToggle(!refereeConnectionEnabled)
                    } else if (connectionModal === 'teamA') {
                      handleHomeTeamConnectionToggle(!homeTeamConnectionEnabled)
                    } else if (connectionModal === 'teamB') {
                      handleAwayTeamConnectionToggle(!awayTeamConnectionEnabled)
                    }
                  }}
                >
                  <div style={{
                    position: 'absolute',
                    top: '2px',
                    left: (connectionModal === 'referee' ? refereeConnectionEnabled : connectionModal === 'teamA' ? homeTeamConnectionEnabled : awayTeamConnectionEnabled) ? '22px' : '2px',
                    width: '20px',
                    height: '20px',
                    background: '#fff',
                    borderRadius: '50%',
                    transition: 'left 0.2s',
                    boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
                  }} />
                </div>
              </label>

              {(connectionModal === 'referee' ? refereeConnectionEnabled : connectionModal === 'teamA' ? homeTeamConnectionEnabled : awayTeamConnectionEnabled) && (
                <div style={{
                  marginTop: '12px',
                  padding: '12px',
                  background: 'rgba(0,0,0,0.3)',
                  borderRadius: '8px'
                }}>
                  <div style={{ fontSize: '10px', color: 'var(--muted)', marginBottom: '4px', textTransform: 'uppercase', letterSpacing: '0.5px' }}>
                    PIN
                  </div>
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    gap: '8px'
                  }}>
                    <span style={{
                      fontWeight: 700,
                      fontSize: '18px',
                      color: 'var(--accent)',
                      letterSpacing: '2px',
                      fontFamily: 'monospace'
                    }}>
                      {connectionModal === 'referee'
                        ? (data?.match?.refereePin || '—')
                        : connectionModal === 'teamA'
                          ? (data?.match?.homeTeamPin || '—')
                          : (data?.match?.awayTeamPin || '—')}
                    </span>
                    <button
                      onClick={(e) => {
                        e.stopPropagation()
                        handleEditPin(connectionModal === 'referee' ? 'referee' : connectionModal === 'teamA' ? 'teamA' : 'teamB')
                        setConnectionModal(null)
                      }}
                      style={{
                        padding: '4px 8px',
                        fontSize: '10px',
                        fontWeight: 600,
                        background: 'rgba(255,255,255,0.1)',
                        color: 'var(--text)',
                        border: '1px solid rgba(255,255,255,0.2)',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        whiteSpace: 'nowrap'
                      }}
                    >
                      Edit
                    </button>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Edit PIN Modal */}
      {editPinModal && (
        <Modal
          title={editPinType === 'referee' ? 'Edit Referee PIN' : editPinType === 'teamA' ? `Edit Team ${teamAShortName} PIN` : `Edit Team ${teamBShortName} PIN`}
          open={true}
          onClose={() => {
            setEditPinModal(false)
            setPinError('')
            setEditPinType(null)
          }}
          width={400}
        >
          <div style={{ padding: '24px' }}>
            <div style={{ marginBottom: '16px' }}>
              <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px', fontWeight: 600 }}>
                Enter new 6-digit PIN:
              </label>
              <input
                type="text"
                inputMode="numeric"
                pattern="[0-9]*"
                value={newPin}
                onChange={(e) => {
                  const value = e.target.value.replace(/\D/g, '')
                  if (value.length <= 6) {
                    setNewPin(value)
                    setPinError('')
                  }
                }}
                placeholder="000000"
                maxLength={6}
                style={{
                  width: '100%',
                  padding: '12px',
                  fontSize: '20px',
                  fontWeight: 700,
                  textAlign: 'center',
                  letterSpacing: '4px',
                  fontFamily: 'monospace',
                  background: 'var(--bg)',
                  border: pinError ? '2px solid #ef4444' : '2px solid rgba(255,255,255,0.2)',
                  borderRadius: '8px',
                  color: 'var(--text)'
                }}
              />
              {pinError && (
                <p style={{ color: '#ef4444', fontSize: '12px', marginTop: '8px' }}>
                  {pinError}
                </p>
              )}
            </div>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
              <button
                onClick={() => {
                  setEditPinModal(false)
                  setPinError('')
                  setEditPinType(null)
                }}
                style={{
                  padding: '10px 20px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'rgba(255,255,255,0.1)',
                  color: 'var(--text)',
                  border: '1px solid rgba(255,255,255,0.2)',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                Cancel
              </button>
              <button
                onClick={handleSavePin}
                style={{
                  padding: '10px 20px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'var(--accent)',
                  color: '#000',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                Save PIN
              </button>
            </div>
          </div>
        </Modal>
      )}

      {/* Court Switch Modal (5th Set at 8 points) - highest priority, blocks everything */}
      {courtSwitchModal && (
        <Modal
          title={t('scoreboard.modals.courtSwitchRequired')}
          open={true}
          onClose={() => { }}
          width={450}
          hideCloseButton={true}
          zIndex={2000}
        >
          <div style={{ padding: '24px', textAlign: 'center' }}>
            <p style={{ marginBottom: '16px', fontSize: '18px', fontWeight: 700, color: 'var(--accent)' }}>
              {t('scoreboard.modals.teamsMustSwitchCourts')}
            </p>
            <div style={{ marginBottom: '16px', fontSize: '16px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px' }}>
              <span style={{ background: data?.homeTeam?.color || '#ef4444', color: isBrightColor(data?.homeTeam?.color || '#ef4444') ? '#000' : '#fff', padding: '2px 6px', borderRadius: '4px', fontSize: '12px', fontWeight: 700 }}>{teamAKey === 'home' ? 'A' : 'B'}</span>
              <span>{data?.homeTeam?.shortName || data?.homeTeam?.name || 'Home'}</span>
              <strong style={{ fontSize: '20px' }}>{courtSwitchModal.homePoints} : {courtSwitchModal.awayPoints}</strong>
              <span>{data?.awayTeam?.shortName || data?.awayTeam?.name || 'Away'}</span>
              <span style={{ background: data?.awayTeam?.color || '#3b82f6', color: isBrightColor(data?.awayTeam?.color || '#3b82f6') ? '#000' : '#fff', padding: '2px 6px', borderRadius: '4px', fontSize: '12px', fontWeight: 700 }}>{teamAKey === 'away' ? 'A' : 'B'}</span>
            </div>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
              <button
                onClick={confirmCourtSwitch}
                style={{
                  flex: '1 1 0',
                  padding: '12px 32px',
                  fontSize: '16px',
                  fontWeight: 600,
                  background: 'var(--accent)',
                  color: '#000',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                {t('scoreboard.buttons.switchCourts')}
              </button>
              <button
                onClick={() => {
                  // Find the last point event to open decision change modal
                  if (data?.events && data?.set) {
                    const currentSetEvents = data.events
                      .filter(e => e.setIndex === data.set.index)
                      .sort((a, b) => (b.seq || 0) - (a.seq || 0))

                    const pointEvent = currentSetEvents.find(e => e.type === 'point')
                    if (pointEvent) {
                      setReplayRallyConfirm({ event: pointEvent, description: 'Decision Change', selectedOption: null })
                    }
                  }
                  // Close court switch modal
                  setCourtSwitchModal(null)
                }}
                style={{
                  flex: '1 1 0',
                  padding: '12px 32px',
                  fontSize: '16px',
                  fontWeight: 600,
                  background: '#facc15',
                  color: '#000',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                {t('scoreboard.buttons.decisionChange')}
              </button>
            </div>
          </div>
        </Modal>
      )}

      {/* Exceptional Substitution Modal */}
      {exceptionalSubstitutionModal && (() => {
        const { team, position, playerOut, reason } = exceptionalSubstitutionModal
        const teamLabel = team === teamAKey ? 'A' : 'B'
        const reasonText = reason === 'expulsion' ? 'expelled' : reason === 'disqualification' ? 'disqualified' : 'injured'
        const exceptionalSubstitutes = getAvailableExceptionalSubstitutes(team, playerOut)

        return (
          <Modal
            title={t('scoreboard.modals.noLegalSubstitution')}
            open={true}
            onClose={() => { }}
            width={500}
            hideCloseButton={true}
          >
            <div style={{ padding: '24px', textAlign: 'center' }}>
              <p style={{ marginBottom: '16px', fontSize: '18px', fontWeight: 700, color: 'var(--accent)' }}>
                Player #{playerOut} ({reasonText})
              </p>
              <p style={{ marginBottom: '16px', fontSize: '16px' }}>
                No legal substitution is possible for this player.
              </p>
              {exceptionalSubstitutes.length > 0 ? (
                <>
                  <p style={{ marginBottom: '24px', fontSize: '14px', color: 'var(--muted)' }}>
                    Choose an option:
                  </p>
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                    <button
                      onClick={() => handleExceptionalSubstitutionChoice('exceptional')}
                      style={{
                        padding: '16px 24px',
                        fontSize: '16px',
                        fontWeight: 600,
                        background: '#facc15',
                        color: '#000',
                        border: 'none',
                        borderRadius: '8px',
                        cursor: 'pointer',
                        textAlign: 'left'
                      }}
                    >
                      <div style={{ fontWeight: 700, marginBottom: '4px' }}>
                        Exceptional Substitution
                      </div>
                      <div style={{ fontSize: '13px', opacity: 0.8 }}>
                        Substitute with any eligible player on the bench (excluding liberos, expelled/disqualified players, and player #{playerOut}). Player #{playerOut} cannot take part in the game anymore.
                      </div>
                    </button>
                    <button
                      onClick={() => handleExceptionalSubstitutionChoice('forfait')}
                      style={{
                        padding: '16px 24px',
                        fontSize: '16px',
                        fontWeight: 600,
                        background: '#ef4444',
                        color: '#fff',
                        border: 'none',
                        borderRadius: '8px',
                        cursor: 'pointer',
                        textAlign: 'left'
                      }}
                    >
                      <div style={{ fontWeight: 700, marginBottom: '4px' }}>
                        Forfait
                      </div>
                      <div style={{ fontSize: '13px', opacity: 0.9 }}>
                        Opponent wins current set and all remaining sets (25-0 or 15-0 for set 5).
                      </div>
                    </button>
                  </div>
                </>
              ) : (
                <div style={{ marginTop: '24px', padding: '16px', background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)', borderRadius: '8px' }}>
                  <p style={{ marginBottom: '16px', fontSize: '16px', fontWeight: 600, color: '#ef4444' }}>
                    No exceptional substitution possible
                  </p>
                  <p style={{ marginBottom: '16px', fontSize: '14px', color: 'var(--muted)' }}>
                    No eligible players available for exceptional substitution. Forfait will be declared automatically.
                  </p>
                  <button
                    onClick={() => handleExceptionalSubstitutionChoice('forfait')}
                    style={{
                      padding: '12px 24px',
                      fontSize: '16px',
                      fontWeight: 600,
                      background: '#ef4444',
                      color: '#fff',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: 'pointer'
                    }}
                  >
                    Confirm Forfait
                  </button>
                </div>
              )}
            </div>
          </Modal>
        )
      })()}

      {/* Sanction Substitution Modal - for bench player (libero replacement) expelled/disqualified */}
      {sanctionSubstitutionModal && (() => {
        const { team, expelledPlayer, liberoOnCourt, availableSubs, reason, isExceptional } = sanctionSubstitutionModal
        const teamLabel = team === teamAKey ? 'A' : 'B'
        const teamData = team === 'home' ? data?.homeTeam : data?.awayTeam
        const teamColor = teamData?.color || (team === 'home' ? '#ef4444' : '#3b82f6')
        const reasonText = reason === 'expulsion' ? 'expelled' : 'disqualified'

        return (
          <Modal
            title={isExceptional ? 'Exceptional Substitution Required' : 'Substitution Required'}
            open={true}
            onClose={() => { }}
            width={450}
            hideCloseButton={true}
            zIndex={2000}
          >
            <div style={{ padding: '16px', textAlign: 'center' }}>
              {/* Team badge */}
              <div style={{
                display: 'inline-flex',
                alignItems: 'center',
                gap: '8px',
                padding: '8px 16px',
                background: teamColor,
                color: isBrightColor(teamColor) ? '#000' : '#fff',
                borderRadius: '8px',
                fontWeight: 700,
                fontSize: '14px',
                marginBottom: '16px'
              }}>
                Team {teamLabel}
              </div>

              <p style={{ marginBottom: '16px', fontSize: '16px' }}>
                Player <strong>#{expelledPlayer}</strong> has been <strong style={{ color: '#ef4444' }}>{reasonText}</strong>.
              </p>

              {liberoOnCourt && (
                <p style={{
                  marginBottom: '16px',
                  padding: '12px',
                  background: 'rgba(250, 204, 21, 0.1)',
                  border: '1px solid rgba(250, 204, 21, 0.3)',
                  borderRadius: '8px',
                  fontSize: '14px'
                }}>
                  Libero <strong>#{liberoOnCourt.liberoNumber}</strong> remains on court at position <strong>{liberoOnCourt.position}</strong>.
                </p>
              )}

              {isExceptional && (
                <p style={{
                  marginBottom: '16px',
                  padding: '8px 12px',
                  background: 'rgba(245, 158, 11, 0.1)',
                  border: '1px solid rgba(245, 158, 11, 0.3)',
                  borderRadius: '6px',
                  fontSize: '13px',
                  color: '#f59e0b'
                }}>
                  No legal substitutes available - exceptional substitution required.
                </p>
              )}

              <p style={{ marginBottom: '16px', fontWeight: 600, fontSize: '15px' }}>
                Select replacement player:
              </p>

              <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                {availableSubs.map(sub => (
                  <button
                    key={sub.number}
                    onClick={() => handleSanctionSubstitution(sub.number)}
                    style={{
                      padding: '14px 16px',
                      fontSize: '16px',
                      fontWeight: 600,
                      background: 'var(--accent)',
                      color: '#000',
                      border: 'none',
                      borderRadius: '8px',
                      cursor: 'pointer',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      gap: '8px'
                    }}
                  >
                    <span style={{ fontSize: '18px', fontWeight: 700 }}>#{sub.number}</span>
                    {sub.name && <span style={{ opacity: 0.8 }}>{sub.name}</span>}
                  </button>
                ))}
              </div>

              {/* Cancel/Forfeit option */}
              <div style={{ marginTop: '16px', paddingTop: '16px', borderTop: '1px solid rgba(255, 255, 255, 0.1)' }}>
                <button
                  onClick={async () => {
                    await handleForfait(team, reason === 'expulsion' ? 'expulsion' : 'disqualification')
                    setSanctionSubstitutionModal(null)
                  }}
                  style={{
                    padding: '10px 16px',
                    fontSize: '14px',
                    background: 'rgba(239, 68, 68, 0.2)',
                    color: '#ef4444',
                    border: '1px solid rgba(239, 68, 68, 0.4)',
                    borderRadius: '6px',
                    cursor: 'pointer'
                  }}
                >
                  Declare Forfeit Instead
                </button>
              </div>
            </div>
          </Modal>
        )
      })()}

      {/* Set 5 Side and Service Modal */}
      {set5SideServiceModal && (() => {
        const { set4LeftTeamLabel, set4RightTeamLabel, set4ServingTeamLabel } = set5SideServiceModal

        // Get team data based on selected left team
        const leftTeamKey = set5SelectedLeftTeam === 'A' ? teamAKey : teamBKey
        const rightTeamKey = set5SelectedLeftTeam === 'A' ? teamBKey : teamAKey
        const leftTeamData = leftTeamKey === 'home' ? data?.homeTeam : data?.awayTeam
        const rightTeamData = rightTeamKey === 'home' ? data?.homeTeam : data?.awayTeam
        const leftTeamName = leftTeamData?.name || `Team ${set5SelectedLeftTeam}`
        const rightTeamName = rightTeamData?.name || `Team ${set5SelectedLeftTeam === 'A' ? 'B' : 'A'}`
        const leftTeamColor = leftTeamData?.color || (leftTeamKey === 'home' ? '#ef4444' : '#3b82f6')
        const rightTeamColor = rightTeamData?.color || (rightTeamKey === 'home' ? '#ef4444' : '#3b82f6')

        // Determine which side is serving (left or right)
        const servingTeamLabel = set5SelectedFirstServe
        const leftTeamLabel = set5SelectedLeftTeam
        const rightTeamLabel = set5SelectedLeftTeam === 'A' ? 'B' : 'A'
        const leftIsServing = servingTeamLabel === leftTeamLabel
        const rightIsServing = servingTeamLabel === rightTeamLabel

        return (
          <Modal
            title={t('scoreboard.modals.set5ChooseSideService')}
            open={true}
            onClose={() => { }}
            width={500}
            hideCloseButton={true}
          >
            <div style={{ padding: '24px' }}>
              <p style={{ marginBottom: '24px', fontSize: '16px', textAlign: 'center' }}>
                Configure teams and service for Set 5.
              </p>

              {/* Teams on Sides */}
              <div style={{ marginBottom: '24px' }}>
                <div style={{
                  display: 'flex',
                  gap: '16px',
                  alignItems: 'center',
                  padding: '16px',
                  background: 'rgba(255, 255, 255, 0.05)',
                  borderRadius: '8px',
                  border: '1px solid rgba(255, 255, 255, 0.1)'
                }}>
                  {/* Team A Box */}
                  <div style={{
                    flex: 1,
                    textAlign: 'center',
                    padding: '16px',
                    background: leftTeamColor,
                    borderRadius: '8px',
                    border: '2px solid rgba(255, 255, 255, 0.3)',
                    position: 'relative'
                  }}>
                    <div style={{ fontSize: '18px', fontWeight: 700, color: '#fff', marginBottom: '4px' }}>
                      Team {leftTeamLabel}
                    </div>
                    <div style={{ fontSize: '14px', color: 'rgba(255, 255, 255, 0.9)', marginBottom: '8px' }}>
                      {leftTeamName}
                    </div>
                    {/* Serve ball underneath if serving */}
                    {leftIsServing && (
                      <img
                        src={ballImage} onError={(e) => e.target.src = mikasaVolleyball}
                        alt="Serving team"
                        style={{
                          width: '5vmin',
                          height: '5vmin',
                          objectFit: 'contain',
                          filter: 'drop-shadow(0 2px 6px rgba(0, 0, 0, 0.35))',
                          marginTop: '8px'
                        }}
                      />
                    )}
                  </div>

                  {/* Team B Box */}
                  <div style={{
                    flex: 1,
                    textAlign: 'center',
                    padding: '16px',
                    background: rightTeamColor,
                    borderRadius: '8px',
                    border: '2px solid rgba(255, 255, 255, 0.3)',
                    position: 'relative'
                  }}>
                    <div style={{ fontSize: '18px', fontWeight: 700, color: '#fff', marginBottom: '4px' }}>
                      Team {rightTeamLabel}
                    </div>
                    <div style={{ fontSize: '14px', color: 'rgba(255, 255, 255, 0.9)', marginBottom: '8px' }}>
                      {rightTeamName}
                    </div>
                    {/* Serve ball underneath if serving */}
                    {rightIsServing && (
                      <img
                        src={ballImage} onError={(e) => e.target.src = mikasaVolleyball}
                        alt="Serving team"
                        style={{
                          width: '5vmin',
                          height: '5vmin',
                          objectFit: 'contain',
                          filter: 'drop-shadow(0 2px 6px rgba(0, 0, 0, 0.35))',
                          marginTop: '8px'
                        }}
                      />
                    )}
                  </div>
                </div>

                {/* Switch Teams Button */}
                <div style={{ display: 'flex', justifyContent: 'center', marginTop: '16px' }}>
                  <button
                    onClick={() => {
                      setSet5SelectedLeftTeam(set5SelectedLeftTeam === 'A' ? 'B' : 'A')
                    }}
                    style={{
                      padding: '8px 16px',
                      fontSize: '14px',
                      fontWeight: 600,
                      background: 'rgba(255, 255, 255, 0.1)',
                      color: 'var(--text)',
                      border: '1px solid rgba(255, 255, 255, 0.2)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      whiteSpace: 'nowrap'
                    }}
                  >
                    Switch Teams
                  </button>
                </div>

                {/* Switch Serve Button */}
                <div style={{ display: 'flex', justifyContent: 'center', marginTop: '12px' }}>
                  <button
                    onClick={() => {
                      setSet5SelectedFirstServe(set5SelectedFirstServe === 'A' ? 'B' : 'A')
                    }}
                    style={{
                      padding: '8px 16px',
                      fontSize: '14px',
                      fontWeight: 600,
                      background: 'rgba(255, 255, 255, 0.1)',
                      color: 'var(--text)',
                      border: '1px solid rgba(255, 255, 255, 0.2)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      whiteSpace: 'nowrap'
                    }}
                  >
                    Switch Serve
                  </button>
                </div>
              </div>

              <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
                <button
                  onClick={() => confirmSet5SideService(set5SelectedLeftTeam, set5SelectedFirstServe)}
                  style={{
                    padding: '12px 32px',
                    fontSize: '16px',
                    fontWeight: 600,
                    background: 'var(--accent)',
                    color: '#000',
                    border: 'none',
                    borderRadius: '8px',
                    cursor: 'pointer'
                  }}
                >
                  Confirm
                </button>
              </div>
            </div>
          </Modal>
        )
      })()}

      {liberoRotationModal && !courtSwitchModal && !setEndTimeModal && (() => {
        const teamData = liberoRotationModal.team === 'home' ? data?.homeTeam : data?.awayTeam
        const teamColor = teamData?.color || (liberoRotationModal.team === 'home' ? '#ef4444' : '#3b82f6')
        const teamLabel = liberoRotationModal.team === teamAKey ? 'A' : 'B'
        const teamName = teamData?.name || (liberoRotationModal.team === 'home' ? 'Home' : 'Away')
        const liberoLabel = liberoRotationModal.liberoType === 'libero1' ? 'L1' : liberoRotationModal.liberoType === 'redesignated' ? 'LR' : 'L2'

        // Determine if this team is on the left or right side
        const isOnLeftSide = (liberoRotationModal.team === 'home') === leftIsHome

        // Get position from the appropriate ref
        const positionRef = isOnLeftSide ? leftCourtPositionVRef : rightCourtPositionIIRef
        const rect = positionRef.current?.getBoundingClientRect()

        // Calculate modal position (top-left corner at the position box)
        const modalTop = rect ? rect.top : (isOnLeftSide ? '50%' : '30%')
        const modalLeft = rect ? rect.left : (isOnLeftSide ? '10%' : '55%')

        return (
          <div
            style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.5)',
              zIndex: 9999
            }}
            onClick={() => setLiberoRotationModal(null)}
          >
            <div
              style={{
                position: 'absolute',
                top: typeof modalTop === 'number' ? `${modalTop}px` : modalTop,
                left: typeof modalLeft === 'number' ? `${modalLeft}px` : modalLeft,
                background: '#fff',
                borderRadius: '16px',
                padding: '24px 32px',
                minWidth: '320px',
                maxWidth: '400px',
                boxShadow: '0 8px 32px rgba(0, 0, 0, 0.3)'
              }}
              onClick={e => e.stopPropagation()}
            >
              {/* Header */}
              <div style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '12px',
                marginBottom: '16px',
                paddingBottom: '12px',
                borderBottom: '2px solid #e5e7eb'
              }}>
                <span style={{ fontSize: '18px', fontWeight: 600, color: '#1f2937' }}>{teamName}</span>
                <span style={{
                  padding: '4px 12px',
                  borderRadius: '6px',
                  fontSize: '14px',
                  fontWeight: 700,
                  background: teamColor,
                  color: isBrightColor(teamColor) ? '#000' : '#fff'
                }}>{teamLabel}</span>
              </div>

              {/* Message */}
              <div style={{
                fontSize: '14px',
                color: '#6b7280',
                textAlign: 'center',
                marginBottom: '16px'
              }}>
                Libero rotated to position IV
              </div>

              {/* Player IN and Libero OUT - side by side */}
              <div style={{ display: 'flex', gap: '12px', marginBottom: '20px' }}>
                {/* Player IN */}
                <div style={{
                  flex: 1,
                  padding: '14px',
                  background: '#dcfce7',
                  borderRadius: '12px',
                  border: '2px solid #22c55e',
                  textAlign: 'center'
                }}>
                  <div style={{
                    fontSize: '11px',
                    color: '#166534',
                    fontWeight: 600,
                    marginBottom: '6px',
                    textTransform: 'uppercase',
                    letterSpacing: '0.5px'
                  }}>
                    Player IN
                  </div>
                  <div style={{
                    fontSize: '26px',
                    fontWeight: 700,
                    color: '#166534'
                  }}>
                    #{liberoRotationModal.playerNumber}
                  </div>
                </div>

                {/* Libero OUT */}
                <div style={{
                  flex: 1,
                  padding: '14px',
                  background: '#fef2f2',
                  borderRadius: '12px',
                  border: '2px solid #ef4444',
                  textAlign: 'center'
                }}>
                  <div style={{
                    fontSize: '11px',
                    color: '#991b1b',
                    fontWeight: 600,
                    marginBottom: '6px',
                    textTransform: 'uppercase',
                    letterSpacing: '0.5px'
                  }}>
                    Libero OUT
                  </div>
                  <div style={{
                    fontSize: '26px',
                    fontWeight: 700,
                    color: '#991b1b'
                  }}>
                    #{liberoRotationModal.liberoNumber}
                  </div>
                  <div style={{
                    fontSize: '12px',
                    padding: '2px 8px',
                    background: '#ef4444',
                    color: '#fff',
                    borderRadius: '4px',
                    display: 'inline-block',
                    marginTop: '4px'
                  }}>{liberoLabel}</div>
                </div>
              </div>

              {/* OK Button */}
              <div style={{ display: 'flex', justifyContent: 'center' }}>
                <button
                  onClick={() => setLiberoRotationModal(null)}
                  style={{
                    padding: '12px 40px',
                    fontSize: '16px',
                    fontWeight: 600,
                    background: '#22c55e',
                    color: '#fff',
                    border: 'none',
                    borderRadius: '8px',
                    cursor: 'pointer'
                  }}
                >
                  OK
                </button>
              </div>
            </div>
          </div>
        )
      })()}

      {undoConfirm && (
        <Modal
          title={t('scoreboard.modals.confirmUndo')}
          open={true}
          onClose={cancelUndo}
          width={400}
        >
          <div style={{ padding: '24px', textAlign: 'center' }}>
            <p style={{ marginBottom: '16px', fontSize: '16px' }}>
              Do you want to undo action?
            </p>
            <p style={{ marginBottom: '24px', fontSize: '14px', color: 'var(--muted)', fontStyle: 'italic' }}>
              {undoConfirm.description}
            </p>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
              <button
                onClick={handleUndo}
                style={{
                  padding: '12px 24px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'var(--accent)',
                  color: '#000',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                Yes
              </button>
              <button
                onClick={cancelUndo}
                style={{
                  padding: '12px 24px',
                  fontSize: '14px',
                  fontWeight: 600,
                  background: 'rgba(255, 255, 255, 0.1)',
                  color: 'var(--text)',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '8px',
                  cursor: 'pointer'
                }}
              >
                Cancel
              </button>
            </div>
          </div>
        </Modal>
      )}

      {replayRallyConfirm && (() => {
        const lastEvent = replayRallyConfirm.event
        const oldTeam = lastEvent?.payload?.team
        const newTeam = oldTeam === 'home' ? 'away' : 'home'
        const selectedOption = replayRallyConfirm.selectedOption || 'swap'

        // Current scores
        const currentHomePoints = data?.set?.homePoints || 0
        const currentAwayPoints = data?.set?.awayPoints || 0

        // Calculate new scores for swap option
        const swapHomePoints = oldTeam === 'home' ? currentHomePoints - 1 : currentHomePoints + 1
        const swapAwayPoints = oldTeam === 'away' ? currentAwayPoints - 1 : currentAwayPoints + 1

        // Calculate new scores for replay option
        const replayHomePoints = oldTeam === 'home' ? currentHomePoints - 1 : currentHomePoints
        const replayAwayPoints = oldTeam === 'away' ? currentAwayPoints - 1 : currentAwayPoints

        // Get team names for display
        const homeTeamName = data?.homeTeam?.shortName || data?.homeTeam?.name || 'Home'
        const awayTeamName = data?.awayTeam?.shortName || data?.awayTeam?.name || 'Away'
        const oldTeamName = oldTeam === 'home' ? homeTeamName : awayTeamName
        const newTeamName = newTeam === 'home' ? homeTeamName : awayTeamName

        // A/B labels and team colors
        const homeLabel = teamAKey === 'home' ? 'A' : 'B'
        const awayLabel = teamAKey === 'away' ? 'A' : 'B'
        const oldTeamLabel = oldTeam === 'home' ? homeLabel : awayLabel
        const homeColor = data?.homeTeam?.color || '#ef4444'
        const awayColor = data?.awayTeam?.color || '#3b82f6'
        const oldTeamColor = oldTeam === 'home' ? homeColor : awayColor

        // Determine which team has serve after each option
        // For swap: the new team gets the point, so they get/keep serve
        // For replay: no point scored, serve stays with who had it before this point
        const swapServeTeam = newTeam
        const replayServeTeam = oldTeam // The team that WAS going to have serve (sideout was reversed)

        // Helper to render team with A/B badge
        const TeamWithLabel = ({ team, name }) => (
          <span style={{ display: 'inline-flex', alignItems: 'center', gap: '4px' }}>
            <span style={{
              background: 'var(--accent)',
              color: '#000',
              padding: '1px 5px',
              borderRadius: '4px',
              fontSize: '11px',
              fontWeight: 700
            }}>{team === 'home' ? homeLabel : awayLabel}</span>
            {name}
          </span>
        )

        return (
          <Modal
            title={t('scoreboard.modals.decisionChange')}
            open={true}
            onClose={cancelReplayRally}
            width={500}
          >
            <div style={{ padding: '24px' }}>
              <p style={{ marginBottom: '16px', fontSize: '14px', color: 'var(--muted)', textAlign: 'center' }}>
                Last point was assigned to <strong><span style={{ background: oldTeamColor, color: isBrightColor(oldTeamColor) ? '#000' : '#fff', padding: '2px 6px', borderRadius: '4px', fontSize: '11px', fontWeight: 700, marginRight: '4px' }}>{oldTeamLabel}</span>{oldTeamName}</strong>
              </p>

              {/* Horizontal radio buttons */}
              <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
                {/* Option 1: Swap */}
                <div
                  onClick={() => setReplayRallyConfirm({ ...replayRallyConfirm, selectedOption: 'swap' })}
                  style={{
                    flex: 1,
                    padding: '12px 16px',
                    background: selectedOption === 'swap' ? 'rgba(234, 179, 8, 0.2)' : 'rgba(255, 255, 255, 0.05)',
                    border: selectedOption === 'swap' ? '2px solid #eab308' : '1px solid rgba(255, 255, 255, 0.1)',
                    borderRadius: '8px',
                    cursor: 'pointer',
                    transition: 'all 0.2s',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: '10px'
                  }}
                >
                  <div style={{
                    width: '18px',
                    height: '18px',
                    borderRadius: '50%',
                    border: selectedOption === 'swap' ? '5px solid #eab308' : '2px solid rgba(255, 255, 255, 0.3)',
                    background: selectedOption === 'swap' ? '#eab308' : 'transparent',
                    flexShrink: 0
                  }} />
                  <span style={{ fontSize: '13px', fontWeight: 600 }}>Assign to other team</span>
                </div>

                {/* Option 2: Replay */}
                <div
                  onClick={() => setReplayRallyConfirm({ ...replayRallyConfirm, selectedOption: 'replay' })}
                  style={{
                    flex: 1,
                    padding: '12px 16px',
                    background: selectedOption === 'replay' ? 'rgba(234, 179, 8, 0.2)' : 'rgba(255, 255, 255, 0.05)',
                    border: selectedOption === 'replay' ? '2px solid #eab308' : '1px solid rgba(255, 255, 255, 0.1)',
                    borderRadius: '8px',
                    cursor: 'pointer',
                    transition: 'all 0.2s',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: '10px'
                  }}
                >
                  <div style={{
                    width: '18px',
                    height: '18px',
                    borderRadius: '50%',
                    border: selectedOption === 'replay' ? '5px solid #eab308' : '2px solid rgba(255, 255, 255, 0.3)',
                    background: selectedOption === 'replay' ? '#eab308' : 'transparent',
                    flexShrink: 0
                  }} />
                  <span style={{ fontSize: '13px', fontWeight: 600 }}>Replay the rally</span>
                </div>
              </div>

              {/* Expanded details panel */}
              <div style={{
                padding: '16px',
                marginBottom: '20px',
                background: 'rgba(234, 179, 8, 0.1)',
                border: '1px solid rgba(234, 179, 8, 0.3)',
                borderRadius: '8px'
              }}>
                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '10px', fontSize: '13px', color: 'var(--muted)' }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                    <span style={{ width: '55px', textAlign: 'right' }}>Current:</span>
                    <div style={{ background: 'rgba(255, 255, 255, 0.1)', padding: '6px 12px', borderRadius: '6px', border: '1px solid rgba(255, 255, 255, 0.2)', display: 'flex', alignItems: 'center', gap: '6px' }}>
                      <span style={{ background: homeColor, color: isBrightColor(homeColor) ? '#000' : '#fff', padding: '2px 6px', borderRadius: '4px', fontSize: '10px', fontWeight: 700 }}>{homeLabel}</span>
                      <strong>{homeTeamName} {currentHomePoints} : {currentAwayPoints} {awayTeamName}</strong>
                      <span style={{ background: awayColor, color: isBrightColor(awayColor) ? '#000' : '#fff', padding: '2px 6px', borderRadius: '4px', fontSize: '10px', fontWeight: 700 }}>{awayLabel}</span>
                    </div>
                  </div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                    <span style={{ width: '55px', textAlign: 'right' }}>New:</span>
                    <div style={{ background: 'rgba(34, 197, 94, 0.15)', padding: '6px 12px', borderRadius: '6px', border: '1px solid rgba(34, 197, 94, 0.4)', display: 'flex', alignItems: 'center', gap: '6px' }}>
                      <span style={{ background: homeColor, color: isBrightColor(homeColor) ? '#000' : '#fff', padding: '2px 6px', borderRadius: '4px', fontSize: '10px', fontWeight: 700 }}>{homeLabel}</span>
                      <strong style={{ color: '#22c55e' }}>
                        {homeTeamName} {selectedOption === 'swap' ? swapHomePoints : replayHomePoints} : {selectedOption === 'swap' ? swapAwayPoints : replayAwayPoints} {awayTeamName}
                      </strong>
                      <span style={{ background: awayColor, color: isBrightColor(awayColor) ? '#000' : '#fff', padding: '2px 6px', borderRadius: '4px', fontSize: '10px', fontWeight: 700 }}>{awayLabel}</span>
                    </div>
                  </div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                    <span style={{ width: '55px', textAlign: 'right' }}>Serve:</span>
                    <span style={{ fontSize: '16px' }}>🏐</span>
                    <span style={{ background: (selectedOption === 'swap' ? swapServeTeam : replayServeTeam) === 'home' ? homeColor : awayColor, color: isBrightColor((selectedOption === 'swap' ? swapServeTeam : replayServeTeam) === 'home' ? homeColor : awayColor) ? '#000' : '#fff', padding: '2px 6px', borderRadius: '4px', fontSize: '10px', fontWeight: 700 }}>
                      {(selectedOption === 'swap' ? swapServeTeam : replayServeTeam) === 'home' ? homeLabel : awayLabel}
                    </span>
                    <strong>{(selectedOption === 'swap' ? swapServeTeam : replayServeTeam) === 'home' ? homeTeamName : awayTeamName}</strong>
                  </div>
                </div>
              </div>

              {/* Buttons */}
              <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
                <button
                  onClick={handleDecisionChange}
                  style={{
                    padding: '12px 32px',
                    fontSize: '14px',
                    fontWeight: 600,
                    background: '#eab308',
                    color: '#000',
                    border: 'none',
                    borderRadius: '8px',
                    cursor: 'pointer'
                  }}
                >
                  Confirm
                </button>
                <button
                  onClick={cancelReplayRally}
                  style={{
                    padding: '12px 32px',
                    fontSize: '14px',
                    fontWeight: 600,
                    background: 'rgba(255, 255, 255, 0.1)',
                    color: 'var(--text)',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    borderRadius: '8px',
                    cursor: 'pointer'
                  }}
                >
                  Cancel
                </button>
              </div>
            </div>
          </Modal>
        )
      })()}



      {postMatchSignature && (
        <Modal
          title={`${postMatchSignature === 'home-captain' ? (data?.homeTeam?.name || 'Home') : (data?.awayTeam?.name || 'Away')} Captain Signature`}
          open={true}
          onClose={() => setPostMatchSignature(null)}
          width={500}
        >
          <div style={{ padding: '24px' }}>
            <SignaturePad
              onSave={async (signatureDataUrl) => {
                const fieldName = postMatchSignature === 'home-captain' ? 'homePostGameCaptainSignature' : 'awayPostGameCaptainSignature'
                await db.matches.update(matchId, { [fieldName]: signatureDataUrl })
                setPostMatchSignature(null)
              }}
              onCancel={() => setPostMatchSignature(null)}
            />
          </div>
        </Modal>
      )}

    </div>
  )
}

function ScoreboardToolbar({ children, collapsed, onToggle }) {
  return (
    <div style={{ position: 'relative' }}>
      <div
        className="match-toolbar"
        style={{
          display: collapsed ? 'none' : 'grid',
          transition: 'all 0.2s ease'
        }}
      >
        {children}
      </div>
      {/* Collapse/Expand arrow button at bottom center */}
      <div
        onClick={onToggle}
        onMouseEnter={(e) => e.currentTarget.style.opacity = '1'}
        onMouseLeave={(e) => e.currentTarget.style.opacity = '0.25'}
        style={{
          position: 'absolute',
          top: collapsed ? '0' : '100%',
          left: '50%',
          transform: 'translateX(-50%)',
          width: '40px',
          height: '24px',
          background: '#22c55e',
          borderRadius: '0 0 8px 8px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          cursor: 'pointer',
          zIndex: 100,
          boxShadow: '0 2px 8px rgba(0, 0, 0, 0.3)',
          transition: 'all 0.2s ease',
          opacity: 0.25
        }}
      >
        <span style={{
          fontSize: '14px',
          color: '#000',
          fontWeight: 700,
          transform: collapsed ? 'rotate(180deg)' : 'rotate(0deg)',
          transition: 'transform 0.2s ease'
        }}>
          ▲
        </span>
      </div>
    </div>
  )
}

function ScoreboardTeamColumn({ side, children }) {
  return (
    <aside className="team-controls" data-side={side}>
      {children}
    </aside>
  )
}

function ScoreboardCourtColumn({ children }) {
  return <section className="court-wrapper">{children}</section>
}

function LineupModal({ team, teamData, players, matchId, setIndex, mode = 'initial', lineup: presetLineup = null, teamAKey, teamBKey, onClose, onSave, onLineupSaved }) {
  const { t } = useTranslation()
  const [lineup, setLineup] = useState(() => {
    if (presetLineup) {
      const positionMapping = ['IV', 'III', 'II', 'V', 'VI', 'I']
      return positionMapping.map(pos => (presetLineup[pos] !== undefined ? String(presetLineup[pos] ?? '') : ''))
    }
    return ['', '', '', '', '', '']
  }) // [IV, III, II, V, VI, I]
  const [errors, setErrors] = useState({}) // Use an object for specific error messages
  const [confirmMessage, setConfirmMessage] = useState(null)
  const [editHistory, setEditHistory] = useState([]) // Track edit history: [{ index, previousValue }]

  // Get all events to check for disqualifications
  const events = useLiveQuery(async () => {
    return await db.events.where('matchId').equals(matchId).toArray()
  }, [matchId])

  const handleInputChange = (index, value, skipHistory = false) => {
    const numValue = value.replace(/[^0-9]/g, '')
    const previousValue = lineup[index]

    // Track edit history (only if the value actually changed and not skipping)
    if (!skipHistory && numValue !== previousValue) {
      setEditHistory(prev => [...prev, { index, previousValue }])
    }

    const newLineup = [...lineup]
    newLineup[index] = numValue
    setLineup(newLineup)

    // Automatically validate the number as it's entered
    if (numValue && numValue.trim() !== '') {
      const num = Number(numValue)
      const player = players?.find(p => String(p.number) === String(num))
      const newErrors = { ...errors }

      // Check if not on roster
      if (!player) {
        newErrors[index] = 'Not on roster'
      }
      // Check if it's a libero
      else if (player.libero && player.libero !== '') {
        newErrors[index] = 'Cannot be libero'
      }
      // Check if disqualified
      else if (events) {
        const isDisqualified = events.some(e =>
          e.type === 'sanction' &&
          e.payload?.team === team &&
          e.payload?.playerNumber === num &&
          e.payload?.type === 'disqualification'
        )
        if (isDisqualified) {
          newErrors[index] = 'Disqualified'
        }
        // Check if exceptionally substituted
        else {
          const wasExceptionallySubstituted = events.some(e =>
            e.type === 'substitution' &&
            e.payload?.team === team &&
            String(e.payload?.playerOut) === String(num) &&
            e.payload?.isExceptional === true
          )
          if (wasExceptionallySubstituted) {
            newErrors[index] = 'Exceptionally substituted'
          } else {
            // Clear error if valid
            delete newErrors[index]
          }
        }
      } else {
        // Clear error if valid
        delete newErrors[index]
      }

      setErrors(newErrors)
    } else {
      // Clear error when field is empty
      const newErrors = { ...errors }
      delete newErrors[index]
      setErrors(newErrors)
    }

    setConfirmMessage(null)
  }

  // Handle click on available player - SINGLE click assigns to first available position
  const handlePlayerClick = (playerNumber) => {
    // Find first empty box (I to VI order: indices 5, 2, 1, 0, 3, 4 for I, II, III, IV, V, VI)
    const positionOrder = [5, 2, 1, 0, 3, 4] // I, II, III, IV, V, VI
    for (const idx of positionOrder) {
      if (!lineup[idx] || lineup[idx].trim() === '') {
        handleInputChange(idx, String(playerNumber))
        break
      }
    }
  }

  // Drag and drop state
  const [draggedPlayer, setDraggedPlayer] = useState(null)
  const [dragOverPosition, setDragOverPosition] = useState(null)

  // Handle drag start for available players
  const handleDragStart = (e, playerNumber) => {
    setDraggedPlayer(playerNumber)
    e.dataTransfer.setData('text/plain', String(playerNumber))
    e.dataTransfer.effectAllowed = 'move'

    // Create custom drag image showing the player number
    const dragImage = document.createElement('div')
    dragImage.textContent = String(playerNumber)
    dragImage.style.cssText = `
      position: absolute;
      top: -1000px;
      left: -1000px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: #4ade80;
      color: #000;
      font-size: 20px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `
    document.body.appendChild(dragImage)
    e.dataTransfer.setDragImage(dragImage, 25, 25)

    // Clean up drag image after a short delay
    setTimeout(() => {
      document.body.removeChild(dragImage)
    }, 0)
  }

  const handleDragEnd = () => {
    setDraggedPlayer(null)
    setDragOverPosition(null)
  }

  // Handle drag over for position inputs
  const handleDragOver = (e, positionIndex) => {
    e.preventDefault()
    e.dataTransfer.dropEffect = 'move'
    setDragOverPosition(positionIndex)
  }

  const handleDragLeave = () => {
    setDragOverPosition(null)
  }

  // Handle drop on position input
  const handleDrop = (e, positionIndex) => {
    e.preventDefault()
    const playerNumber = e.dataTransfer.getData('text/plain')
    if (playerNumber) {
      handleInputChange(positionIndex, playerNumber)
    }
    setDraggedPlayer(null)
    setDragOverPosition(null)
  }

  // Undo the last edit
  const handleUndoLastEdit = () => {
    if (editHistory.length === 0) return

    const lastEdit = editHistory[editHistory.length - 1]
    // Restore the previous value (skip history tracking for undo)
    handleInputChange(lastEdit.index, lastEdit.previousValue, true)
    // Remove the last entry from history
    setEditHistory(prev => prev.slice(0, -1))
    setConfirmMessage(null)
  }

  // Clear all lineup entries
  const handleClearLineup = () => {
    // Save current state to history before clearing
    lineup.forEach((value, index) => {
      if (value && value.trim() !== '') {
        setEditHistory(prev => [...prev, { index, previousValue: value }])
      }
    })
    setLineup(['', '', '', '', '', ''])
    setErrors({})
    setConfirmMessage(null)
  }

  // Rotate lineup clockwise (forward): I->II, II->III, III->IV, IV->V, V->VI, VI->I
  // Array indices: [IV=0, III=1, II=2, V=3, VI=4, I=5]
  // Clockwise means each player moves to next position: 0->3, 1->0, 2->1, 3->4, 4->5, 5->2
  const handleRotateClockwise = () => {
    const newLineup = ['', '', '', '', '', '']
    // IV(0) -> V(3), III(1) -> IV(0), II(2) -> III(1), V(3) -> VI(4), VI(4) -> I(5), I(5) -> II(2)
    newLineup[3] = lineup[0]  // IV -> V
    newLineup[0] = lineup[1]  // III -> IV
    newLineup[1] = lineup[2]  // II -> III
    newLineup[4] = lineup[3]  // V -> VI
    newLineup[5] = lineup[4]  // VI -> I
    newLineup[2] = lineup[5]  // I -> II
    setLineup(newLineup)
    setConfirmMessage(null)
  }

  // Rotate lineup counterclockwise (backward): I->VI, VI->V, V->IV, IV->III, III->II, II->I
  const handleRotateCounterClockwise = () => {
    const newLineup = ['', '', '', '', '', '']
    // IV(0) -> III(1), III(1) -> II(2), II(2) -> I(5), V(3) -> IV(0), VI(4) -> V(3), I(5) -> VI(4)
    newLineup[1] = lineup[0]  // IV -> III
    newLineup[2] = lineup[1]  // III -> II
    newLineup[5] = lineup[2]  // II -> I
    newLineup[0] = lineup[3]  // V -> IV
    newLineup[3] = lineup[4]  // VI -> V
    newLineup[4] = lineup[5]  // I -> VI
    setLineup(newLineup)
    setConfirmMessage(null)
  }

  // Modify lineup (undo confirm and go back to editing)
  const handleModify = () => {
    setConfirmMessage(null)
  }

  const handleConfirm = () => {
    const newErrors = {}
    const lineupNumbers = lineup.map(n => (n ? Number(n) : null))

    // Check for duplicates first, as it's a cross-field validation
    const numberCounts = lineupNumbers.reduce((acc, num) => {
      if (num !== null) acc[num] = (acc[num] || 0) + 1
      return acc
    }, {})

    lineup.forEach((numStr, i) => {
      // 1. Required
      if (!numStr || numStr.trim() === '') {
        newErrors[i] = 'Required'
        return // Move to next input
      }

      const num = Number(numStr)

      // 2. Duplicate
      if (numberCounts[num] > 1) {
        newErrors[i] = 'Duplicate'
        // Don't return, so we can flag all duplicates
      }

      const player = players?.find(p => String(p.number) === String(num))

      // 3. Not on roster
      if (!player) {
        newErrors[i] = 'Not on roster'
        return
      }

      // 4. Is a libero
      if (player.libero && player.libero !== '') {
        newErrors[i] = 'Cannot be libero'
        return
      }

      // 5. Is disqualified - cannot enter the game ever again
      if (events) {
        const isDisqualified = events.some(e =>
          e.type === 'sanction' &&
          e.payload?.team === team &&
          e.payload?.playerNumber === num &&
          e.payload?.type === 'disqualification'
        )
        if (isDisqualified) {
          newErrors[i] = 'Disqualified'
          return
        }
      }

      // 6. Was exceptionally substituted - cannot take part in the game anymore
      if (events) {
        const wasExceptionallySubstituted = events.some(e =>
          e.type === 'substitution' &&
          e.payload?.team === team &&
          String(e.payload?.playerOut) === String(num) &&
          e.payload?.isExceptional === true
        )
        if (wasExceptionallySubstituted) {
          newErrors[i] = 'Exceptionally substituted'
          return
        }
      }
    })

    // Re-check for duplicates to mark all of them
    lineupNumbers.forEach((num, i) => {
      if (num !== null && numberCounts[num] > 1) {
        newErrors[i] = 'Duplicate'
      }
    })

    setErrors(newErrors)

    if (Object.keys(newErrors).length > 0) {
      return
    }

    // Check if captain is in court
    const captain = players?.find(p => p.isCaptain)
    const captainInCourt = captain && lineupNumbers.includes(captain.number)

    // Save lineup: Map positions I->I, II->II, III->III, IV->IV, V->V, VI->VI
    // Lineup array indices: [0=IV, 1=III, 2=II, 3=V, 4=VI, 5=I]
    const positionMapping = ['IV', 'III', 'II', 'V', 'VI', 'I']
    const lineupData = {}
    positionMapping.forEach((pos, idx) => {
      lineupData[pos] = lineupNumbers[idx]
    })

    // Save lineup as an event (mark as initial lineup or manual override)
    if (matchId && setIndex) {
      // Save lineup with sequence number
      (async () => {
        // Get next sequence number
        const allEvents = await db.events.where('matchId').equals(matchId).toArray()
        const maxSeq = allEvents.reduce((max, e) => Math.max(max, e.seq || 0), 0)

        const manualLineupSeq = maxSeq + 1
        const manualLineupEventId = await db.events.add({
          matchId,
          setIndex,
          ts: new Date().toISOString(),
          type: 'lineup',
          payload: {
            team,
            lineup: lineupData,
            isInitial: mode === 'initial'
          },
          seq: manualLineupSeq
        })

        // Sync to referee immediately after lineup is saved
        if (onLineupSaved) {
          onLineupSaved()
        }

        // Check if both lineups are now set - if so, award any pending penalty points
        // Reuse allEvents from above to avoid redeclaration
        const homeLineupSet = allEvents.some(e =>
          e.type === 'lineup' &&
          e.payload?.team === 'home' &&
          e.setIndex === setIndex &&
          e.payload?.isInitial
        )
        const awayLineupSet = allEvents.some(e =>
          e.type === 'lineup' &&
          e.payload?.team === 'away' &&
          e.setIndex === setIndex &&
          e.payload?.isInitial
        )

        if (homeLineupSet && awayLineupSet) {
          // Both lineups are set - check for pending penalty sanctions in this set
          const pendingPenalties = allEvents.filter(e =>
            e.type === 'sanction' &&
            e.setIndex === setIndex &&
            e.payload?.type === 'penalty'
          )

          // Check if points have already been awarded for these penalties
          const pointEvents = allEvents.filter(e => e.type === 'point' && e.setIndex === setIndex)

          if (pendingPenalties.length > 0 && pointEvents.length === 0) {
            // Award points for each pending penalty
            for (const penalty of pendingPenalties) {
              const sanctionedTeam = penalty.payload?.team
              const otherTeam = sanctionedTeam === 'home' ? 'away' : 'home'

              // Award point to the other team
              const currentSet = await db.sets.where('matchId').equals(matchId).and(s => s.index === setIndex).first()
              if (currentSet) {
                const field = otherTeam === 'home' ? 'homePoints' : 'awayPoints'
                const currentPoints = currentSet[field] || 0
                await db.sets.update(currentSet.id, {
                  [field]: currentPoints + 1
                })

                // Log point event
                const penaltyPointSeq = maxSeq + 2 + pendingPenalties.indexOf(penalty)
                await db.events.add({
                  matchId,
                  setIndex,
                  ts: new Date().toISOString(),
                  type: 'point',
                  payload: { team: otherTeam, fromPenalty: true },
                  seq: penaltyPointSeq
                })

              }
            }
          }
        }

        // Auto-close modal after successful save (skip confirmation step)
        onSave()
      })().catch(err => {
        // Don't auto-close - let user close manually with close button
        setErrors({ 0: 'Save failed', 1: 'Save failed', 2: 'Save failed', 3: 'Save failed', 4: 'Save failed', 5: 'Save failed' })
      })
    } else {
      // Auto-close modal after successful save
      onSave()
    }
  }

  // Determine if this team is A or B
  const isTeamA = team === teamAKey
  const teamLabel = isTeamA ? 'A' : 'B'
  const teamColor = teamData?.color || (isTeamA ? '#ef4444' : '#3b82f6')

  // Helper function to determine if a color is bright
  const isBrightColor = (color) => {
    if (!color) return false
    const hex = color.replace('#', '')
    const r = parseInt(hex.substr(0, 2), 16)
    const g = parseInt(hex.substr(2, 2), 16)
    const b = parseInt(hex.substr(4, 2), 16)
    const brightness = (r * 299 + g * 587 + b * 114) / 1000
    return brightness > 155
  }

  return (
    <Modal
      title={
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
          <span>{teamData?.name || (team === 'home' ? 'Home' : 'Away')}</span>
          <span
            style={{
              padding: '4px 12px',
              borderRadius: '6px',
              fontSize: '14px',
              fontWeight: 700,
              background: teamColor,
              color: isBrightColor(teamColor) ? '#000' : '#fff'
            }}
          >
            {teamLabel}
          </span>
        </div>
      }
      open={true}
      onClose={onClose}
      width={500}
      hideCloseButton={true}
    >
      <div style={{ padding: '24px' }}>
        {/* Centered container for position inputs */}
        <div style={{
          display: 'flex',
          justifyContent: 'center',
          marginBottom: '24px'
        }}>
          <div className="lineup-grid" style={{
            display: 'grid',
            gridTemplateColumns: 'repeat(3, 1fr)',
            gap: '8px',
            position: 'relative'
          }}>
            {/* Net indicator */}
            <div style={{
              position: 'absolute',
              top: '-8px',
              left: '50%',
              transform: 'translateX(-50%)',
              width: '100%',
              height: '2px',
              background: 'var(--accent)',
              zIndex: 1
            }} />
            <div style={{
              position: 'absolute',
              top: '-20px',
              left: '50%',
              transform: 'translateX(-50%)',
              fontSize: '12px',
              fontWeight: 600,
              color: 'var(--accent)',
              zIndex: 2,
              background: 'var(--bg)',
              padding: '0 8px'
            }}>
            </div>

            {/* Top row (closer to net) */}
            {[
              { idx: 0, pos: 'IV' },
              { idx: 1, pos: 'III' },
              { idx: 2, pos: 'II' }
            ].map(({ idx, pos }) => (
              <div key={`top-${idx}`} style={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center'
              }}>
                {/* Position label rectangle */}
                <div style={{
                  width: '60px',
                  height: '24px',
                  background: 'rgba(255, 255, 255, 0.1)',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '4px 4px 0 0',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: '12px',
                  fontWeight: 600,
                  color: 'var(--text)'
                }}>
                  {pos}
                </div>
                {/* Input square with captain indicator (circled number) - droppable */}
                <div
                  style={{ position: 'relative', width: '60px' }}
                  onDragOver={(e) => handleDragOver(e, idx)}
                  onDragLeave={handleDragLeave}
                  onDrop={(e) => handleDrop(e, idx)}
                >
                  <input
                    type="text"
                    inputMode="numeric"
                    min="1"
                    max="99"
                    value={lineup[idx]}
                    onChange={e => {
                      const val = e.target.value.replace(/[^0-9]/g, '')
                      if (val === '' || (Number(val) >= 1 && Number(val) <= 99)) {
                        handleInputChange(idx, val)
                      }
                    }}
                    onKeyDown={e => {
                      if (e.key === 'Enter') {
                        e.preventDefault()
                        // Counterclockwise order: I(5) → II(2) → III(1) → IV(0) → V(3) → VI(4) → I(5)
                        const counterclockwiseOrder = [5, 2, 1, 0, 3, 4]
                        const currentOrderIdx = counterclockwiseOrder.indexOf(idx)
                        const inputs = e.target.closest('.lineup-grid')?.querySelectorAll('input')
                        if (inputs) {
                          for (let i = 1; i <= 6; i++) {
                            const nextOrderIdx = (currentOrderIdx + i) % 6
                            const nextIdx = counterclockwiseOrder[nextOrderIdx]
                            if (!inputs[nextIdx]?.value) {
                              inputs[nextIdx].focus()
                              return
                            }
                          }
                          e.target.blur()
                        }
                      }
                    }}
                    style={{
                      width: '60px',
                      height: '60px',
                      padding: '0',
                      fontSize: '18px',
                      fontWeight: 700,
                      textAlign: 'center',
                      background: dragOverPosition === idx ? 'rgba(74, 222, 128, 0.2)' : 'var(--bg-secondary)',
                      borderTop: 'none',
                      borderLeft: `2px solid ${errors[idx] ? '#ef4444' : dragOverPosition === idx ? '#4ade80' : 'rgba(255,255,255,0.2)'}`,
                      borderRight: `2px solid ${errors[idx] ? '#ef4444' : dragOverPosition === idx ? '#4ade80' : 'rgba(255,255,255,0.2)'}`,
                      borderBottom: `2px solid ${errors[idx] ? '#ef4444' : dragOverPosition === idx ? '#4ade80' : 'rgba(255,255,255,0.2)'}`,
                      borderRadius: '0 0 8px 8px',
                      color: 'var(--text)',
                      transition: 'background 0.15s, border-color 0.15s'
                    }}
                  />
                  {lineup[idx] && players?.find(p => String(p.number) === String(lineup[idx]) && p.isCaptain) && (
                    <div style={{
                      position: 'absolute',
                      top: '50%',
                      left: '50%',
                      transform: 'translate(-50%, -50%)',
                      width: '36px',
                      height: '36px',
                      borderRadius: '50%',
                      borderTop: '2px solid var(--accent)',
                      borderLeft: '2px solid var(--accent)',
                      borderRight: '2px solid var(--accent)',
                      borderBottom: '2px solid var(--accent)',
                      pointerEvents: 'none',
                      zIndex: 1
                    }} />
                  )}
                </div>
                <div style={{ color: '#ef4444', fontSize: '11px', marginTop: '4px', height: '14px', textAlign: 'center' }}>
                  {errors[idx] || ''}
                </div>
              </div>
            ))}

            {/* Bottom row (further from net) */}
            {[
              { idx: 3, pos: 'V' },
              { idx: 4, pos: 'VI' },
              { idx: 5, pos: 'I' }
            ].map(({ idx, pos }) => (
              <div
                key={`bottom-${idx}`}
                style={{
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'center',
                  marginTop: '8px'
                }}
              >
                {/* Position label rectangle */}
                <div style={{
                  width: '60px',
                  height: '24px',
                  background: 'rgba(255, 255, 255, 0.1)',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: '4px 4px 0 0',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: '12px',
                  fontWeight: 600,
                  color: 'var(--text)'
                }}>
                  {pos}
                </div>
                {/* Input square with captain indicator (circled number) - droppable */}
                <div
                  style={{ position: 'relative', width: '60px' }}
                  onDragOver={(e) => handleDragOver(e, idx)}
                  onDragLeave={handleDragLeave}
                  onDrop={(e) => handleDrop(e, idx)}
                >
                  <input
                    type="text"
                    inputMode="numeric"
                    min="1"
                    max="99"
                    value={lineup[idx]}
                    onChange={e => {
                      const val = e.target.value.replace(/[^0-9]/g, '')
                      if (val === '' || (Number(val) >= 1 && Number(val) <= 99)) {
                        handleInputChange(idx, val)
                      }
                    }}
                    onKeyDown={e => {
                      if (e.key === 'Enter') {
                        e.preventDefault()
                        // Counterclockwise order: I(5) → II(2) → III(1) → IV(0) → V(3) → VI(4) → I(5)
                        const counterclockwiseOrder = [5, 2, 1, 0, 3, 4]
                        const currentOrderIdx = counterclockwiseOrder.indexOf(idx)
                        const inputs = e.target.closest('.lineup-grid')?.querySelectorAll('input')
                        if (inputs) {
                          for (let i = 1; i <= 6; i++) {
                            const nextOrderIdx = (currentOrderIdx + i) % 6
                            const nextIdx = counterclockwiseOrder[nextOrderIdx]
                            if (!inputs[nextIdx]?.value) {
                              inputs[nextIdx].focus()
                              return
                            }
                          }
                          e.target.blur()
                        }
                      }
                    }}
                    style={{
                      width: '60px',
                      height: '60px',
                      padding: '0',
                      fontSize: '18px',
                      fontWeight: 700,
                      textAlign: 'center',
                      background: dragOverPosition === idx ? 'rgba(74, 222, 128, 0.2)' : 'var(--bg-secondary)',
                      borderTop: 'none',
                      borderLeft: `2px solid ${errors[idx] ? '#ef4444' : dragOverPosition === idx ? '#4ade80' : 'rgba(255,255,255,0.2)'}`,
                      borderRight: `2px solid ${errors[idx] ? '#ef4444' : dragOverPosition === idx ? '#4ade80' : 'rgba(255,255,255,0.2)'}`,
                      borderBottom: `2px solid ${errors[idx] ? '#ef4444' : dragOverPosition === idx ? '#4ade80' : 'rgba(255,255,255,0.2)'}`,
                      borderRadius: '0 0 8px 8px',
                      color: 'var(--text)',
                      transition: 'background 0.15s, border-color 0.15s'
                    }}
                  />
                  {lineup[idx] && players?.find(p => String(p.number) === String(lineup[idx]) && p.isCaptain) && (
                    <div style={{
                      position: 'absolute',
                      top: '50%',
                      left: '50%',
                      transform: 'translate(-50%, -50%)',
                      width: '36px',
                      height: '36px',
                      borderRadius: '50%',
                      borderTop: '2px solid var(--accent)',
                      borderLeft: '2px solid var(--accent)',
                      borderRight: '2px solid var(--accent)',
                      borderBottom: '2px solid var(--accent)',
                      pointerEvents: 'none',
                      zIndex: 1
                    }} />
                  )}
                </div>
                <div style={{ color: '#ef4444', fontSize: '11px', marginTop: '4px', height: '14px', textAlign: 'center' }}>
                  {errors[idx] || ''}
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Available players (excluding liberos and disqualified) */}
        <div style={{
          marginBottom: '16px',
          padding: '12px',
          background: 'rgba(255, 255, 255, 0.05)',
          borderRadius: '8px'
        }}>
          <div style={{
            fontSize: '13px',
            fontWeight: 600,
            color: 'var(--muted)',
            marginBottom: '8px'
          }}>
            {t('scoreboard.lineupModal.availablePlayers', 'Available Players:')}
          </div>
          <div style={{
            display: 'flex',
            flexWrap: 'wrap',
            gap: '8px'
          }}>
            {players?.filter(p => {
              // Exclude liberos
              if (p.libero && p.libero !== '') return false

              // Exclude players already in the lineup
              if (lineup.includes(String(p.number))) return false

              if (events) {
                // Exclude players substituted due to disqualification (cannot take part for rest of game)
                const wasDisqualifiedSub = events.some(e =>
                  e.type === 'substitution' &&
                  e.payload?.team === team &&
                  String(e.payload?.playerOut) === String(p.number) &&
                  e.payload?.isDisqualified === true
                )
                if (wasDisqualifiedSub) {
                  return false
                }

                // Exclude exceptionally substituted players (cannot take part for rest of game)
                const wasExceptionallySubstituted = events.some(e =>
                  e.type === 'substitution' &&
                  e.payload?.team === team &&
                  String(e.payload?.playerOut) === String(p.number) &&
                  e.payload?.isExceptional === true
                )
                if (wasExceptionallySubstituted) {
                  return false
                }

                // Exclude expelled players in the current set (cannot take part in this set)
                if (setIndex) {
                  // Check for substitution due to expulsion in current set
                  const wasExpelledSub = events.some(e =>
                    e.type === 'substitution' &&
                    e.payload?.team === team &&
                    String(e.payload?.playerOut) === String(p.number) &&
                    e.payload?.isExpelled === true &&
                    e.setIndex === setIndex
                  )
                  if (wasExpelledSub) {
                    return false
                  }

                  // Also check for sanction-based expulsion in current set
                  const isExpelledInSet = events.some(e =>
                    e.type === 'sanction' &&
                    e.payload?.team === team &&
                    String(e.payload?.playerNumber) === String(p.number) &&
                    e.payload?.type === 'expulsion' &&
                    e.setIndex === setIndex
                  )
                  if (isExpelledInSet) {
                    return false
                  }
                }

                // Also check for sanction-based disqualification
                const isDisqualified = events.some(e =>
                  e.type === 'sanction' &&
                  e.payload?.team === team &&
                  String(e.payload?.playerNumber) === String(p.number) &&
                  e.payload?.type === 'disqualification'
                )
                if (isDisqualified) {
                  return false
                }
              }

              return true
            }).sort((a, b) => a.number - b.number).map(p => (
              <div
                key={p.number}
                draggable
                onClick={() => handlePlayerClick(p.number)}
                onDragStart={(e) => handleDragStart(e, p.number)}
                onDragEnd={handleDragEnd}
                style={{
                  position: 'relative',
                  width: '40px',
                  height: '40px',
                  borderRadius: '50%',
                  background: draggedPlayer === p.number ? 'rgba(74, 222, 128, 0.4)' : 'rgba(74, 222, 128, 0.2)',
                  border: '2px solid #4ade80',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: '14px',
                  fontWeight: 700,
                  color: '#4ade80',
                  cursor: 'grab',
                  transition: 'all 0.2s',
                  userSelect: 'none',
                  opacity: draggedPlayer === p.number ? 0.5 : 1
                }}
                onMouseEnter={(e) => {
                  if (!draggedPlayer) {
                    e.currentTarget.style.background = 'rgba(74, 222, 128, 0.3)'
                    e.currentTarget.style.transform = 'scale(1.1)'
                  }
                }}
                onMouseLeave={(e) => {
                  if (!draggedPlayer) {
                    e.currentTarget.style.background = 'rgba(74, 222, 128, 0.2)'
                    e.currentTarget.style.transform = 'scale(1)'
                  }
                }}
                title={t('scoreboard.lineupModal.clickOrDragTooltip', 'Click or drag to assign to a position')}
              >
                {p.isCaptain && (
                  <span style={{
                    position: 'absolute',
                    top: '-4px',
                    right: '-4px',
                    width: '16px',
                    height: '16px',
                    borderRadius: '50%',
                    background: '#4ade80',
                    color: '#000',
                    fontSize: '10px',
                    fontWeight: 700,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    pointerEvents: 'none'
                  }}>
                    C
                  </span>
                )}
                {p.number}
              </div>
            ))}
          </div>
        </div>

        {/* Instruction text */}
        <div style={{
          textAlign: 'center',
          fontSize: '12px',
          color: 'var(--muted)',
          marginBottom: '16px',
          fontStyle: 'italic'
        }}>
          {t('scoreboard.lineupModal.dragInstruction', 'Please write the number, drag and drop it, or click on available player to fill each of the available positions')}
        </div>

        {/* Undo, Clear, and Rotate buttons - hidden when lineup is confirmed */}
        {!confirmMessage && (
          <>
            {/* Undo and Clear buttons row */}
            <div style={{
              display: 'flex',
              justifyContent: 'center',
              gap: '12px',
              marginBottom: '12px'
            }}>
              {editHistory.length > 0 && (
                <button
                  className="secondary"
                  onClick={handleUndoLastEdit}
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '6px',
                    padding: '8px 16px',
                    fontSize: '13px'
                  }}
                >
                  <span style={{ fontSize: '16px' }}>↩</span>
                  {t('scoreboard.lineupModal.undoLastEdit', 'Undo last edit')}
                </button>
              )}
              {lineup.some(v => v && v.trim() !== '') && (
                <button
                  className="secondary"
                  onClick={handleClearLineup}
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '6px',
                    padding: '8px 16px',
                    fontSize: '13px',
                    color: '#ef4444',
                    borderColor: 'rgba(239, 68, 68, 0.3)'
                  }}
                >
                  <span style={{ fontSize: '16px' }}>✕</span>
                  {t('scoreboard.lineupModal.clearLineup', 'Clear lineup')}
                </button>
              )}
            </div>

            {/* Rotate buttons row */}
            {lineup.some(v => v && v.trim() !== '') && (
              <div style={{
                display: 'flex',
                justifyContent: 'center',
                gap: '16px',
                marginBottom: '16px'
              }}>
                <button
                  className="secondary"
                  onClick={handleRotateClockwise}
                  title={t('scoreboard.lineupModal.rotateClockwise', 'Rotate clockwise')}
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    width: '44px',
                    height: '44px',
                    padding: '0',
                    fontSize: '20px',
                    borderRadius: '50%'
                  }}
                >
                  ↻
                </button>
                <span style={{
                  display: 'flex',
                  alignItems: 'center',
                  fontSize: '12px',
                  color: 'var(--muted)'
                }}>
                  {t('scoreboard.lineupModal.rotate', 'Rotate')}
                </span>

                <button
                  className="secondary"
                  onClick={handleRotateCounterClockwise}
                  title={t('scoreboard.lineupModal.rotateCounterclockwise', 'Rotate counterclockwise')}
                  style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    width: '44px',
                    height: '44px',
                    padding: '0',
                    fontSize: '20px',
                    borderRadius: '50%'
                  }}
                >
                  ↺
                </button>
              </div>
            )}
          </>
        )}

        {errors.length > 0 && (
          <div style={{
            padding: '12px',
            background: 'rgba(239, 68, 68, 0.1)',
            border: '1px solid #ef4444',
            borderRadius: '8px',
            marginBottom: '16px',
            color: '#ef4444',
            fontSize: '14px'
          }}>
            {t('scoreboard.lineupModal.validationError', 'Please check: All numbers must exist in roster, not be liberos, and not be duplicated.')}
          </div>
        )}

        {confirmMessage && (
          <div style={{
            padding: '12px',
            background: 'rgba(74, 222, 128, 0.1)',
            border: '1px solid #4ade80',
            borderRadius: '8px',
            marginBottom: '16px',
            color: '#4ade80',
            fontSize: '14px',
            fontWeight: 600,
            textAlign: 'center'
          }}>
            {confirmMessage}
          </div>
        )}

        <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>

          {confirmMessage === null && (
            <button onClick={handleConfirm}>
              {t('scoreboard.lineupModal.confirm', 'Confirm')}
            </button>
          )}

          <button
            className={confirmMessage === null ? 'secondary' : ''}
            onClick={() => {
              // If lineup was confirmed (confirmMessage exists), refresh state before closing
              if (confirmMessage) {
                onSave()
              } else {
                onClose()
              }
            }}
          >
            {t('scoreboard.lineupModal.close', 'Close')}
          </button>
          {confirmMessage !== null && (
            <button
              className="secondary"
              onClick={handleModify}
              style={{
                background: 'rgba(0, 0, 0, 1)',
                color: '#fff',
                border: '1px solid rgba(0, 0, 0, 1)',
                borderRadius: '10px',
                cursor: 'point  er'
              }}
            >
              {t('scoreboard.lineupModal.modify', 'Modify')}
            </button>
          )}
        </div>
      </div>
    </Modal>
  )
}

function SetStartTimeModal({ setIndex, defaultTime, onConfirm, onCancel }) {
  const [time, setTime] = useState(() => {
    // Extract local time from UTC ISO string
    const { time: localTime } = splitLocalDateTime(defaultTime)
    return localTime
  })

  const handleConfirm = () => {
    // Get the date component from defaultTime and combine with entered time
    const { date } = splitLocalDateTime(defaultTime)
    // Convert local time to UTC ISO string
    const isoString = parseLocalDateTimeToISO(date, time)
    onConfirm(isoString)
  }

  return (
    <Modal
      title={`Set ${setIndex} Start Time`}
      open={true}
      onClose={onCancel}
      width={400}
      hideCloseButton={true}
    >
      <div style={{ padding: '24px', textAlign: 'center' }}>
        <p style={{ marginBottom: '24px', fontSize: '16px' }}>
          Confirm the start time for Set {setIndex}:
        </p>
        <input
          type="time"
          value={time}
          onChange={(e) => setTime(e.target.value)}
          style={{
            padding: '12px 16px',
            fontSize: '18px',
            fontWeight: 600,
            textAlign: 'center',
            background: 'var(--bg-secondary)',
            border: `2px solid rgba(255,255,255,0.2)`,
            borderRadius: '8px',
            color: 'var(--text)',
            marginBottom: '24px',
            width: '150px'
          }}
        />
        <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
          <button
            onClick={handleConfirm}
            style={{
              padding: '12px 24px',
              fontSize: '14px',
              fontWeight: 600,
              background: 'var(--accent)',
              color: '#000',
              border: 'none',
              borderRadius: '8px',
              cursor: 'pointer'
            }}
          >
            Confirm
          </button>
          <button
            onClick={onCancel}
            style={{
              padding: '12px 24px',
              fontSize: '14px',
              fontWeight: 600,
              background: 'rgba(255, 255, 255, 0.1)',
              color: 'var(--text)',
              border: '1px solid rgba(255, 255, 255, 0.2)',
              borderRadius: '8px',
              cursor: 'pointer'
            }}
          >
            Cancel
          </button>
        </div>
      </div>
    </Modal>
  )
}

function ToSubDetailsModal({ type, side, timeoutDetails, substitutionDetails, teamName, onClose }) {
  return (
    <Modal
      title={type === 'timeout' ? `Timeouts - ${teamName}   ` : `Substitutions - ${teamName}  `}
      open={true}
      onClose={onClose}
      width={400}
    >
      <div style={{ padding: '20px', maxHeight: '80vh', overflowY: 'auto' }}>
        {type === 'timeout' ? (
          <div>
            {timeoutDetails && timeoutDetails.length > 0 ? (
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                {timeoutDetails.map((detail, index) => (
                  <div
                    key={index}
                    style={{
                      padding: '12px',
                      background: 'rgba(255, 255, 255, 0.05)',
                      borderRadius: '8px',
                      border: '1px solid rgba(255, 255, 255, 0.1)'
                    }}
                  >
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                      <div style={{ fontSize: '16px', fontWeight: 600 }}>
                        Timeout {detail.index}
                      </div>
                      <div style={{ fontSize: '18px', fontWeight: 700, color: 'var(--accent)' }}>
                        {detail.score}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div style={{ textAlign: 'center', color: 'var(--muted)', padding: '20px' }}>
                No timeouts taken yet
              </div>
            )}
          </div>
        ) : (
          <div>
            {substitutionDetails && substitutionDetails.length > 0 ? (
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                {substitutionDetails.map((detail, index) => (
                  <div
                    key={index}
                    style={{
                      padding: '12px',
                      background: 'rgba(255, 255, 255, 0.05)',
                      borderRadius: '8px',
                      border: '1px solid rgba(255, 255, 255, 0.1)'
                    }}
                  >
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                      <div style={{ fontSize: '16px', fontWeight: 600 }}>
                        Substitution {detail.index}
                      </div>
                      <div style={{ fontSize: '18px', fontWeight: 700, color: 'var(--accent)' }}>
                        {detail.score}
                      </div>
                    </div>
                    <div style={{ display: 'flex', gap: '16px', fontSize: '14px', color: 'var(--muted)' }}>
                      <div>
                        <span style={{ fontWeight: 600 }}>Position:</span> {detail.position}
                      </div>
                      <div>
                        <span style={{ fontWeight: 600 }}>Out:</span> {detail.playerOut}
                      </div>
                      <div>
                        <span style={{ fontWeight: 600 }}>In:</span> {detail.playerIn}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div style={{ textAlign: 'center', color: 'var(--muted)', padding: '20px' }}>
                No substitutions taken yet
              </div>
            )}
          </div>
        )}
      </div>
    </Modal>
  )
}

function SetEndTimeModal({ setIndex, winner, homePoints, awayPoints, defaultTime, teamAKey, leftIsHome, isMatchEnd, homeTeamName, awayTeamName, onConfirm, onDecisionChange }) {
  const [time, setTime] = useState(() => {
    // Extract local time from UTC ISO string
    const { time: localTime } = splitLocalDateTime(defaultTime)
    return localTime
  })
  const [isConfirming, setIsConfirming] = useState(false) // Prevent double-clicks

  // Get winner team name
  const winnerTeamName = winner === 'home' ? homeTeamName : awayTeamName

  // Calculate left and right team names and scores
  const leftTeamName = leftIsHome ? homeTeamName : awayTeamName
  const rightTeamName = leftIsHome ? awayTeamName : homeTeamName
  const leftScore = leftIsHome ? homePoints : awayPoints
  const rightScore = leftIsHome ? awayPoints : homePoints

  const handleConfirm = () => {
    if (isConfirming) return // Prevent double-clicks
    setIsConfirming(true)
    // Get the date component from defaultTime and combine with entered time
    const { date } = splitLocalDateTime(defaultTime)
    // Convert local time to UTC ISO string
    const isoString = parseLocalDateTimeToISO(date, time)
    onConfirm(isoString)
  }

  return (
    <Modal
      title={isMatchEnd ? 'Match End' : `Set ${setIndex} End`}
      open={true}
      onClose={onDecisionChange}
      width={400}
      hideCloseButton={true}
    >
      <div style={{ padding: '24px', textAlign: 'center' }}>
        <p style={{ marginBottom: '8px', fontSize: '14px', color: 'var(--muted)' }}>
          {leftTeamName} vs {rightTeamName}
        </p>
        <p style={{ marginBottom: '16px', fontSize: '36px', fontWeight: 700 }}>
          {leftScore} : {rightScore}
        </p>
        <p style={{ marginBottom: '24px', fontSize: '16px', fontWeight: 600, color: 'var(--accent)' }}>
          {isMatchEnd ? `${winnerTeamName} won the Match!` : `${winnerTeamName} wins!`}
        </p>
        <p style={{ marginBottom: '16px', fontSize: '16px' }}>
          Confirm the end time:
        </p>
        <input
          type="time"
          value={time}
          onChange={(e) => setTime(e.target.value)}
          style={{
            padding: '12px 16px',
            fontSize: '18px',
            fontWeight: 600,
            textAlign: 'center',
            background: 'var(--bg-secondary)',
            border: `2px solid rgba(255,255,255,0.2)`,
            borderRadius: '8px',
            color: 'var(--text)',
            marginBottom: '24px',
            width: '150px'
          }}
        />
        <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
          <button
            onClick={handleConfirm}
            disabled={isConfirming}
            style={{
              padding: '12px 24px',
              fontSize: '14px',
              fontWeight: 600,
              background: isConfirming ? 'var(--muted)' : 'var(--accent)',
              color: '#000',
              border: 'none',
              borderRadius: '8px',
              cursor: isConfirming ? 'not-allowed' : 'pointer',
              opacity: isConfirming ? 0.7 : 1
            }}
          >
            {isConfirming ? 'Confirming...' : 'Confirm'}
          </button>
          <button
            onClick={onDecisionChange}
            disabled={isConfirming}
            style={{
              padding: '12px 24px',
              fontSize: '14px',
              fontWeight: 600,
              background: '#eab308',
              color: '#000',
              border: 'none',
              borderRadius: '8px',
              cursor: isConfirming ? 'not-allowed' : 'pointer',
              opacity: isConfirming ? 0.7 : 1
            }}
          >
            Decision Change
          </button>
        </div>
      </div>
    </Modal>
  )
}
